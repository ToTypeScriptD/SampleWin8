//****************************************************************
//  Generated by:  ToTypeScriptD
//  Website:       http://github.com/ToTypeScriptD/ToTypeScriptD
//  Version:       v0.1.5070.37889 - SHA1:ce46bca - Debug
//  Date:          11/19/2013 11:19:11 PM
//
//  Assemblies:
//    Windows.ApplicationModel.winmd
//    Windows.Data.winmd
//    Windows.Devices.winmd
//    Windows.Foundation.winmd
//    Windows.Globalization.winmd
//    Windows.Graphics.winmd
//    Windows.Management.winmd
//    Windows.Media.winmd
//    Windows.Networking.winmd
//    Windows.Security.winmd
//    Windows.Storage.winmd
//    Windows.System.winmd
//    Windows.UI.winmd
//    Windows.Web.winmd
//
//****************************************************************




/*
 * This TypeScript definition file contains some core WinRT type 
 * definitions that the TypeScriptD output may need for things like async etc.
 *
 * Include this definition with the rest of your *.d.ts includes.
 *
 */


declare module ToTypeScriptD.WinRT {
    export interface IPromise<TResult> {
        then<U>(success?: (value: TResult) => IPromise<U>, error?: (error: any) => IPromise<U>, progress?: (progress: any) => void): IPromise<U>;
        then<U>(success?: (value: TResult) => IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => IPromise<U>, progress?: (progress: any) => void): IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => U, progress?: (progress: any) => void): IPromise<U>;
        done<U>(success?: (value: TResult) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
        cancel(): void;

        //operation: Windows.Foundation.IAsyncOperation<T>;
    }
}



declare module Windows.ApplicationModel.Activation {

    enum ActivationKind {
        launch,
        search,
        shareTarget,
        file,
        protocol,
        fileOpenPicker,
        fileSavePicker,
        cachedFileUpdater,
        contactPicker,
        device,
        printTaskSettings,
        cameraSettings
    }

    enum ApplicationExecutionState {
        notRunning,
        running,
        suspended,
        terminated,
        closedByUser
    }

    export class CachedFileUpdaterActivatedEventArgs implements Windows.ApplicationModel.Activation.ICachedFileUpdaterActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        cachedFileUpdaterUI: Windows.Storage.Provider.CachedFileUpdaterUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class CameraSettingsActivatedEventArgs implements Windows.ApplicationModel.Activation.ICameraSettingsActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        videoDeviceController: any;
        videoDeviceExtension: any;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class ContactPickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IContactPickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        contactPickerUI: Windows.ApplicationModel.Contacts.Provider.ContactPickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class DeviceActivatedEventArgs implements Windows.ApplicationModel.Activation.IDeviceActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        deviceInformationId: string;
        verb: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class FileActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        files: Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>;
        verb: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class FileOpenPickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileOpenPickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        fileOpenPickerUI: Windows.Storage.Pickers.Provider.FileOpenPickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class FileSavePickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        fileSavePickerUI: Windows.Storage.Pickers.Provider.FileSavePickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export interface IActivatedEventArgs {
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export interface ICachedFileUpdaterActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        cachedFileUpdaterUI: Windows.Storage.Provider.CachedFileUpdaterUI;
    }

    export interface ICameraSettingsActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        videoDeviceController: any;
        videoDeviceExtension: any;
    }

    export interface IContactPickerActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        contactPickerUI: Windows.ApplicationModel.Contacts.Provider.ContactPickerUI;
    }

    export interface IDeviceActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        deviceInformationId: string;
        verb: string;
    }

    export interface IFileActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        files: Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>;
        verb: string;
    }

    export interface IFileOpenPickerActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        fileOpenPickerUI: Windows.Storage.Pickers.Provider.FileOpenPickerUI;
    }

    export interface IFileSavePickerActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        fileSavePickerUI: Windows.Storage.Pickers.Provider.FileSavePickerUI;
    }

    export interface ILaunchActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        arguments: string;
        tileId: string;
    }

    export interface IPrintTaskSettingsActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        configuration: Windows.Devices.Printers.Extensions.PrintTaskConfiguration;
    }

    export interface IProtocolActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        uri: Windows.Foundation.Uri;
    }

    export interface ISearchActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        language: string;
        queryText: string;
    }

    export interface IShareTargetActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        shareOperation: Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
    }

    export interface ISplashScreen {
        imageLocation: Windows.Foundation.Rect;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): void;
        removeEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): void;
        ondismissed: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>) => void;

    }

    export class LaunchActivatedEventArgs implements Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        arguments: string;
        tileId: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class PrintTaskSettingsActivatedEventArgs implements Windows.ApplicationModel.Activation.IPrintTaskSettingsActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        configuration: Windows.Devices.Printers.Extensions.PrintTaskConfiguration;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class ProtocolActivatedEventArgs implements Windows.ApplicationModel.Activation.IProtocolActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        uri: Windows.Foundation.Uri;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class SearchActivatedEventArgs implements Windows.ApplicationModel.Activation.ISearchActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        language: string;
        queryText: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class ShareTargetActivatedEventArgs implements Windows.ApplicationModel.Activation.IShareTargetActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        shareOperation: Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class SplashScreen implements Windows.ApplicationModel.Activation.ISplashScreen {
        imageLocation: Windows.Foundation.Rect;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): void;
        removeEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): void;
        ondismissed: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>) => void;

    }

}
declare module Windows.ApplicationModel.Background {

    enum BackgroundAccessStatus {
        unspecified,
        allowedWithAlwaysOnRealTimeConnectivity,
        allowedMayUseActiveRealTimeConnectivity,
        denied
    }

    export class BackgroundExecutionManager {
        static requestAccessAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.BackgroundAccessStatus>;
        static requestAccessAsync(applicationId: string): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.BackgroundAccessStatus>;
        static removeAccess(): void;
        static removeAccess(applicationId: string): void;
        static getAccessStatus(): Windows.ApplicationModel.Background.BackgroundAccessStatus;
        static getAccessStatus(applicationId: string): Windows.ApplicationModel.Background.BackgroundAccessStatus;
    }

    export class BackgroundTaskBuilder implements Windows.ApplicationModel.Background.IBackgroundTaskBuilder {
        constructor();
        setTrigger(trigger: Windows.ApplicationModel.Background.IBackgroundTrigger): void;
        addCondition(condition: Windows.ApplicationModel.Background.IBackgroundCondition): void;
        register(): Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        name: string;
        taskEntryPoint: string;
    }

    export interface BackgroundTaskCanceledEventHandler {
        target: Windows.ApplicationModel.Background.IBackgroundTaskInstance;
        detail: any[];
        type: string;
    }

    enum BackgroundTaskCancellationReason {
        abort,
        terminating,
        loggingOff,
        servicingUpdate
    }

    export class BackgroundTaskCompletedEventArgs implements Windows.ApplicationModel.Background.IBackgroundTaskCompletedEventArgs {
        checkResult(): void;
        instanceId: string;
    }

    export interface BackgroundTaskCompletedEventHandler {
        target: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        detail: any[];
        type: string;
    }

    export class BackgroundTaskDeferral implements Windows.ApplicationModel.Background.IBackgroundTaskDeferral {
        complete(): void;
    }

    export class BackgroundTaskProgressEventArgs implements Windows.ApplicationModel.Background.IBackgroundTaskProgressEventArgs {
        instanceId: string;
        progress: number;
    }

    export interface BackgroundTaskProgressEventHandler {
        target: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        detail: any[];
        type: string;
    }

    export class BackgroundTaskRegistration implements Windows.ApplicationModel.Background.IBackgroundTaskRegistration {
        unregister(cancelTask: boolean): void;
        name: string;
        taskId: string;
        static allTasks: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Background.IBackgroundTaskRegistration>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): void;
        removeEventListener(eventName: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): void;
        oncompleted: (ev: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler) => void;
        addEventListener(eventName: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): void;
        removeEventListener(eventName: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): void;
        onprogress: (ev: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler) => void;

    }

    export interface IBackgroundCondition {
    }

    export interface IBackgroundTask {
        run(taskInstance: Windows.ApplicationModel.Background.IBackgroundTaskInstance): void;
    }

    export interface IBackgroundTaskBuilder {
        setTrigger(trigger: Windows.ApplicationModel.Background.IBackgroundTrigger): void;
        addCondition(condition: Windows.ApplicationModel.Background.IBackgroundCondition): void;
        register(): Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        name: string;
        taskEntryPoint: string;
    }

    export interface IBackgroundTaskCompletedEventArgs {
        checkResult(): void;
        instanceId: string;
    }

    export interface IBackgroundTaskDeferral {
        complete(): void;
    }

    export interface IBackgroundTaskInstance {
        getDeferral(): Windows.ApplicationModel.Background.BackgroundTaskDeferral;
        instanceId: string;
        progress: number;
        suspendedCount: number;
        task: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        triggerDetails: any;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): void;
        removeEventListener(eventName: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): void;
        oncanceled: (ev: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler) => void;

    }

    export interface IBackgroundTaskProgressEventArgs {
        instanceId: string;
        progress: number;
    }

    export interface IBackgroundTaskRegistration {
        unregister(cancelTask: boolean): void;
        name: string;
        taskId: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): void;
        removeEventListener(eventName: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): void;
        oncompleted: (ev: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler) => void;
        addEventListener(eventName: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): void;
        removeEventListener(eventName: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): void;
        onprogress: (ev: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler) => void;

    }

    export interface IBackgroundTrigger {
    }

    export interface IMaintenanceTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
        freshnessTime: number;
        oneShot: boolean;
    }

    export interface INetworkOperatorHotspotAuthenticationTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
    }

    export interface INetworkOperatorNotificationTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
        networkAccountId: string;
    }

    export interface ISystemCondition extends Windows.ApplicationModel.Background.IBackgroundCondition {
        conditionType: Windows.ApplicationModel.Background.SystemConditionType;
    }

    export interface ISystemTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
        oneShot: boolean;
        triggerType: Windows.ApplicationModel.Background.SystemTriggerType;
    }

    export interface ITimeTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
        freshnessTime: number;
        oneShot: boolean;
    }

    export class MaintenanceTrigger implements Windows.ApplicationModel.Background.IMaintenanceTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(freshnessTime: number, oneShot: boolean);
        freshnessTime: number;
        oneShot: boolean;
    }

    export class NetworkOperatorHotspotAuthenticationTrigger implements Windows.ApplicationModel.Background.INetworkOperatorHotspotAuthenticationTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor();
    }

    export class NetworkOperatorNotificationTrigger implements Windows.ApplicationModel.Background.INetworkOperatorNotificationTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(networkAccountId: string);
        networkAccountId: string;
    }

    export class PushNotificationTrigger implements Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(applicationId: string);
        constructor();
    }

    export class SystemCondition implements Windows.ApplicationModel.Background.ISystemCondition, Windows.ApplicationModel.Background.IBackgroundCondition {
        constructor(conditionType: Windows.ApplicationModel.Background.SystemConditionType);
        conditionType: Windows.ApplicationModel.Background.SystemConditionType;
    }

    enum SystemConditionType {
        invalid,
        userPresent,
        userNotPresent,
        internetAvailable,
        internetNotAvailable,
        sessionConnected,
        sessionDisconnected
    }

    export class SystemTrigger implements Windows.ApplicationModel.Background.ISystemTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(triggerType: Windows.ApplicationModel.Background.SystemTriggerType, oneShot: boolean);
        oneShot: boolean;
        triggerType: Windows.ApplicationModel.Background.SystemTriggerType;
    }

    enum SystemTriggerType {
        invalid,
        smsReceived,
        userPresent,
        userAway,
        networkStateChange,
        controlChannelReset,
        internetAvailable,
        sessionConnected,
        servicingComplete,
        lockScreenApplicationAdded,
        lockScreenApplicationRemoved,
        timeZoneChange,
        onlineIdConnectedStateChange
    }

    export class TimeTrigger implements Windows.ApplicationModel.Background.ITimeTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(freshnessTime: number, oneShot: boolean);
        freshnessTime: number;
        oneShot: boolean;
    }

}
declare module Windows.ApplicationModel.Contacts {

    export class Contact implements Windows.ApplicationModel.Contacts.IContact {
        constructor();
        fields: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.IContactField>;
        name: string;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
    }

    export class ContactField implements Windows.ApplicationModel.Contacts.IContactField {
        constructor(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType);
        constructor(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory);
        constructor(name: string, value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory);
        category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
        name: string;
        type: Windows.ApplicationModel.Contacts.ContactFieldType;
        value: string;
    }

    enum ContactFieldCategory {
        none,
        home,
        work,
        mobile,
        other
    }

    export class ContactFieldFactory implements Windows.ApplicationModel.Contacts.IContactFieldFactory, Windows.ApplicationModel.Contacts.IContactLocationFieldFactory, Windows.ApplicationModel.Contacts.IContactInstantMessageFieldFactory {
        constructor();
        createField(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType): Windows.ApplicationModel.Contacts.ContactField;
        createField(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactField;
        createField(name: string, value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactField;
        createLocation(unstructuredAddress: string): Windows.ApplicationModel.Contacts.ContactLocationField;
        createLocation(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactLocationField;
        createLocation(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string): Windows.ApplicationModel.Contacts.ContactLocationField;
        createInstantMessage(userName: string): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
        createInstantMessage(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
        createInstantMessage(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows.Foundation.Uri): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
    }

    enum ContactFieldType {
        email,
        phoneNumber,
        location,
        instantMessage,
        custom
    }

    export class ContactInformation implements Windows.ApplicationModel.Contacts.IContactInformation {
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        queryCustomFields(customName: string): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        customFields: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        emails: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        instantMessages: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInstantMessageField>;
        locations: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactLocationField>;
        name: string;
        phoneNumbers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
    }

    export class ContactInstantMessageField implements Windows.ApplicationModel.Contacts.IContactInstantMessageField, Windows.ApplicationModel.Contacts.IContactField {
        constructor(userName: string);
        constructor(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory);
        constructor(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows.Foundation.Uri);
        displayText: string;
        launchUri: Windows.Foundation.Uri;
        service: string;
        userName: string;
        category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
        name: string;
        type: Windows.ApplicationModel.Contacts.ContactFieldType;
        value: string;
    }

    export class ContactLocationField implements Windows.ApplicationModel.Contacts.IContactLocationField, Windows.ApplicationModel.Contacts.IContactField {
        constructor(unstructuredAddress: string);
        constructor(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory);
        constructor(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string);
        city: string;
        country: string;
        postalCode: string;
        region: string;
        street: string;
        unstructuredAddress: string;
        category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
        name: string;
        type: Windows.ApplicationModel.Contacts.ContactFieldType;
        value: string;
    }

    export class ContactPicker implements Windows.ApplicationModel.Contacts.IContactPicker {
        constructor();
        pickSingleContactAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Contacts.ContactInformation>;
        pickMultipleContactsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInformation>>;
        commitButtonText: string;
        desiredFields: Windows.Foundation.Collections.IVector<string>;
        selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
    }

    enum ContactSelectionMode {
        contacts,
        fields
    }

    export interface IContact {
        fields: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.IContactField>;
        name: string;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
    }

    export interface IContactField {
        category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
        name: string;
        type: Windows.ApplicationModel.Contacts.ContactFieldType;
        value: string;
    }

    export interface IContactFieldFactory {
        createField(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType): Windows.ApplicationModel.Contacts.ContactField;
        createField(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactField;
        createField(name: string, value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactField;
    }

    export interface IContactInformation {
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        queryCustomFields(customName: string): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        customFields: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        emails: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        instantMessages: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInstantMessageField>;
        locations: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactLocationField>;
        name: string;
        phoneNumbers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
    }

    export interface IContactInstantMessageField extends Windows.ApplicationModel.Contacts.IContactField {
        displayText: string;
        launchUri: Windows.Foundation.Uri;
        service: string;
        userName: string;
    }

    export interface IContactInstantMessageFieldFactory {
        createInstantMessage(userName: string): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
        createInstantMessage(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
        createInstantMessage(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows.Foundation.Uri): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
    }

    export interface IContactLocationField extends Windows.ApplicationModel.Contacts.IContactField {
        city: string;
        country: string;
        postalCode: string;
        region: string;
        street: string;
        unstructuredAddress: string;
    }

    export interface IContactLocationFieldFactory {
        createLocation(unstructuredAddress: string): Windows.ApplicationModel.Contacts.ContactLocationField;
        createLocation(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactLocationField;
        createLocation(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string): Windows.ApplicationModel.Contacts.ContactLocationField;
    }

    export interface IContactPicker {
        pickSingleContactAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Contacts.ContactInformation>;
        pickMultipleContactsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInformation>>;
        commitButtonText: string;
        desiredFields: Windows.Foundation.Collections.IVector<string>;
        selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
    }

    export class KnownContactField {
        static convertNameToType(name: string): Windows.ApplicationModel.Contacts.ContactFieldType;
        static convertTypeToName(type: Windows.ApplicationModel.Contacts.ContactFieldType): string;
        static email: string;
        static instantMessage: string;
        static location: string;
        static phoneNumber: string;
    }

}
declare module Windows.ApplicationModel.Contacts.Provider {

    enum AddContactResult {
        added,
        alreadyAdded,
        unavailable
    }

    export class ContactPickerUI implements Windows.ApplicationModel.Contacts.Provider.IContactPickerUI {
        addContact(id: string, contact: Windows.ApplicationModel.Contacts.Contact): Windows.ApplicationModel.Contacts.Provider.AddContactResult;
        removeContact(id: string): void;
        containsContact(id: string): boolean;
        desiredFields: Windows.Foundation.Collections.IVectorView<string>;
        selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): void;
        removeEventListener(eventName: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): void;
        oncontactremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>) => void;

    }

    export class ContactRemovedEventArgs implements Windows.ApplicationModel.Contacts.Provider.IContactRemovedEventArgs {
        id: string;
    }

    export interface IContactPickerUI {
        addContact(id: string, contact: Windows.ApplicationModel.Contacts.Contact): Windows.ApplicationModel.Contacts.Provider.AddContactResult;
        removeContact(id: string): void;
        containsContact(id: string): boolean;
        desiredFields: Windows.Foundation.Collections.IVectorView<string>;
        selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): void;
        removeEventListener(eventName: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): void;
        oncontactremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>) => void;

    }

    export interface IContactRemovedEventArgs {
        id: string;
    }

}
declare module Windows.ApplicationModel.Core {

    export class CoreApplication {
        static incrementApplicationUseCount(): void;
        static decrementApplicationUseCount(): void;
        static createNewView(runtimeType: string, entryPoint: string): Windows.ApplicationModel.Core.CoreApplicationView;
        static exit(): void;
        static getCurrentView(): Windows.ApplicationModel.Core.CoreApplicationView;
        static run(viewSource: Windows.ApplicationModel.Core.IFrameworkViewSource): void;
        static runWithActivationFactories(activationFactoryCallback: Windows.Foundation.IGetActivationFactory): void;
        static mainView: Windows.ApplicationModel.Core.CoreApplicationView;
        static views: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Core.CoreApplicationView>;
        static id: string;
        static properties: Windows.Foundation.Collections.IPropertySet;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "exiting", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "exiting", listener: Windows.Foundation.EventHandler<any>): void;
        onexiting: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "resuming", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "resuming", listener: Windows.Foundation.EventHandler<any>): void;
        onresuming: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "suspending", listener: Windows.Foundation.EventHandler<Windows.ApplicationModel.SuspendingEventArgs>): void;
        removeEventListener(eventName: "suspending", listener: Windows.Foundation.EventHandler<Windows.ApplicationModel.SuspendingEventArgs>): void;
        onsuspending: (ev: Windows.Foundation.EventHandler<Windows.ApplicationModel.SuspendingEventArgs>) => void;

    }

    export class CoreApplicationView implements Windows.ApplicationModel.Core.ICoreApplicationView {
        coreWindow: Windows.UI.Core.CoreWindow;
        isHosted: boolean;
        isMain: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>) => void;

    }

    export interface ICoreApplicationView {
        coreWindow: Windows.UI.Core.CoreWindow;
        isHosted: boolean;
        isMain: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>) => void;

    }

    export interface IFrameworkView {
        initialize(applicationView: Windows.ApplicationModel.Core.CoreApplicationView): void;
        setWindow(window: Windows.UI.Core.CoreWindow): void;
        load(entryPoint: string): void;
        run(): void;
        uninitialize(): void;
    }

    export interface IFrameworkViewSource {
        createView(): Windows.ApplicationModel.Core.IFrameworkView;
    }

}
declare module Windows.ApplicationModel.DataTransfer {

    export class Clipboard {
        static getContent(): Windows.ApplicationModel.DataTransfer.DataPackageView;
        static setContent(content: Windows.ApplicationModel.DataTransfer.DataPackage): void;
        static flush(): void;
        static clear(): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentchanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "contentchanged", listener: Windows.Foundation.EventHandler<any>): void;
        oncontentchanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class DataPackage implements Windows.ApplicationModel.DataTransfer.IDataPackage {
        constructor();
        getView(): Windows.ApplicationModel.DataTransfer.DataPackageView;
        setData(formatId: string, value: any): void;
        setDataProvider(formatId: string, delayRenderer: Windows.ApplicationModel.DataTransfer.DataProviderHandler): void;
        setText(value: string): void;
        setUri(value: Windows.Foundation.Uri): void;
        setHtmlFormat(value: string): void;
        setRtf(value: string): void;
        setBitmap(value: Windows.Storage.Streams.RandomAccessStreamReference): void;
        setStorageItems(value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>): void;
        setStorageItems(value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>, readOnly: boolean): void;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
        requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
        resourceMap: Windows.Foundation.Collections.IMap<string,Windows.Storage.Streams.RandomAccessStreamReference>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): void;
        removeEventListener(eventName: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): void;
        ondestroyed: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>) => void;
        addEventListener(eventName: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): void;
        removeEventListener(eventName: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): void;
        onoperationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>) => void;

    }

    enum DataPackageOperation {
        none,
        copy,
        move,
        link
    }

    export class DataPackagePropertySet implements Windows.ApplicationModel.DataTransfer.IDataPackagePropertySet, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        applicationListingUri: Windows.Foundation.Uri;
        applicationName: string;
        description: string;
        fileTypes: Windows.Foundation.Collections.IVector<string>;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
        title: string;
        size: number;
    }

    export class DataPackagePropertySetView implements Windows.ApplicationModel.DataTransfer.IDataPackagePropertySetView, Windows.Foundation.Collections.IMapView<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        lookup(key: string): any;
        hasKey(key: string): boolean;
        split(): DataPackagePropertySetView_split_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        applicationListingUri: Windows.Foundation.Uri;
        applicationName: string;
        description: string;
        fileTypes: Windows.Foundation.Collections.IVectorView<string>;
        thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
        title: string;
        size: number;
    }

    interface DataPackagePropertySetView_split_OUT {
        first: Windows.Foundation.Collections.IMapView<string,any>;
        second: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export class DataPackageView implements Windows.ApplicationModel.DataTransfer.IDataPackageView {
        reportOperationCompleted(value: Windows.ApplicationModel.DataTransfer.DataPackageOperation): void;
        contains(formatId: string): boolean;
        getDataAsync(formatId: string): Windows.Foundation.IAsyncOperation<any>;
        getTextAsync(): Windows.Foundation.IAsyncOperation<string>;
        getTextAsync(formatId: string): Windows.Foundation.IAsyncOperation<string>;
        getUriAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Uri>;
        getHtmlFormatAsync(): Windows.Foundation.IAsyncOperation<string>;
        getResourceMapAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMapView<string,Windows.Storage.Streams.RandomAccessStreamReference>>;
        getRtfAsync(): Windows.Foundation.IAsyncOperation<string>;
        getBitmapAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.RandomAccessStreamReference>;
        getStorageItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        availableFormats: Windows.Foundation.Collections.IVectorView<string>;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView;
        requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
    }

    export class DataProviderDeferral implements Windows.ApplicationModel.DataTransfer.IDataProviderDeferral {
        complete(): void;
    }

    export interface DataProviderHandler {
        target: Windows.ApplicationModel.DataTransfer.DataProviderRequest;
        detail: any[];
        type: string;
    }

    export class DataProviderRequest implements Windows.ApplicationModel.DataTransfer.IDataProviderRequest {
        getDeferral(): Windows.ApplicationModel.DataTransfer.DataProviderDeferral;
        setData(value: any): void;
        deadline: Date;
        formatId: string;
    }

    export class DataRequest implements Windows.ApplicationModel.DataTransfer.IDataRequest {
        failWithDisplayText(value: string): void;
        getDeferral(): Windows.ApplicationModel.DataTransfer.DataRequestDeferral;
        data: Windows.ApplicationModel.DataTransfer.DataPackage;
        deadline: Date;
    }

    export class DataRequestDeferral implements Windows.ApplicationModel.DataTransfer.IDataRequestDeferral {
        complete(): void;
    }

    export class DataRequestedEventArgs implements Windows.ApplicationModel.DataTransfer.IDataRequestedEventArgs {
        request: Windows.ApplicationModel.DataTransfer.DataRequest;
    }

    export class DataTransferManager implements Windows.ApplicationModel.DataTransfer.IDataTransferManager {
        static showShareUI(): void;
        static getForCurrentView(): Windows.ApplicationModel.DataTransfer.DataTransferManager;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): void;
        removeEventListener(eventName: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): void;
        ondatarequested: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>) => void;
        addEventListener(eventName: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): void;
        removeEventListener(eventName: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): void;
        ontargetapplicationchosen: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>) => void;

    }

    export class HtmlFormatHelper {
        static getStaticFragment(htmlFormat: string): string;
        static createHtmlFormat(htmlFragment: string): string;
    }

    export interface IDataPackage {
        getView(): Windows.ApplicationModel.DataTransfer.DataPackageView;
        setData(formatId: string, value: any): void;
        setDataProvider(formatId: string, delayRenderer: Windows.ApplicationModel.DataTransfer.DataProviderHandler): void;
        setText(value: string): void;
        setUri(value: Windows.Foundation.Uri): void;
        setHtmlFormat(value: string): void;
        setRtf(value: string): void;
        setBitmap(value: Windows.Storage.Streams.RandomAccessStreamReference): void;
        setStorageItems(value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>): void;
        setStorageItems(value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>, readOnly: boolean): void;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
        requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
        resourceMap: Windows.Foundation.Collections.IMap<string,Windows.Storage.Streams.RandomAccessStreamReference>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): void;
        removeEventListener(eventName: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): void;
        ondestroyed: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>) => void;
        addEventListener(eventName: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): void;
        removeEventListener(eventName: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): void;
        onoperationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>) => void;

    }

    export interface IDataPackagePropertySet extends Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        applicationListingUri: Windows.Foundation.Uri;
        applicationName: string;
        description: string;
        fileTypes: Windows.Foundation.Collections.IVector<string>;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
        title: string;
    }

    export interface IDataPackagePropertySetView extends Windows.Foundation.Collections.IMapView<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        applicationListingUri: Windows.Foundation.Uri;
        applicationName: string;
        description: string;
        fileTypes: Windows.Foundation.Collections.IVectorView<string>;
        thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
        title: string;
    }

    export interface IDataPackageView {
        reportOperationCompleted(value: Windows.ApplicationModel.DataTransfer.DataPackageOperation): void;
        contains(formatId: string): boolean;
        getDataAsync(formatId: string): Windows.Foundation.IAsyncOperation<any>;
        getTextAsync(): Windows.Foundation.IAsyncOperation<string>;
        getTextAsync(formatId: string): Windows.Foundation.IAsyncOperation<string>;
        getUriAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Uri>;
        getHtmlFormatAsync(): Windows.Foundation.IAsyncOperation<string>;
        getResourceMapAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMapView<string,Windows.Storage.Streams.RandomAccessStreamReference>>;
        getRtfAsync(): Windows.Foundation.IAsyncOperation<string>;
        getBitmapAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.RandomAccessStreamReference>;
        getStorageItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        availableFormats: Windows.Foundation.Collections.IVectorView<string>;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView;
        requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
    }

    export interface IDataProviderDeferral {
        complete(): void;
    }

    export interface IDataProviderRequest {
        getDeferral(): Windows.ApplicationModel.DataTransfer.DataProviderDeferral;
        setData(value: any): void;
        deadline: Date;
        formatId: string;
    }

    export interface IDataRequest {
        failWithDisplayText(value: string): void;
        getDeferral(): Windows.ApplicationModel.DataTransfer.DataRequestDeferral;
        data: Windows.ApplicationModel.DataTransfer.DataPackage;
        deadline: Date;
    }

    export interface IDataRequestDeferral {
        complete(): void;
    }

    export interface IDataRequestedEventArgs {
        request: Windows.ApplicationModel.DataTransfer.DataRequest;
    }

    export interface IDataTransferManager {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): void;
        removeEventListener(eventName: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): void;
        ondatarequested: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>) => void;
        addEventListener(eventName: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): void;
        removeEventListener(eventName: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): void;
        ontargetapplicationchosen: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>) => void;

    }

    export interface IOperationCompletedEventArgs {
        operation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
    }

    export interface ITargetApplicationChosenEventArgs {
        applicationName: string;
    }

    export class OperationCompletedEventArgs implements Windows.ApplicationModel.DataTransfer.IOperationCompletedEventArgs {
        operation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
    }

    export class StandardDataFormats {
        static bitmap: string;
        static html: string;
        static rtf: string;
        static storageItems: string;
        static text: string;
        static uri: string;
    }

    export class TargetApplicationChosenEventArgs implements Windows.ApplicationModel.DataTransfer.ITargetApplicationChosenEventArgs {
        applicationName: string;
    }

}
declare module Windows.ApplicationModel.DataTransfer.ShareTarget {

    export interface IQuickLink {
        id: string;
        supportedDataFormats: Windows.Foundation.Collections.IVector<string>;
        supportedFileTypes: Windows.Foundation.Collections.IVector<string>;
        thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
        title: string;
    }

    export interface IShareOperation {
        removeThisQuickLink(): void;
        reportStarted(): void;
        reportDataRetrieved(): void;
        reportSubmittedBackgroundTask(): void;
        reportCompleted(quicklink: Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink): void;
        reportCompleted(): void;
        reportError(value: string): void;
        data: Windows.ApplicationModel.DataTransfer.DataPackageView;
        quickLinkId: string;
    }

    export class QuickLink implements Windows.ApplicationModel.DataTransfer.ShareTarget.IQuickLink {
        constructor();
        id: string;
        supportedDataFormats: Windows.Foundation.Collections.IVector<string>;
        supportedFileTypes: Windows.Foundation.Collections.IVector<string>;
        thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
        title: string;
    }

    export class ShareOperation implements Windows.ApplicationModel.DataTransfer.ShareTarget.IShareOperation {
        removeThisQuickLink(): void;
        reportStarted(): void;
        reportDataRetrieved(): void;
        reportSubmittedBackgroundTask(): void;
        reportCompleted(quicklink: Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink): void;
        reportCompleted(): void;
        reportError(value: string): void;
        data: Windows.ApplicationModel.DataTransfer.DataPackageView;
        quickLinkId: string;
    }

}
declare module Windows.ApplicationModel {

    export class DesignMode {
        static designModeEnabled: boolean;
    }

    export interface IPackage {
        dependencies: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Package>;
        id: Windows.ApplicationModel.PackageId;
        installedLocation: Windows.Storage.StorageFolder;
        isFramework: boolean;
    }

    export interface IPackageId {
        architecture: Windows.System.ProcessorArchitecture;
        familyName: string;
        fullName: string;
        name: string;
        publisher: string;
        publisherId: string;
        resourceId: string;
        version: Windows.ApplicationModel.PackageVersion;
    }

    export interface ISuspendingDeferral {
        complete(): void;
    }

    export interface ISuspendingEventArgs {
        suspendingOperation: Windows.ApplicationModel.SuspendingOperation;
    }

    export interface ISuspendingOperation {
        getDeferral(): Windows.ApplicationModel.SuspendingDeferral;
        deadline: Date;
    }

    export class Package implements Windows.ApplicationModel.IPackage {
        dependencies: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Package>;
        id: Windows.ApplicationModel.PackageId;
        installedLocation: Windows.Storage.StorageFolder;
        isFramework: boolean;
        static current: Windows.ApplicationModel.Package;
    }

    export class PackageId implements Windows.ApplicationModel.IPackageId {
        architecture: Windows.System.ProcessorArchitecture;
        familyName: string;
        fullName: string;
        name: string;
        publisher: string;
        publisherId: string;
        resourceId: string;
        version: Windows.ApplicationModel.PackageVersion;
    }

    export class PackageVersion {
        major: number;
        minor: number;
        build: number;
        revision: number;
    }

    export class SuspendingDeferral implements Windows.ApplicationModel.ISuspendingDeferral {
        complete(): void;
    }

    export class SuspendingEventArgs implements Windows.ApplicationModel.ISuspendingEventArgs {
        suspendingOperation: Windows.ApplicationModel.SuspendingOperation;
    }

    export class SuspendingOperation implements Windows.ApplicationModel.ISuspendingOperation {
        getDeferral(): Windows.ApplicationModel.SuspendingDeferral;
        deadline: Date;
    }

}
declare module Windows.ApplicationModel.Resources.Core {

    export interface INamedResource {
        resolve(): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        resolve(resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        resolveAll(): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        resolveAll(resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        candidates: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        uri: Windows.Foundation.Uri;
    }

    export interface IResourceCandidate {
        getValueAsFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getQualifierValue(qualifierName: string): string;
        isDefault: boolean;
        isMatch: boolean;
        isMatchAsDefault: boolean;
        qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceQualifier>;
        valueAsString: string;
    }

    export interface IResourceContext {
        reset(): void;
        reset(qualifierNames: Windows.Foundation.Collections.IIterable<string>): void;
        overrideToMatch(result: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier>): void;
        clone(): Windows.ApplicationModel.Resources.Core.ResourceContext;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        qualifierValues: Windows.Foundation.Collections.IObservableMap<string,string>;
    }

    export interface IResourceManager {
        loadPriFiles(files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>): void;
        unloadPriFiles(files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>): void;
        allResourceMaps: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
        defaultContext: Windows.ApplicationModel.Resources.Core.ResourceContext;
        mainResourceMap: Windows.ApplicationModel.Resources.Core.ResourceMap;
    }

    export interface IResourceMap extends Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.NamedResource>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>> {
        getValue(resource: string): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        getValue(resource: string, context: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        getSubtree(reference: string): Windows.ApplicationModel.Resources.Core.ResourceMap;
        uri: Windows.Foundation.Uri;
    }

    export interface IResourceQualifier {
        isDefault: boolean;
        isMatch: boolean;
        qualifierName: string;
        qualifierValue: string;
        score: number;
    }

    export class NamedResource implements Windows.ApplicationModel.Resources.Core.INamedResource {
        resolve(): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        resolve(resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        resolveAll(): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        resolveAll(resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        candidates: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        uri: Windows.Foundation.Uri;
    }

    export class ResourceCandidate implements Windows.ApplicationModel.Resources.Core.IResourceCandidate {
        getValueAsFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getQualifierValue(qualifierName: string): string;
        isDefault: boolean;
        isMatch: boolean;
        isMatchAsDefault: boolean;
        qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceQualifier>;
        valueAsString: string;
    }

    export class ResourceCandidateVectorView implements Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>, Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceCandidate> {
        getAt(index: number): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        indexOf(value: Windows.ApplicationModel.Resources.Core.ResourceCandidate): ResourceCandidateVectorView_indexOf_OUT;
        getMany(startIndex: number): ResourceCandidateVectorView_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        size: number;
    }

    interface ResourceCandidateVectorView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ResourceCandidateVectorView_getMany_OUT {
        __returnValue: number;
        items: Windows.ApplicationModel.Resources.Core.ResourceCandidate[];
    }

    export class ResourceContext implements Windows.ApplicationModel.Resources.Core.IResourceContext {
        constructor();
        reset(): void;
        reset(qualifierNames: Windows.Foundation.Collections.IIterable<string>): void;
        overrideToMatch(result: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier>): void;
        clone(): Windows.ApplicationModel.Resources.Core.ResourceContext;
        static createMatchingContext(result: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier>): Windows.ApplicationModel.Resources.Core.ResourceContext;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        qualifierValues: Windows.Foundation.Collections.IObservableMap<string,string>;
    }

    export class ResourceContextLanguagesVectorView implements Windows.Foundation.Collections.IVectorView<string>, Windows.Foundation.Collections.IIterable<string> {
        getAt(index: number): string;
        indexOf(value: string): ResourceContextLanguagesVectorView_indexOf_OUT;
        getMany(startIndex: number): ResourceContextLanguagesVectorView_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<string>;
        size: number;
    }

    interface ResourceContextLanguagesVectorView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ResourceContextLanguagesVectorView_getMany_OUT {
        __returnValue: number;
        items: string[];
    }

    export class ResourceManager implements Windows.ApplicationModel.Resources.Core.IResourceManager {
        loadPriFiles(files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>): void;
        unloadPriFiles(files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>): void;
        static isResourceReference(resourceReference: string): boolean;
        allResourceMaps: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
        defaultContext: Windows.ApplicationModel.Resources.Core.ResourceContext;
        mainResourceMap: Windows.ApplicationModel.Resources.Core.ResourceMap;
        static current: Windows.ApplicationModel.Resources.Core.ResourceManager;
    }

    export class ResourceMap implements Windows.ApplicationModel.Resources.Core.IResourceMap, Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.NamedResource>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>> {
        getValue(resource: string): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        getValue(resource: string, context: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        getSubtree(reference: string): Windows.ApplicationModel.Resources.Core.ResourceMap;
        lookup(key: string): Windows.ApplicationModel.Resources.Core.NamedResource;
        hasKey(key: string): boolean;
        split(): ResourceMap_split_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>>;
        uri: Windows.Foundation.Uri;
        size: number;
    }

    interface ResourceMap_split_OUT {
        first: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.NamedResource>;
        second: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.NamedResource>;
    }

    export class ResourceMapIterator implements Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>> {
        moveNext(): boolean;
        getMany(): ResourceMapIterator_getMany_OUT;
        current: Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>;
        hasCurrent: boolean;
    }

    interface ResourceMapIterator_getMany_OUT {
        __returnValue: number;
        items: Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>[];
    }

    export class ResourceMapMapView implements Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>> {
        lookup(key: string): Windows.ApplicationModel.Resources.Core.ResourceMap;
        hasKey(key: string): boolean;
        split(): ResourceMapMapView_split_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>>;
        size: number;
    }

    interface ResourceMapMapView_split_OUT {
        first: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
        second: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
    }

    export class ResourceMapMapViewIterator implements Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>> {
        moveNext(): boolean;
        getMany(): ResourceMapMapViewIterator_getMany_OUT;
        current: Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
        hasCurrent: boolean;
    }

    interface ResourceMapMapViewIterator_getMany_OUT {
        __returnValue: number;
        items: Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>[];
    }

    export class ResourceQualifier implements Windows.ApplicationModel.Resources.Core.IResourceQualifier {
        isDefault: boolean;
        isMatch: boolean;
        qualifierName: string;
        qualifierValue: string;
        score: number;
    }

    export class ResourceQualifierMapView implements Windows.Foundation.Collections.IMapView<string,string>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,string>> {
        lookup(key: string): string;
        hasKey(key: string): boolean;
        split(): ResourceQualifierMapView_split_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,string>>;
        size: number;
    }

    interface ResourceQualifierMapView_split_OUT {
        first: Windows.Foundation.Collections.IMapView<string,string>;
        second: Windows.Foundation.Collections.IMapView<string,string>;
    }

    export class ResourceQualifierObservableMap implements Windows.Foundation.Collections.IObservableMap<string,string>, Windows.Foundation.Collections.IMap<string,string>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,string>> {
        lookup(key: string): string;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,string>;
        insert(key: string, value: string): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,string>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,string>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,string>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,string>) => void;

    }

    export class ResourceQualifierVectorView implements Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceQualifier>, Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier> {
        getAt(index: number): Windows.ApplicationModel.Resources.Core.ResourceQualifier;
        indexOf(value: Windows.ApplicationModel.Resources.Core.ResourceQualifier): ResourceQualifierVectorView_indexOf_OUT;
        getMany(startIndex: number): ResourceQualifierVectorView_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.ApplicationModel.Resources.Core.ResourceQualifier>;
        size: number;
    }

    interface ResourceQualifierVectorView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ResourceQualifierVectorView_getMany_OUT {
        __returnValue: number;
        items: Windows.ApplicationModel.Resources.Core.ResourceQualifier[];
    }

}
declare module Windows.ApplicationModel.Resources {

    export interface IResourceLoader {
        getString(resource: string): string;
    }

    export class ResourceLoader implements Windows.ApplicationModel.Resources.IResourceLoader {
        constructor(name: string);
        constructor();
        getString(resource: string): string;
        static getStringForReference(uri: Windows.Foundation.Uri): string;
    }

}
declare module Windows.ApplicationModel.Resources.Management {

    export interface IIndexedResourceCandidate {
        getQualifierValue(qualifierName: string): string;
        metadata: Windows.Foundation.Collections.IMapView<string,string>;
        qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Management.IndexedResourceQualifier>;
        type: Windows.ApplicationModel.Resources.Management.IndexedResourceType;
        uri: Windows.Foundation.Uri;
        valueAsString: string;
    }

    export interface IIndexedResourceQualifier {
        qualifierName: string;
        qualifierValue: string;
    }

    export class IndexedResourceCandidate implements Windows.ApplicationModel.Resources.Management.IIndexedResourceCandidate {
        getQualifierValue(qualifierName: string): string;
        metadata: Windows.Foundation.Collections.IMapView<string,string>;
        qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Management.IndexedResourceQualifier>;
        type: Windows.ApplicationModel.Resources.Management.IndexedResourceType;
        uri: Windows.Foundation.Uri;
        valueAsString: string;
    }

    export class IndexedResourceQualifier implements Windows.ApplicationModel.Resources.Management.IIndexedResourceQualifier {
        qualifierName: string;
        qualifierValue: string;
    }

    enum IndexedResourceType {
        string,
        path
    }

    export interface IResourceIndexer {
        indexFilePath(filePath: Windows.Foundation.Uri): Windows.ApplicationModel.Resources.Management.IndexedResourceCandidate;
        indexFileContentsAsync(file: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Management.IndexedResourceCandidate>>;
    }

    export class ResourceIndexer implements Windows.ApplicationModel.Resources.Management.IResourceIndexer {
        constructor(projectRoot: Windows.Foundation.Uri);
        indexFilePath(filePath: Windows.Foundation.Uri): Windows.ApplicationModel.Resources.Management.IndexedResourceCandidate;
        indexFileContentsAsync(file: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Management.IndexedResourceCandidate>>;
    }

}
declare module Windows.ApplicationModel.Search {

    export interface ILocalContentSuggestionSettings {
        aqsFilter: string;
        enabled: boolean;
        locations: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFolder>;
        propertiesToMatch: Windows.Foundation.Collections.IVector<string>;
    }

    export interface ISearchPane {
        setLocalContentSuggestionSettings(settings: Windows.ApplicationModel.Search.LocalContentSuggestionSettings): void;
        show(): void;
        show(query: string): void;
        trySetQueryText(query: string): boolean;
        language: string;
        placeholderText: string;
        queryText: string;
        searchHistoryContext: string;
        searchHistoryEnabled: boolean;
        showOnKeyboardInput: boolean;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): void;
        removeEventListener(eventName: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): void;
        onquerychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>) => void;
        addEventListener(eventName: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): void;
        removeEventListener(eventName: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): void;
        onquerysubmitted: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>) => void;
        addEventListener(eventName: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): void;
        removeEventListener(eventName: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): void;
        onresultsuggestionchosen: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>) => void;
        addEventListener(eventName: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): void;
        removeEventListener(eventName: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): void;
        onsuggestionsrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): void;
        onvisibilitychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>) => void;

    }

    export interface ISearchPaneQueryChangedEventArgs {
        language: string;
        linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
        queryText: string;
    }

    export interface ISearchPaneQueryLinguisticDetails {
        queryTextAlternatives: Windows.Foundation.Collections.IVectorView<string>;
        queryTextCompositionLength: number;
        queryTextCompositionStart: number;
    }

    export interface ISearchPaneQuerySubmittedEventArgs {
        language: string;
        queryText: string;
    }

    export interface ISearchPaneResultSuggestionChosenEventArgs {
        tag: string;
    }

    export interface ISearchPaneSuggestionsRequest {
        getDeferral(): Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral;
        isCanceled: boolean;
        searchSuggestionCollection: Windows.ApplicationModel.Search.SearchSuggestionCollection;
    }

    export interface ISearchPaneSuggestionsRequestDeferral {
        complete(): void;
    }

    export interface ISearchPaneSuggestionsRequestedEventArgs extends Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs {
        request: Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest;
    }

    export interface ISearchPaneVisibilityChangedEventArgs {
        visible: boolean;
    }

    export interface ISearchSuggestionCollection {
        appendQuerySuggestion(text: string): void;
        appendQuerySuggestions(suggestions: Windows.Foundation.Collections.IIterable<string>): void;
        appendResultSuggestion(text: string, detailText: string, tag: string, image: Windows.Storage.Streams.IRandomAccessStreamReference, imageAlternateText: string): void;
        appendSearchSeparator(label: string): void;
        size: number;
    }

    export class LocalContentSuggestionSettings implements Windows.ApplicationModel.Search.ILocalContentSuggestionSettings {
        constructor();
        aqsFilter: string;
        enabled: boolean;
        locations: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFolder>;
        propertiesToMatch: Windows.Foundation.Collections.IVector<string>;
    }

    export class SearchPane implements Windows.ApplicationModel.Search.ISearchPane {
        setLocalContentSuggestionSettings(settings: Windows.ApplicationModel.Search.LocalContentSuggestionSettings): void;
        show(): void;
        show(query: string): void;
        trySetQueryText(query: string): boolean;
        static getForCurrentView(): Windows.ApplicationModel.Search.SearchPane;
        language: string;
        placeholderText: string;
        queryText: string;
        searchHistoryContext: string;
        searchHistoryEnabled: boolean;
        showOnKeyboardInput: boolean;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): void;
        removeEventListener(eventName: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): void;
        onquerychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>) => void;
        addEventListener(eventName: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): void;
        removeEventListener(eventName: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): void;
        onquerysubmitted: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>) => void;
        addEventListener(eventName: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): void;
        removeEventListener(eventName: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): void;
        onresultsuggestionchosen: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>) => void;
        addEventListener(eventName: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): void;
        removeEventListener(eventName: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): void;
        onsuggestionsrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): void;
        onvisibilitychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>) => void;

    }

    export class SearchPaneQueryChangedEventArgs implements Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs {
        language: string;
        linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
        queryText: string;
    }

    export class SearchPaneQueryLinguisticDetails implements Windows.ApplicationModel.Search.ISearchPaneQueryLinguisticDetails {
        queryTextAlternatives: Windows.Foundation.Collections.IVectorView<string>;
        queryTextCompositionLength: number;
        queryTextCompositionStart: number;
    }

    export class SearchPaneQuerySubmittedEventArgs implements Windows.ApplicationModel.Search.ISearchPaneQuerySubmittedEventArgs {
        language: string;
        queryText: string;
    }

    export class SearchPaneResultSuggestionChosenEventArgs implements Windows.ApplicationModel.Search.ISearchPaneResultSuggestionChosenEventArgs {
        tag: string;
    }

    export class SearchPaneSuggestionsRequest implements Windows.ApplicationModel.Search.ISearchPaneSuggestionsRequest {
        getDeferral(): Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral;
        isCanceled: boolean;
        searchSuggestionCollection: Windows.ApplicationModel.Search.SearchSuggestionCollection;
    }

    export class SearchPaneSuggestionsRequestDeferral implements Windows.ApplicationModel.Search.ISearchPaneSuggestionsRequestDeferral {
        complete(): void;
    }

    export class SearchPaneSuggestionsRequestedEventArgs implements Windows.ApplicationModel.Search.ISearchPaneSuggestionsRequestedEventArgs, Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs {
        request: Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest;
        language: string;
        linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
        queryText: string;
    }

    export class SearchPaneVisibilityChangedEventArgs implements Windows.ApplicationModel.Search.ISearchPaneVisibilityChangedEventArgs {
        visible: boolean;
    }

    export class SearchSuggestionCollection implements Windows.ApplicationModel.Search.ISearchSuggestionCollection {
        appendQuerySuggestion(text: string): void;
        appendQuerySuggestions(suggestions: Windows.Foundation.Collections.IIterable<string>): void;
        appendResultSuggestion(text: string, detailText: string, tag: string, image: Windows.Storage.Streams.IRandomAccessStreamReference, imageAlternateText: string): void;
        appendSearchSeparator(label: string): void;
        size: number;
    }

}
declare module Windows.ApplicationModel.Store {

    export class CurrentApp {
        static requestAppPurchaseAsync(includeReceipt: boolean): Windows.Foundation.IAsyncOperation<string>;
        static requestProductPurchaseAsync(productId: string, includeReceipt: boolean): Windows.Foundation.IAsyncOperation<string>;
        static loadListingInformationAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
        static getAppReceiptAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getProductReceiptAsync(productId: string): Windows.Foundation.IAsyncOperation<string>;
        static appId: string;
        static licenseInformation: Windows.ApplicationModel.Store.LicenseInformation;
        static linkUri: Windows.Foundation.Uri;
    }

    export class CurrentAppSimulator {
        static requestAppPurchaseAsync(includeReceipt: boolean): Windows.Foundation.IAsyncOperation<string>;
        static requestProductPurchaseAsync(productId: string, includeReceipt: boolean): Windows.Foundation.IAsyncOperation<string>;
        static loadListingInformationAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
        static getAppReceiptAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getProductReceiptAsync(productId: string): Windows.Foundation.IAsyncOperation<string>;
        static reloadSimulatorAsync(simulatorSettingsFile: Windows.Storage.StorageFile): Windows.Foundation.IAsyncAction;
        static appId: string;
        static licenseInformation: Windows.ApplicationModel.Store.LicenseInformation;
        static linkUri: Windows.Foundation.Uri;
    }

    export interface ILicenseInformation {
        expirationDate: Date;
        isActive: boolean;
        isTrial: boolean;
        productLicenses: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Store.ProductLicense>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler): void;
        removeEventListener(eventName: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler): void;
        onlicensechanged: (ev: Windows.ApplicationModel.Store.LicenseChangedEventHandler) => void;

    }

    export interface IListingInformation {
        ageRating: number;
        currentMarket: string;
        description: string;
        formattedPrice: string;
        name: string;
        productListings: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Store.ProductListing>;
    }

    export interface IProductLicense {
        expirationDate: Date;
        isActive: boolean;
        productId: string;
    }

    export interface IProductListing {
        formattedPrice: string;
        name: string;
        productId: string;
    }

    export interface LicenseChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class LicenseInformation implements Windows.ApplicationModel.Store.ILicenseInformation {
        expirationDate: Date;
        isActive: boolean;
        isTrial: boolean;
        productLicenses: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Store.ProductLicense>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler): void;
        removeEventListener(eventName: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler): void;
        onlicensechanged: (ev: Windows.ApplicationModel.Store.LicenseChangedEventHandler) => void;

    }

    export class ListingInformation implements Windows.ApplicationModel.Store.IListingInformation {
        ageRating: number;
        currentMarket: string;
        description: string;
        formattedPrice: string;
        name: string;
        productListings: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Store.ProductListing>;
    }

    export class ProductLicense implements Windows.ApplicationModel.Store.IProductLicense {
        expirationDate: Date;
        isActive: boolean;
        productId: string;
    }

    export class ProductListing implements Windows.ApplicationModel.Store.IProductListing {
        formattedPrice: string;
        name: string;
        productId: string;
    }

}
declare module Windows.Data.Html {

    export class HtmlUtilities {
        static convertToText(html: string): string;
    }

}
declare module Windows.Data.Json {

    export interface IJsonArray extends Windows.Data.Json.IJsonValue {
        getObjectAt(index: number): Windows.Data.Json.JsonObject;
        getArrayAt(index: number): Windows.Data.Json.JsonArray;
        getStringAt(index: number): string;
        getNumberAt(index: number): number;
        getBooleanAt(index: number): boolean;
    }

    export interface IJsonObject extends Windows.Data.Json.IJsonValue {
        getNamedValue(name: string): Windows.Data.Json.JsonValue;
        setNamedValue(name: string, value: Windows.Data.Json.IJsonValue): void;
        getNamedObject(name: string): Windows.Data.Json.JsonObject;
        getNamedArray(name: string): Windows.Data.Json.JsonArray;
        getNamedString(name: string): string;
        getNamedNumber(name: string): number;
        getNamedBoolean(name: string): boolean;
    }

    export interface IJsonValue {
        stringify(): string;
        getString(): string;
        getNumber(): number;
        getBoolean(): boolean;
        getArray(): Windows.Data.Json.JsonArray;
        getObject(): Windows.Data.Json.JsonObject;
        valueType: Windows.Data.Json.JsonValueType;
    }

    export class JsonArray implements Windows.Data.Json.IJsonArray, Windows.Data.Json.IJsonValue, Windows.Foundation.Collections.IVector<Windows.Data.Json.IJsonValue>, Windows.Foundation.Collections.IIterable<Windows.Data.Json.IJsonValue> {
        constructor();
        getObjectAt(index: number): Windows.Data.Json.JsonObject;
        getArrayAt(index: number): Windows.Data.Json.JsonArray;
        getStringAt(index: number): string;
        getNumberAt(index: number): number;
        getBooleanAt(index: number): boolean;
        stringify(): string;
        getString(): string;
        getNumber(): number;
        getBoolean(): boolean;
        getArray(): Windows.Data.Json.JsonArray;
        getObject(): Windows.Data.Json.JsonObject;
        getAt(index: number): Windows.Data.Json.IJsonValue;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.Data.Json.IJsonValue>;
        indexOf(value: Windows.Data.Json.IJsonValue): JsonArray_indexOf_OUT;
        setAt(index: number, value: Windows.Data.Json.IJsonValue): void;
        insertAt(index: number, value: Windows.Data.Json.IJsonValue): void;
        removeAt(index: number): void;
        append(value: Windows.Data.Json.IJsonValue): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): JsonArray_getMany_OUT;
        replaceAll(items: Windows.Data.Json.IJsonValue[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Data.Json.IJsonValue>;
        static parse(input: string): Windows.Data.Json.JsonArray;
        static tryParse(input: string): JsonArray_tryParse_OUT;
        valueType: Windows.Data.Json.JsonValueType;
        size: number;
    }

    interface JsonArray_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface JsonArray_getMany_OUT {
        __returnValue: number;
        items: Windows.Data.Json.IJsonValue[];
    }

    interface JsonArray_tryParse_OUT {
        __returnValue: boolean;
        result: Windows.Data.Json.JsonArray;
    }

    export class JsonError {
        static getStatus(hresult: number): Windows.Data.Json.JsonErrorStatus;
    }

    enum JsonErrorStatus {
        unknown,
        invalidJsonString,
        invalidJsonNumber,
        jsonValueNotFound,
        implementationLimit
    }

    export class JsonObject implements Windows.Data.Json.IJsonObject, Windows.Data.Json.IJsonValue, Windows.Foundation.Collections.IMap<string,Windows.Data.Json.IJsonValue>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Data.Json.IJsonValue>> {
        constructor();
        getNamedValue(name: string): Windows.Data.Json.JsonValue;
        setNamedValue(name: string, value: Windows.Data.Json.IJsonValue): void;
        getNamedObject(name: string): Windows.Data.Json.JsonObject;
        getNamedArray(name: string): Windows.Data.Json.JsonArray;
        getNamedString(name: string): string;
        getNamedNumber(name: string): number;
        getNamedBoolean(name: string): boolean;
        stringify(): string;
        getString(): string;
        getNumber(): number;
        getBoolean(): boolean;
        getArray(): Windows.Data.Json.JsonArray;
        getObject(): Windows.Data.Json.JsonObject;
        lookup(key: string): Windows.Data.Json.IJsonValue;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,Windows.Data.Json.IJsonValue>;
        insert(key: string, value: Windows.Data.Json.IJsonValue): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Data.Json.IJsonValue>>;
        static parse(input: string): Windows.Data.Json.JsonObject;
        static tryParse(input: string): JsonObject_tryParse_OUT;
        valueType: Windows.Data.Json.JsonValueType;
        size: number;
    }

    interface JsonObject_tryParse_OUT {
        __returnValue: boolean;
        result: Windows.Data.Json.JsonObject;
    }

    export class JsonValue implements Windows.Data.Json.IJsonValue {
        stringify(): string;
        getString(): string;
        getNumber(): number;
        getBoolean(): boolean;
        getArray(): Windows.Data.Json.JsonArray;
        getObject(): Windows.Data.Json.JsonObject;
        static parse(input: string): Windows.Data.Json.JsonValue;
        static tryParse(input: string): JsonValue_tryParse_OUT;
        static createBooleanValue(input: boolean): Windows.Data.Json.JsonValue;
        static createNumberValue(input: number): Windows.Data.Json.JsonValue;
        static createStringValue(input: string): Windows.Data.Json.JsonValue;
        valueType: Windows.Data.Json.JsonValueType;
    }

    interface JsonValue_tryParse_OUT {
        __returnValue: boolean;
        result: Windows.Data.Json.JsonValue;
    }

    enum JsonValueType {
        null,
        boolean,
        number,
        string,
        array,
        object
    }

}
declare module Windows.Data.Xml.Dom {

    export class DtdEntity implements Windows.Data.Xml.Dom.IDtdEntity, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        notationName: any;
        publicId: any;
        systemId: any;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class DtdNotation implements Windows.Data.Xml.Dom.IDtdNotation, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        publicId: any;
        systemId: any;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export interface IDtdEntity extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        notationName: any;
        publicId: any;
        systemId: any;
    }

    export interface IDtdNotation extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        publicId: any;
        systemId: any;
    }

    export interface IXmlAttribute extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        name: string;
        specified: boolean;
        value: string;
    }

    export interface IXmlCDataSection extends Windows.Data.Xml.Dom.IXmlText, Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
    }

    export interface IXmlCharacterData extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        substringData(offset: number, count: number): string;
        appendData(data: string): void;
        insertData(offset: number, data: string): void;
        deleteData(offset: number, count: number): void;
        replaceData(offset: number, count: number, data: string): void;
        data: string;
        length: number;
    }

    export interface IXmlComment extends Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
    }

    export interface IXmlDocument extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        createElement(tagName: string): Windows.Data.Xml.Dom.XmlElement;
        createDocumentFragment(): Windows.Data.Xml.Dom.XmlDocumentFragment;
        createTextNode(data: string): Windows.Data.Xml.Dom.XmlText;
        createComment(data: string): Windows.Data.Xml.Dom.XmlComment;
        createProcessingInstruction(target: string, data: string): Windows.Data.Xml.Dom.XmlProcessingInstruction;
        createAttribute(name: string): Windows.Data.Xml.Dom.XmlAttribute;
        createEntityReference(name: string): Windows.Data.Xml.Dom.XmlEntityReference;
        getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
        createCDataSection(data: string): Windows.Data.Xml.Dom.XmlCDataSection;
        createAttributeNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlAttribute;
        createElementNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlElement;
        getElementById(elementId: string): Windows.Data.Xml.Dom.XmlElement;
        importNode(node: Windows.Data.Xml.Dom.IXmlNode, deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        doctype: Windows.Data.Xml.Dom.XmlDocumentType;
        documentElement: Windows.Data.Xml.Dom.XmlElement;
        documentUri: string;
        implementation: Windows.Data.Xml.Dom.XmlDomImplementation;
    }

    export interface IXmlDocumentFragment extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
    }

    export interface IXmlDocumentIO {
        loadXml(xml: string): void;
        loadXml(xml: string, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): void;
        saveToFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
    }

    export interface IXmlDocumentType extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        entities: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        name: string;
        notations: Windows.Data.Xml.Dom.XmlNamedNodeMap;
    }

    export interface IXmlDomImplementation {
        hasFeature(feature: string, version: any): boolean;
    }

    export interface IXmlElement extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        getAttribute(attributeName: string): string;
        setAttribute(attributeName: string, attributeValue: string): void;
        removeAttribute(attributeName: string): void;
        getAttributeNode(attributeName: string): Windows.Data.Xml.Dom.XmlAttribute;
        setAttributeNode(newAttribute: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        removeAttributeNode(attributeNode: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
        setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void;
        getAttributeNS(namespaceUri: any, localName: string): string;
        removeAttributeNS(namespaceUri: any, localName: string): void;
        setAttributeNodeNS(newAttribute: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        getAttributeNodeNS(namespaceUri: any, localName: string): Windows.Data.Xml.Dom.XmlAttribute;
        tagName: string;
    }

    export interface IXmlEntityReference extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
    }

    export interface IXmlLoadSettings {
        elementContentWhiteSpace: boolean;
        maxElementDepth: number;
        prohibitDtd: boolean;
        resolveExternals: boolean;
        validateOnParse: boolean;
    }

    export interface IXmlNamedNodeMap extends Windows.Foundation.Collections.IVectorView<Windows.Data.Xml.Dom.IXmlNode>, Windows.Foundation.Collections.IIterable<Windows.Data.Xml.Dom.IXmlNode> {
        item(index: number): Windows.Data.Xml.Dom.IXmlNode;
        getNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
        setNamedItem(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
        getNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
        removeNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
        setNamedItemNS(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        length: number;
    }

    export interface IXmlNode extends Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
    }

    export interface IXmlNodeList extends Windows.Foundation.Collections.IVectorView<Windows.Data.Xml.Dom.IXmlNode>, Windows.Foundation.Collections.IIterable<Windows.Data.Xml.Dom.IXmlNode> {
        item(index: number): Windows.Data.Xml.Dom.IXmlNode;
        length: number;
    }

    export interface IXmlNodeSelector {
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
    }

    export interface IXmlNodeSerializer {
        getXml(): string;
        innerText: string;
    }

    export interface IXmlProcessingInstruction extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        data: string;
        target: string;
    }

    export interface IXmlText extends Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        splitText(offset: number): Windows.Data.Xml.Dom.IXmlText;
    }

    enum NodeType {
        invalid,
        elementNode,
        attributeNode,
        textNode,
        dataSectionNode,
        entityReferenceNode,
        entityNode,
        processingInstructionNode,
        commentNode,
        documentNode,
        documentTypeNode,
        documentFragmentNode,
        notationNode
    }

    export class XmlAttribute implements Windows.Data.Xml.Dom.IXmlAttribute, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        name: string;
        specified: boolean;
        value: string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlCDataSection implements Windows.Data.Xml.Dom.IXmlCDataSection, Windows.Data.Xml.Dom.IXmlText, Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        splitText(offset: number): Windows.Data.Xml.Dom.IXmlText;
        substringData(offset: number, count: number): string;
        appendData(data: string): void;
        insertData(offset: number, data: string): void;
        deleteData(offset: number, count: number): void;
        replaceData(offset: number, count: number, data: string): void;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        data: string;
        length: number;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlComment implements Windows.Data.Xml.Dom.IXmlComment, Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        substringData(offset: number, count: number): string;
        appendData(data: string): void;
        insertData(offset: number, data: string): void;
        deleteData(offset: number, count: number): void;
        replaceData(offset: number, count: number, data: string): void;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        data: string;
        length: number;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlDocument implements Windows.Data.Xml.Dom.IXmlDocument, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer, Windows.Data.Xml.Dom.IXmlDocumentIO {
        constructor();
        createElement(tagName: string): Windows.Data.Xml.Dom.XmlElement;
        createDocumentFragment(): Windows.Data.Xml.Dom.XmlDocumentFragment;
        createTextNode(data: string): Windows.Data.Xml.Dom.XmlText;
        createComment(data: string): Windows.Data.Xml.Dom.XmlComment;
        createProcessingInstruction(target: string, data: string): Windows.Data.Xml.Dom.XmlProcessingInstruction;
        createAttribute(name: string): Windows.Data.Xml.Dom.XmlAttribute;
        createEntityReference(name: string): Windows.Data.Xml.Dom.XmlEntityReference;
        getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
        createCDataSection(data: string): Windows.Data.Xml.Dom.XmlCDataSection;
        createAttributeNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlAttribute;
        createElementNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlElement;
        getElementById(elementId: string): Windows.Data.Xml.Dom.XmlElement;
        importNode(node: Windows.Data.Xml.Dom.IXmlNode, deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        loadXml(xml: string): void;
        loadXml(xml: string, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): void;
        saveToFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        static loadFromUriAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
        static loadFromUriAsync(uri: Windows.Foundation.Uri, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): Windows.Foundation.IAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
        static loadFromFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
        static loadFromFileAsync(file: Windows.Storage.IStorageFile, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): Windows.Foundation.IAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
        doctype: Windows.Data.Xml.Dom.XmlDocumentType;
        documentElement: Windows.Data.Xml.Dom.XmlElement;
        documentUri: string;
        implementation: Windows.Data.Xml.Dom.XmlDomImplementation;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlDocumentFragment implements Windows.Data.Xml.Dom.IXmlDocumentFragment, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlDocumentType implements Windows.Data.Xml.Dom.IXmlDocumentType, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        entities: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        name: string;
        notations: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlDomImplementation implements Windows.Data.Xml.Dom.IXmlDomImplementation {
        hasFeature(feature: string, version: any): boolean;
    }

    export class XmlElement implements Windows.Data.Xml.Dom.IXmlElement, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        getAttribute(attributeName: string): string;
        setAttribute(attributeName: string, attributeValue: string): void;
        removeAttribute(attributeName: string): void;
        getAttributeNode(attributeName: string): Windows.Data.Xml.Dom.XmlAttribute;
        setAttributeNode(newAttribute: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        removeAttributeNode(attributeNode: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
        setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void;
        getAttributeNS(namespaceUri: any, localName: string): string;
        removeAttributeNS(namespaceUri: any, localName: string): void;
        setAttributeNodeNS(newAttribute: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        getAttributeNodeNS(namespaceUri: any, localName: string): Windows.Data.Xml.Dom.XmlAttribute;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        tagName: string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlEntityReference implements Windows.Data.Xml.Dom.IXmlEntityReference, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlLoadSettings implements Windows.Data.Xml.Dom.IXmlLoadSettings {
        constructor();
        elementContentWhiteSpace: boolean;
        maxElementDepth: number;
        prohibitDtd: boolean;
        resolveExternals: boolean;
        validateOnParse: boolean;
    }

    export class XmlNamedNodeMap implements Windows.Data.Xml.Dom.IXmlNamedNodeMap, Windows.Foundation.Collections.IVectorView<Windows.Data.Xml.Dom.IXmlNode>, Windows.Foundation.Collections.IIterable<Windows.Data.Xml.Dom.IXmlNode> {
        item(index: number): Windows.Data.Xml.Dom.IXmlNode;
        getNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
        setNamedItem(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
        getNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
        removeNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
        setNamedItemNS(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        getAt(index: number): Windows.Data.Xml.Dom.IXmlNode;
        indexOf(value: Windows.Data.Xml.Dom.IXmlNode): XmlNamedNodeMap_indexOf_OUT;
        getMany(startIndex: number): XmlNamedNodeMap_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Data.Xml.Dom.IXmlNode>;
        length: number;
        size: number;
    }

    interface XmlNamedNodeMap_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface XmlNamedNodeMap_getMany_OUT {
        __returnValue: number;
        items: Windows.Data.Xml.Dom.IXmlNode[];
    }

    export class XmlNodeList implements Windows.Data.Xml.Dom.IXmlNodeList, Windows.Foundation.Collections.IVectorView<Windows.Data.Xml.Dom.IXmlNode>, Windows.Foundation.Collections.IIterable<Windows.Data.Xml.Dom.IXmlNode> {
        item(index: number): Windows.Data.Xml.Dom.IXmlNode;
        getAt(index: number): Windows.Data.Xml.Dom.IXmlNode;
        indexOf(value: Windows.Data.Xml.Dom.IXmlNode): XmlNodeList_indexOf_OUT;
        getMany(startIndex: number): XmlNodeList_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Data.Xml.Dom.IXmlNode>;
        length: number;
        size: number;
    }

    interface XmlNodeList_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface XmlNodeList_getMany_OUT {
        __returnValue: number;
        items: Windows.Data.Xml.Dom.IXmlNode[];
    }

    export class XmlProcessingInstruction implements Windows.Data.Xml.Dom.IXmlProcessingInstruction, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        data: string;
        target: string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlText implements Windows.Data.Xml.Dom.IXmlText, Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        splitText(offset: number): Windows.Data.Xml.Dom.IXmlText;
        substringData(offset: number, count: number): string;
        appendData(data: string): void;
        insertData(offset: number, data: string): void;
        deleteData(offset: number, count: number): void;
        replaceData(offset: number, count: number, data: string): void;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        data: string;
        length: number;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

}
declare module Windows.Data.Xml.Xsl {

    export interface IXsltProcessor {
        transformToString(inputNode: Windows.Data.Xml.Dom.IXmlNode): string;
    }

    export class XsltProcessor implements Windows.Data.Xml.Xsl.IXsltProcessor {
        constructor(document: Windows.Data.Xml.Dom.XmlDocument);
        transformToString(inputNode: Windows.Data.Xml.Dom.IXmlNode): string;
    }

}
declare module Windows.Devices.Enumeration {

    enum DeviceClass {
        all,
        audioCapture,
        audioRender,
        portableStorageDevice,
        videoCapture
    }

    export class DeviceInformation implements Windows.Devices.Enumeration.IDeviceInformation {
        update(updateInfo: Windows.Devices.Enumeration.DeviceInformationUpdate): void;
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
        getGlyphThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
        static createFromIdAsync(id: string): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
        static createFromIdAsync(id: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
        static findAllAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
        static findAllAsync(deviceClass: Windows.Devices.Enumeration.DeviceClass): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
        static findAllAsync(aqsFilter: string): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
        static findAllAsync(aqsFilter: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
        static createWatcher(): Windows.Devices.Enumeration.DeviceWatcher;
        static createWatcher(deviceClass: Windows.Devices.Enumeration.DeviceClass): Windows.Devices.Enumeration.DeviceWatcher;
        static createWatcher(aqsFilter: string): Windows.Devices.Enumeration.DeviceWatcher;
        static createWatcher(aqsFilter: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Devices.Enumeration.DeviceWatcher;
        enclosureLocation: Windows.Devices.Enumeration.EnclosureLocation;
        id: string;
        isDefault: boolean;
        isEnabled: boolean;
        name: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export class DeviceInformationCollection implements Windows.Foundation.Collections.IVectorView<Windows.Devices.Enumeration.DeviceInformation>, Windows.Foundation.Collections.IIterable<Windows.Devices.Enumeration.DeviceInformation> {
        getAt(index: number): Windows.Devices.Enumeration.DeviceInformation;
        indexOf(value: Windows.Devices.Enumeration.DeviceInformation): DeviceInformationCollection_indexOf_OUT;
        getMany(startIndex: number): DeviceInformationCollection_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Devices.Enumeration.DeviceInformation>;
        size: number;
    }

    interface DeviceInformationCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface DeviceInformationCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.Devices.Enumeration.DeviceInformation[];
    }

    export class DeviceInformationUpdate implements Windows.Devices.Enumeration.IDeviceInformationUpdate {
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export class DeviceThumbnail implements Windows.Storage.Streams.IRandomAccessStreamWithContentType, Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream, Windows.Storage.Streams.IContentTypeProvider {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
        contentType: string;
    }

    export class DeviceWatcher implements Windows.Devices.Enumeration.IDeviceWatcher {
        start(): void;
        stop(): void;
        status: Windows.Devices.Enumeration.DeviceWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>) => void;

    }

    enum DeviceWatcherStatus {
        created,
        started,
        enumerationCompleted,
        stopping,
        stopped,
        aborted
    }

    export class EnclosureLocation implements Windows.Devices.Enumeration.IEnclosureLocation {
        inDock: boolean;
        inLid: boolean;
        panel: Windows.Devices.Enumeration.Panel;
    }

    export interface IDeviceInformation {
        update(updateInfo: Windows.Devices.Enumeration.DeviceInformationUpdate): void;
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
        getGlyphThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
        enclosureLocation: Windows.Devices.Enumeration.EnclosureLocation;
        id: string;
        isDefault: boolean;
        isEnabled: boolean;
        name: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export interface IDeviceInformationUpdate {
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export interface IDeviceWatcher {
        start(): void;
        stop(): void;
        status: Windows.Devices.Enumeration.DeviceWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>) => void;

    }

    export interface IEnclosureLocation {
        inDock: boolean;
        inLid: boolean;
        panel: Windows.Devices.Enumeration.Panel;
    }

    enum Panel {
        unknown,
        front,
        back,
        top,
        bottom,
        left,
        right
    }

}
declare module Windows.Devices.Enumeration.Pnp {

    export interface IPnpObject {
        update(updateInfo: Windows.Devices.Enumeration.Pnp.PnpObjectUpdate): void;
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
    }

    export interface IPnpObjectUpdate {
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
    }

    export interface IPnpObjectWatcher {
        start(): void;
        stop(): void;
        status: Windows.Devices.Enumeration.DeviceWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>) => void;

    }

    export class PnpObject implements Windows.Devices.Enumeration.Pnp.IPnpObject {
        update(updateInfo: Windows.Devices.Enumeration.Pnp.PnpObjectUpdate): void;
        static createFromIdAsync(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, id: string, requestedProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObject>;
        static findAllAsync(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObjectCollection>;
        static findAllAsync(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>, aqsFilter: string): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObjectCollection>;
        static createWatcher(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Devices.Enumeration.Pnp.PnpObjectWatcher;
        static createWatcher(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>, aqsFilter: string): Windows.Devices.Enumeration.Pnp.PnpObjectWatcher;
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
    }

    export class PnpObjectCollection implements Windows.Foundation.Collections.IVectorView<Windows.Devices.Enumeration.Pnp.PnpObject>, Windows.Foundation.Collections.IIterable<Windows.Devices.Enumeration.Pnp.PnpObject> {
        getAt(index: number): Windows.Devices.Enumeration.Pnp.PnpObject;
        indexOf(value: Windows.Devices.Enumeration.Pnp.PnpObject): PnpObjectCollection_indexOf_OUT;
        getMany(startIndex: number): PnpObjectCollection_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Devices.Enumeration.Pnp.PnpObject>;
        size: number;
    }

    interface PnpObjectCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface PnpObjectCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.Devices.Enumeration.Pnp.PnpObject[];
    }

    enum PnpObjectType {
        unknown,
        deviceInterface,
        deviceContainer,
        device,
        deviceInterfaceClass
    }

    export class PnpObjectUpdate implements Windows.Devices.Enumeration.Pnp.IPnpObjectUpdate {
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
    }

    export class PnpObjectWatcher implements Windows.Devices.Enumeration.Pnp.IPnpObjectWatcher {
        start(): void;
        stop(): void;
        status: Windows.Devices.Enumeration.DeviceWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>) => void;

    }

}
declare module Windows.Devices.Geolocation {

    export class CivicAddress implements Windows.Devices.Geolocation.ICivicAddress {
        city: string;
        country: string;
        postalCode: string;
        state: string;
        timestamp: Date;
    }

    export class Geocoordinate implements Windows.Devices.Geolocation.IGeocoordinate {
        accuracy: number;
        altitude: Windows.Foundation.IReference<number>;
        altitudeAccuracy: Windows.Foundation.IReference<number>;
        heading: Windows.Foundation.IReference<number>;
        latitude: number;
        longitude: number;
        speed: Windows.Foundation.IReference<number>;
        timestamp: Date;
    }

    export class Geolocator implements Windows.Devices.Geolocation.IGeolocator {
        constructor();
        getGeopositionAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
        getGeopositionAsync(maximumAge: Windows.Foundation.TimeSpan, timeout: Windows.Foundation.TimeSpan): Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
        desiredAccuracy: Windows.Devices.Geolocation.PositionAccuracy;
        locationStatus: Windows.Devices.Geolocation.PositionStatus;
        movementThreshold: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): void;
        removeEventListener(eventName: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): void;
        onpositionchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>) => void;
        addEventListener(eventName: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): void;
        removeEventListener(eventName: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): void;
        onstatuschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>) => void;

    }

    export class Geoposition implements Windows.Devices.Geolocation.IGeoposition {
        civicAddress: Windows.Devices.Geolocation.CivicAddress;
        coordinate: Windows.Devices.Geolocation.Geocoordinate;
    }

    export interface ICivicAddress {
        city: string;
        country: string;
        postalCode: string;
        state: string;
        timestamp: Date;
    }

    export interface IGeocoordinate {
        accuracy: number;
        altitude: Windows.Foundation.IReference<number>;
        altitudeAccuracy: Windows.Foundation.IReference<number>;
        heading: Windows.Foundation.IReference<number>;
        latitude: number;
        longitude: number;
        speed: Windows.Foundation.IReference<number>;
        timestamp: Date;
    }

    export interface IGeolocator {
        getGeopositionAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
        getGeopositionAsync(maximumAge: Windows.Foundation.TimeSpan, timeout: Windows.Foundation.TimeSpan): Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
        desiredAccuracy: Windows.Devices.Geolocation.PositionAccuracy;
        locationStatus: Windows.Devices.Geolocation.PositionStatus;
        movementThreshold: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): void;
        removeEventListener(eventName: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): void;
        onpositionchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>) => void;
        addEventListener(eventName: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): void;
        removeEventListener(eventName: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): void;
        onstatuschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>) => void;

    }

    export interface IGeoposition {
        civicAddress: Windows.Devices.Geolocation.CivicAddress;
        coordinate: Windows.Devices.Geolocation.Geocoordinate;
    }

    export interface IPositionChangedEventArgs {
        position: Windows.Devices.Geolocation.Geoposition;
    }

    export interface IStatusChangedEventArgs {
        status: Windows.Devices.Geolocation.PositionStatus;
    }

    enum PositionAccuracy {
        default,
        high
    }

    export class PositionChangedEventArgs implements Windows.Devices.Geolocation.IPositionChangedEventArgs {
        position: Windows.Devices.Geolocation.Geoposition;
    }

    enum PositionStatus {
        ready,
        initializing,
        noData,
        disabled,
        notInitialized,
        notAvailable
    }

    export class StatusChangedEventArgs implements Windows.Devices.Geolocation.IStatusChangedEventArgs {
        status: Windows.Devices.Geolocation.PositionStatus;
    }

}
declare module Windows.Devices.Input {

    export interface IKeyboardCapabilities {
        keyboardPresent: number;
    }

    export interface IMouseCapabilities {
        horizontalWheelPresent: number;
        mousePresent: number;
        numberOfButtons: number;
        swapButtons: number;
        verticalWheelPresent: number;
    }

    export interface IMouseDevice {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): void;
        removeEventListener(eventName: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): void;
        onmousemoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>) => void;

    }

    export interface IMouseEventArgs {
        mouseDelta: Windows.Devices.Input.MouseDelta;
    }

    export interface IPointerDevice {
        isIntegrated: boolean;
        maxContacts: number;
        physicalDeviceRect: Windows.Foundation.Rect;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        screenRect: Windows.Foundation.Rect;
        supportedUsages: Windows.Foundation.Collections.IVectorView<Windows.Devices.Input.PointerDeviceUsage>;
    }

    export interface ITouchCapabilities {
        contacts: number;
        touchPresent: number;
    }

    export class KeyboardCapabilities implements Windows.Devices.Input.IKeyboardCapabilities {
        constructor();
        keyboardPresent: number;
    }

    export class MouseCapabilities implements Windows.Devices.Input.IMouseCapabilities {
        constructor();
        horizontalWheelPresent: number;
        mousePresent: number;
        numberOfButtons: number;
        swapButtons: number;
        verticalWheelPresent: number;
    }

    export class MouseDelta {
        x: number;
        y: number;
    }

    export class MouseDevice implements Windows.Devices.Input.IMouseDevice {
        static getForCurrentView(): Windows.Devices.Input.MouseDevice;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): void;
        removeEventListener(eventName: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): void;
        onmousemoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>) => void;

    }

    export class MouseEventArgs implements Windows.Devices.Input.IMouseEventArgs {
        mouseDelta: Windows.Devices.Input.MouseDelta;
    }

    export class PointerDevice implements Windows.Devices.Input.IPointerDevice {
        static getPointerDevice(pointerId: number): Windows.Devices.Input.PointerDevice;
        static getPointerDevices(): Windows.Foundation.Collections.IVectorView<Windows.Devices.Input.PointerDevice>;
        isIntegrated: boolean;
        maxContacts: number;
        physicalDeviceRect: Windows.Foundation.Rect;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        screenRect: Windows.Foundation.Rect;
        supportedUsages: Windows.Foundation.Collections.IVectorView<Windows.Devices.Input.PointerDeviceUsage>;
    }

    enum PointerDeviceType {
        touch,
        pen,
        mouse
    }

    export class PointerDeviceUsage {
        usagePage: number;
        usage: number;
        minLogical: number;
        maxLogical: number;
        minPhysical: number;
        maxPhysical: number;
        unit: number;
        physicalMultiplier: number;
    }

    export class TouchCapabilities implements Windows.Devices.Input.ITouchCapabilities {
        constructor();
        contacts: number;
        touchPresent: number;
    }

}
declare module Windows.Devices.Portable {

    export class ServiceDevice {
        static getDeviceSelector(serviceType: Windows.Devices.Portable.ServiceDeviceType): string;
        static getDeviceSelectorFromServiceId(serviceId: string): string;
    }

    enum ServiceDeviceType {
        calendarService,
        contactsService,
        deviceStatusService,
        notesService,
        ringtonesService,
        smsService,
        tasksService
    }

    export class StorageDevice {
        static fromId(interfaceId: string): Windows.Storage.StorageFolder;
        static getDeviceSelector(): string;
    }

}
declare module Windows.Devices.Printers.Extensions {

    export interface IPrintNotificationEventDetails {
        eventData: string;
        printerName: string;
    }

    export interface IPrintTaskConfiguration {
        printerExtensionContext: any;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): void;
        removeEventListener(eventName: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): void;
        onsaverequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>) => void;

    }

    export interface IPrintTaskConfigurationSaveRequest {
        cancel(): void;
        save(printerExtensionContext: any): void;
        getDeferral(): Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral;
        deadline: Date;
    }

    export interface IPrintTaskConfigurationSaveRequestedDeferral {
        complete(): void;
    }

    export interface IPrintTaskConfigurationSaveRequestedEventArgs {
        request: Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest;
    }

    export class PrintExtensionContext {
        static fromDeviceId(deviceId: string): any;
    }

    export class PrintNotificationEventDetails implements Windows.Devices.Printers.Extensions.IPrintNotificationEventDetails {
        eventData: string;
        printerName: string;
    }

    export class PrintTaskConfiguration implements Windows.Devices.Printers.Extensions.IPrintTaskConfiguration {
        printerExtensionContext: any;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): void;
        removeEventListener(eventName: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): void;
        onsaverequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>) => void;

    }

    export class PrintTaskConfigurationSaveRequest implements Windows.Devices.Printers.Extensions.IPrintTaskConfigurationSaveRequest {
        cancel(): void;
        save(printerExtensionContext: any): void;
        getDeferral(): Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral;
        deadline: Date;
    }

    export class PrintTaskConfigurationSaveRequestedDeferral implements Windows.Devices.Printers.Extensions.IPrintTaskConfigurationSaveRequestedDeferral {
        complete(): void;
    }

    export class PrintTaskConfigurationSaveRequestedEventArgs implements Windows.Devices.Printers.Extensions.IPrintTaskConfigurationSaveRequestedEventArgs {
        request: Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest;
    }

}
declare module Windows.Devices.Sensors {

    export class Accelerometer implements Windows.Devices.Sensors.IAccelerometer {
        getCurrentReading(): Windows.Devices.Sensors.AccelerometerReading;
        static getDefault(): Windows.Devices.Sensors.Accelerometer;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>) => void;
        addEventListener(eventName: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): void;
        removeEventListener(eventName: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): void;
        onshaken: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>) => void;

    }

    export class AccelerometerReading implements Windows.Devices.Sensors.IAccelerometerReading {
        accelerationX: number;
        accelerationY: number;
        accelerationZ: number;
        timestamp: Date;
    }

    export class AccelerometerReadingChangedEventArgs implements Windows.Devices.Sensors.IAccelerometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.AccelerometerReading;
    }

    export class AccelerometerShakenEventArgs implements Windows.Devices.Sensors.IAccelerometerShakenEventArgs {
        timestamp: Date;
    }

    export class Compass implements Windows.Devices.Sensors.ICompass {
        getCurrentReading(): Windows.Devices.Sensors.CompassReading;
        static getDefault(): Windows.Devices.Sensors.Compass;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>) => void;

    }

    export class CompassReading implements Windows.Devices.Sensors.ICompassReading {
        headingMagneticNorth: number;
        headingTrueNorth: Windows.Foundation.IReference<number>;
        timestamp: Date;
    }

    export class CompassReadingChangedEventArgs implements Windows.Devices.Sensors.ICompassReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.CompassReading;
    }

    export class Gyrometer implements Windows.Devices.Sensors.IGyrometer {
        getCurrentReading(): Windows.Devices.Sensors.GyrometerReading;
        static getDefault(): Windows.Devices.Sensors.Gyrometer;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>) => void;

    }

    export class GyrometerReading implements Windows.Devices.Sensors.IGyrometerReading {
        angularVelocityX: number;
        angularVelocityY: number;
        angularVelocityZ: number;
        timestamp: Date;
    }

    export class GyrometerReadingChangedEventArgs implements Windows.Devices.Sensors.IGyrometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.GyrometerReading;
    }

    export interface IAccelerometer {
        getCurrentReading(): Windows.Devices.Sensors.AccelerometerReading;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>) => void;
        addEventListener(eventName: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): void;
        removeEventListener(eventName: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): void;
        onshaken: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>) => void;

    }

    export interface IAccelerometerReading {
        accelerationX: number;
        accelerationY: number;
        accelerationZ: number;
        timestamp: Date;
    }

    export interface IAccelerometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.AccelerometerReading;
    }

    export interface IAccelerometerShakenEventArgs {
        timestamp: Date;
    }

    export interface ICompass {
        getCurrentReading(): Windows.Devices.Sensors.CompassReading;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>) => void;

    }

    export interface ICompassReading {
        headingMagneticNorth: number;
        headingTrueNorth: Windows.Foundation.IReference<number>;
        timestamp: Date;
    }

    export interface ICompassReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.CompassReading;
    }

    export interface IGyrometer {
        getCurrentReading(): Windows.Devices.Sensors.GyrometerReading;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>) => void;

    }

    export interface IGyrometerReading {
        angularVelocityX: number;
        angularVelocityY: number;
        angularVelocityZ: number;
        timestamp: Date;
    }

    export interface IGyrometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.GyrometerReading;
    }

    export interface IInclinometer {
        getCurrentReading(): Windows.Devices.Sensors.InclinometerReading;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>) => void;

    }

    export interface IInclinometerReading {
        pitchDegrees: number;
        rollDegrees: number;
        timestamp: Date;
        yawDegrees: number;
    }

    export interface IInclinometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.InclinometerReading;
    }

    export interface ILightSensor {
        getCurrentReading(): Windows.Devices.Sensors.LightSensorReading;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>) => void;

    }

    export interface ILightSensorReading {
        illuminanceInLux: number;
        timestamp: Date;
    }

    export interface ILightSensorReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.LightSensorReading;
    }

    export class Inclinometer implements Windows.Devices.Sensors.IInclinometer {
        getCurrentReading(): Windows.Devices.Sensors.InclinometerReading;
        static getDefault(): Windows.Devices.Sensors.Inclinometer;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>) => void;

    }

    export class InclinometerReading implements Windows.Devices.Sensors.IInclinometerReading {
        pitchDegrees: number;
        rollDegrees: number;
        timestamp: Date;
        yawDegrees: number;
    }

    export class InclinometerReadingChangedEventArgs implements Windows.Devices.Sensors.IInclinometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.InclinometerReading;
    }

    export interface IOrientationSensor {
        getCurrentReading(): Windows.Devices.Sensors.OrientationSensorReading;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>) => void;

    }

    export interface IOrientationSensorReading {
        quaternion: Windows.Devices.Sensors.SensorQuaternion;
        rotationMatrix: Windows.Devices.Sensors.SensorRotationMatrix;
        timestamp: Date;
    }

    export interface IOrientationSensorReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.OrientationSensorReading;
    }

    export interface ISensorQuaternion {
        w: number;
        x: number;
        y: number;
        z: number;
    }

    export interface ISensorRotationMatrix {
        m11: number;
        m12: number;
        m13: number;
        m21: number;
        m22: number;
        m23: number;
        m31: number;
        m32: number;
        m33: number;
    }

    export interface ISimpleOrientationSensor {
        getCurrentOrientation(): Windows.Devices.Sensors.SimpleOrientation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): void;
        removeEventListener(eventName: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): void;
        onorientationchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>) => void;

    }

    export interface ISimpleOrientationSensorOrientationChangedEventArgs {
        orientation: Windows.Devices.Sensors.SimpleOrientation;
        timestamp: Date;
    }

    export class LightSensor implements Windows.Devices.Sensors.ILightSensor {
        getCurrentReading(): Windows.Devices.Sensors.LightSensorReading;
        static getDefault(): Windows.Devices.Sensors.LightSensor;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>) => void;

    }

    export class LightSensorReading implements Windows.Devices.Sensors.ILightSensorReading {
        illuminanceInLux: number;
        timestamp: Date;
    }

    export class LightSensorReadingChangedEventArgs implements Windows.Devices.Sensors.ILightSensorReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.LightSensorReading;
    }

    export class OrientationSensor implements Windows.Devices.Sensors.IOrientationSensor {
        getCurrentReading(): Windows.Devices.Sensors.OrientationSensorReading;
        static getDefault(): Windows.Devices.Sensors.OrientationSensor;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>) => void;

    }

    export class OrientationSensorReading implements Windows.Devices.Sensors.IOrientationSensorReading {
        quaternion: Windows.Devices.Sensors.SensorQuaternion;
        rotationMatrix: Windows.Devices.Sensors.SensorRotationMatrix;
        timestamp: Date;
    }

    export class OrientationSensorReadingChangedEventArgs implements Windows.Devices.Sensors.IOrientationSensorReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.OrientationSensorReading;
    }

    export class SensorQuaternion implements Windows.Devices.Sensors.ISensorQuaternion {
        w: number;
        x: number;
        y: number;
        z: number;
    }

    export class SensorRotationMatrix implements Windows.Devices.Sensors.ISensorRotationMatrix {
        m11: number;
        m12: number;
        m13: number;
        m21: number;
        m22: number;
        m23: number;
        m31: number;
        m32: number;
        m33: number;
    }

    enum SimpleOrientation {
        notRotated,
        rotated90DegreesCounterclockwise,
        rotated180DegreesCounterclockwise,
        rotated270DegreesCounterclockwise,
        faceup,
        facedown
    }

    export class SimpleOrientationSensor implements Windows.Devices.Sensors.ISimpleOrientationSensor {
        getCurrentOrientation(): Windows.Devices.Sensors.SimpleOrientation;
        static getDefault(): Windows.Devices.Sensors.SimpleOrientationSensor;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): void;
        removeEventListener(eventName: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): void;
        onorientationchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>) => void;

    }

    export class SimpleOrientationSensorOrientationChangedEventArgs implements Windows.Devices.Sensors.ISimpleOrientationSensorOrientationChangedEventArgs {
        orientation: Windows.Devices.Sensors.SimpleOrientation;
        timestamp: Date;
    }

}
declare module Windows.Devices.Sms {

    enum CellularClass {
        none,
        gsm,
        cdma
    }

    export class DeleteSmsMessageOperation implements Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncInfo {
        getResults(): void;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export class DeleteSmsMessagesOperation implements Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncInfo {
        getResults(): void;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export class GetSmsDeviceOperation implements Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.SmsDevice>, Windows.Foundation.IAsyncInfo {
        getResults(): Windows.Devices.Sms.SmsDevice;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Devices.Sms.SmsDevice>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class GetSmsMessageOperation implements Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.ISmsMessage>, Windows.Foundation.IAsyncInfo {
        getResults(): Windows.Devices.Sms.ISmsMessage;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Devices.Sms.ISmsMessage>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class GetSmsMessagesOperation implements Windows.Foundation.IAsyncOperationWithProgress<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>, Windows.Foundation.IAsyncInfo {
        getResults(): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationWithProgressCompletedHandler<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>;
        progress: Windows.Foundation.AsyncOperationProgressHandler<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export interface ISmsBinaryMessage extends Windows.Devices.Sms.ISmsMessage {
        getData(): any;
        setData(value: any): void;
        format: Windows.Devices.Sms.SmsDataFormat;
    }

    export interface ISmsDevice {
        sendMessageAsync(message: Windows.Devices.Sms.ISmsMessage): Windows.Devices.Sms.SendSmsMessageOperation;
        calculateLength(message: Windows.Devices.Sms.SmsTextMessage): Windows.Devices.Sms.SmsEncodedLength;
        accountPhoneNumber: string;
        cellularClass: Windows.Devices.Sms.CellularClass;
        deviceStatus: Windows.Devices.Sms.SmsDeviceStatus;
        messageStore: Windows.Devices.Sms.SmsDeviceMessageStore;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): void;
        removeEventListener(eventName: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): void;
        onsmsdevicestatuschanged: (ev: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler) => void;
        addEventListener(eventName: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler): void;
        removeEventListener(eventName: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler): void;
        onsmsmessagereceived: (ev: Windows.Devices.Sms.SmsMessageReceivedEventHandler) => void;

    }

    export interface ISmsDeviceMessageStore {
        deleteMessageAsync(messageId: number): Windows.Foundation.IAsyncAction;
        deleteMessagesAsync(messageFilter: Windows.Devices.Sms.SmsMessageFilter): Windows.Foundation.IAsyncAction;
        getMessageAsync(messageId: number): Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.ISmsMessage>;
        getMessagesAsync(messageFilter: Windows.Devices.Sms.SmsMessageFilter): Windows.Foundation.IAsyncOperationWithProgress<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>;
        maxMessages: number;
    }

    export interface ISmsMessage {
        id: number;
        messageClass: Windows.Devices.Sms.SmsMessageClass;
    }

    export interface ISmsMessageReceivedEventArgs {
        binaryMessage: Windows.Devices.Sms.SmsBinaryMessage;
        textMessage: Windows.Devices.Sms.SmsTextMessage;
    }

    export interface ISmsReceivedEventDetails {
        deviceId: string;
        messageIndex: number;
    }

    export interface ISmsTextMessage extends Windows.Devices.Sms.ISmsMessage {
        toBinaryMessages(format: Windows.Devices.Sms.SmsDataFormat): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsBinaryMessage>;
        body: string;
        encoding: Windows.Devices.Sms.SmsEncoding;
        from: string;
        partCount: number;
        partNumber: number;
        partReferenceId: number;
        timestamp: Date;
        to: string;
    }

    export class SendSmsMessageOperation implements Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncInfo {
        getResults(): void;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export class SmsBinaryMessage implements Windows.Devices.Sms.ISmsBinaryMessage, Windows.Devices.Sms.ISmsMessage {
        constructor();
        getData(): any;
        setData(value: any): void;
        format: Windows.Devices.Sms.SmsDataFormat;
        id: number;
        messageClass: Windows.Devices.Sms.SmsMessageClass;
    }

    enum SmsDataFormat {
        unknown,
        cdmaSubmit,
        gsmSubmit,
        cdmaDeliver,
        gsmDeliver
    }

    export class SmsDevice implements Windows.Devices.Sms.ISmsDevice {
        sendMessageAsync(message: Windows.Devices.Sms.ISmsMessage): Windows.Devices.Sms.SendSmsMessageOperation;
        calculateLength(message: Windows.Devices.Sms.SmsTextMessage): Windows.Devices.Sms.SmsEncodedLength;
        static getDeviceSelector(): string;
        static fromIdAsync(deviceInstanceId: string): Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.SmsDevice>;
        static getDefaultAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.SmsDevice>;
        accountPhoneNumber: string;
        cellularClass: Windows.Devices.Sms.CellularClass;
        deviceStatus: Windows.Devices.Sms.SmsDeviceStatus;
        messageStore: Windows.Devices.Sms.SmsDeviceMessageStore;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): void;
        removeEventListener(eventName: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): void;
        onsmsdevicestatuschanged: (ev: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler) => void;
        addEventListener(eventName: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler): void;
        removeEventListener(eventName: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler): void;
        onsmsmessagereceived: (ev: Windows.Devices.Sms.SmsMessageReceivedEventHandler) => void;

    }

    export class SmsDeviceMessageStore implements Windows.Devices.Sms.ISmsDeviceMessageStore {
        deleteMessageAsync(messageId: number): Windows.Foundation.IAsyncAction;
        deleteMessagesAsync(messageFilter: Windows.Devices.Sms.SmsMessageFilter): Windows.Foundation.IAsyncAction;
        getMessageAsync(messageId: number): Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.ISmsMessage>;
        getMessagesAsync(messageFilter: Windows.Devices.Sms.SmsMessageFilter): Windows.Foundation.IAsyncOperationWithProgress<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>;
        maxMessages: number;
    }

    enum SmsDeviceStatus {
        off,
        ready,
        simNotInserted,
        badSim,
        deviceFailure,
        subscriptionNotActivated,
        deviceLocked,
        deviceBlocked
    }

    export interface SmsDeviceStatusChangedEventHandler {
        target: Windows.Devices.Sms.SmsDevice;
        detail: any[];
        type: string;
    }

    export class SmsEncodedLength {
        segmentCount: number;
        characterCountLastSegment: number;
        charactersPerSegment: number;
        byteCountLastSegment: number;
        bytesPerSegment: number;
    }

    enum SmsEncoding {
        unknown,
        optimal,
        sevenBitAscii,
        unicode,
        gsmSevenBit
    }

    enum SmsMessageClass {
        none,
        class0,
        class1,
        class2,
        class3
    }

    enum SmsMessageFilter {
        all,
        unread,
        read,
        sent,
        draft
    }

    export class SmsMessageReceivedEventArgs implements Windows.Devices.Sms.ISmsMessageReceivedEventArgs {
        binaryMessage: Windows.Devices.Sms.SmsBinaryMessage;
        textMessage: Windows.Devices.Sms.SmsTextMessage;
    }

    export interface SmsMessageReceivedEventHandler {
        target: Windows.Devices.Sms.SmsDevice;
        detail: any[];
        type: string;
    }

    enum SmsMessageType {
        binary,
        text
    }

    export class SmsReceivedEventDetails implements Windows.Devices.Sms.ISmsReceivedEventDetails {
        deviceId: string;
        messageIndex: number;
    }

    export class SmsTextMessage implements Windows.Devices.Sms.ISmsTextMessage, Windows.Devices.Sms.ISmsMessage {
        constructor();
        toBinaryMessages(format: Windows.Devices.Sms.SmsDataFormat): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsBinaryMessage>;
        static fromBinaryMessage(binaryMessage: Windows.Devices.Sms.SmsBinaryMessage): Windows.Devices.Sms.SmsTextMessage;
        static fromBinaryData(format: Windows.Devices.Sms.SmsDataFormat, value: any): Windows.Devices.Sms.SmsTextMessage;
        body: string;
        encoding: Windows.Devices.Sms.SmsEncoding;
        from: string;
        partCount: number;
        partNumber: number;
        partReferenceId: number;
        timestamp: Date;
        to: string;
        id: number;
        messageClass: Windows.Devices.Sms.SmsMessageClass;
    }

}
declare module Windows.Foundation {

    export interface AsyncActionCompletedHandler {
        target: Windows.Foundation.IAsyncAction;
        detail: any[];
        type: string;
    }

    export interface AsyncActionProgressHandler<TProgress> {
        target: Windows.Foundation.IAsyncActionWithProgress<TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncActionWithProgressCompletedHandler<TProgress> {
        target: Windows.Foundation.IAsyncActionWithProgress<TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationCompletedHandler<TResult> {
        target: Windows.Foundation.IAsyncOperation<TResult>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationProgressHandler<TResult, TProgress> {
        target: Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationWithProgressCompletedHandler<TResult, TProgress> {
        target: Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>;
        detail: any[];
        type: string;
    }

    enum AsyncStatus {
        started,
        completed,
        canceled,
        error
    }

    export class DateTime {
        universalTime: number;
    }

    export interface EventHandler<T> {
        target: any;
        detail: any[];
        type: string;
    }

    export class EventRegistrationToken {
        value: number;
    }

    export class HResult {
        value: number;
    }

    export interface IAsyncAction extends Windows.Foundation.IAsyncInfo {
        getResults(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
    }

    export interface IAsyncActionWithProgress<TProgress> extends Windows.Foundation.IAsyncInfo {
        getResults(): void;
        progress: Windows.Foundation.AsyncActionProgressHandler<TProgress>;
        completed: Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>;
    }

    export interface IAsyncInfo {
        cancel(): void;
        close(): void;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export interface IAsyncOperation<TResult> extends Windows.Foundation.IAsyncInfo {
        getResults(): TResult;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<TResult>;

        // Promise Extension
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: TResult) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export interface IAsyncOperationWithProgress<TResult, TProgress> extends Windows.Foundation.IAsyncInfo {
        getResults(): TResult;
        progress: Windows.Foundation.AsyncOperationProgressHandler<TResult,TProgress>;
        completed: Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult,TProgress>;

        // Promise Extension
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: TResult) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export interface IClosable {
        close(): void;
    }

    export interface IGetActivationFactory {
        getActivationFactory(activatableClassId: string): any;
    }

    export interface IPropertyValue {
        getUInt8(): number;
        getInt16(): number;
        getUInt16(): number;
        getInt32(): number;
        getUInt32(): number;
        getInt64(): number;
        getUInt64(): number;
        getSingle(): number;
        getDouble(): number;
        getChar16(): number;
        getBoolean(): boolean;
        getString(): string;
        getGuid(): string;
        getDateTime(): Date;
        getTimeSpan(): Windows.Foundation.TimeSpan;
        getPoint(): Windows.Foundation.Point;
        getSize(): Windows.Foundation.Size;
        getRect(): Windows.Foundation.Rect;
        getUInt8Array(): IPropertyValue_getUInt8Array_OUT;
        getInt16Array(): IPropertyValue_getInt16Array_OUT;
        getUInt16Array(): IPropertyValue_getUInt16Array_OUT;
        getInt32Array(): IPropertyValue_getInt32Array_OUT;
        getUInt32Array(): IPropertyValue_getUInt32Array_OUT;
        getInt64Array(): IPropertyValue_getInt64Array_OUT;
        getUInt64Array(): IPropertyValue_getUInt64Array_OUT;
        getSingleArray(): IPropertyValue_getSingleArray_OUT;
        getDoubleArray(): IPropertyValue_getDoubleArray_OUT;
        getChar16Array(): IPropertyValue_getChar16Array_OUT;
        getBooleanArray(): IPropertyValue_getBooleanArray_OUT;
        getStringArray(): IPropertyValue_getStringArray_OUT;
        getInspectableArray(): IPropertyValue_getInspectableArray_OUT;
        getGuidArray(): IPropertyValue_getGuidArray_OUT;
        getDateTimeArray(): IPropertyValue_getDateTimeArray_OUT;
        getTimeSpanArray(): IPropertyValue_getTimeSpanArray_OUT;
        getPointArray(): IPropertyValue_getPointArray_OUT;
        getSizeArray(): IPropertyValue_getSizeArray_OUT;
        getRectArray(): IPropertyValue_getRectArray_OUT;
        isNumericScalar: boolean;
        type: Windows.Foundation.PropertyType;
    }

    interface IPropertyValue_getUInt8Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt32Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt32Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt64Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt64Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getSingleArray_OUT {
        value: number[];
    }

    interface IPropertyValue_getDoubleArray_OUT {
        value: number[];
    }

    interface IPropertyValue_getChar16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getBooleanArray_OUT {
        value: boolean[];
    }

    interface IPropertyValue_getStringArray_OUT {
        value: string[];
    }

    interface IPropertyValue_getInspectableArray_OUT {
        value: any[];
    }

    interface IPropertyValue_getGuidArray_OUT {
        value: string[];
    }

    interface IPropertyValue_getDateTimeArray_OUT {
        value: Date[];
    }

    interface IPropertyValue_getTimeSpanArray_OUT {
        value: Windows.Foundation.TimeSpan[];
    }

    interface IPropertyValue_getPointArray_OUT {
        value: Windows.Foundation.Point[];
    }

    interface IPropertyValue_getSizeArray_OUT {
        value: Windows.Foundation.Size[];
    }

    interface IPropertyValue_getRectArray_OUT {
        value: Windows.Foundation.Rect[];
    }

    export interface IReference<T> extends Windows.Foundation.IPropertyValue {
        value: T;
    }

    export interface IReferenceArray<T> extends Windows.Foundation.IPropertyValue {
        value: T[];
    }

    export interface IUriRuntimeClass {
        equals(pUri: Windows.Foundation.Uri): boolean;
        combineUri(relativeUri: string): Windows.Foundation.Uri;
        absoluteUri: string;
        displayUri: string;
        domain: string;
        extension: string;
        fragment: string;
        host: string;
        password: string;
        path: string;
        port: number;
        query: string;
        queryParsed: Windows.Foundation.WwwFormUrlDecoder;
        rawUri: string;
        schemeName: string;
        suspicious: boolean;
        userName: string;
    }

    export interface IUriRuntimeClassWithAbsoluteCanonicalUri {
        absoluteCanonicalUri: string;
        displayIri: string;
    }

    export interface IWwwFormUrlDecoderEntry {
        name: string;
        value: string;
    }

    export interface IWwwFormUrlDecoderRuntimeClass extends Windows.Foundation.Collections.IIterable<Windows.Foundation.IWwwFormUrlDecoderEntry>, Windows.Foundation.Collections.IVectorView<Windows.Foundation.IWwwFormUrlDecoderEntry> {
        getFirstValueByName(name: string): string;
    }

    export class Point {
        x: number;
        y: number;
    }

    enum PropertyType {
        empty,
        uInt8,
        int16,
        uInt16,
        int32,
        uInt32,
        int64,
        uInt64,
        single,
        double,
        char16,
        boolean,
        string,
        inspectable,
        dateTime,
        timeSpan,
        guid,
        point,
        size,
        rect,
        otherType,
        uInt8Array,
        int16Array,
        uInt16Array,
        int32Array,
        uInt32Array,
        int64Array,
        uInt64Array,
        singleArray,
        doubleArray,
        char16Array,
        booleanArray,
        stringArray,
        inspectableArray,
        dateTimeArray,
        timeSpanArray,
        guidArray,
        pointArray,
        sizeArray,
        rectArray,
        otherTypeArray
    }

    export class PropertyValue {
        static createEmpty(): any;
        static createUInt8(value: number): any;
        static createInt16(value: number): any;
        static createUInt16(value: number): any;
        static createInt32(value: number): any;
        static createUInt32(value: number): any;
        static createInt64(value: number): any;
        static createUInt64(value: number): any;
        static createSingle(value: number): any;
        static createDouble(value: number): any;
        static createChar16(value: number): any;
        static createBoolean(value: boolean): any;
        static createString(value: string): any;
        static createInspectable(value: any): any;
        static createGuid(value: string): any;
        static createDateTime(value: Date): any;
        static createTimeSpan(value: Windows.Foundation.TimeSpan): any;
        static createPoint(value: Windows.Foundation.Point): any;
        static createSize(value: Windows.Foundation.Size): any;
        static createRect(value: Windows.Foundation.Rect): any;
        static createUInt8Array(value: any): any;
        static createInt16Array(value: number[]): any;
        static createUInt16Array(value: number[]): any;
        static createInt32Array(value: number[]): any;
        static createUInt32Array(value: number[]): any;
        static createInt64Array(value: number[]): any;
        static createUInt64Array(value: number[]): any;
        static createSingleArray(value: number[]): any;
        static createDoubleArray(value: number[]): any;
        static createChar16Array(value: number[]): any;
        static createBooleanArray(value: boolean[]): any;
        static createStringArray(value: string[]): any;
        static createInspectableArray(value: any[]): any;
        static createGuidArray(value: string[]): any;
        static createDateTimeArray(value: Date[]): any;
        static createTimeSpanArray(value: Windows.Foundation.TimeSpan[]): any;
        static createPointArray(value: Windows.Foundation.Point[]): any;
        static createSizeArray(value: Windows.Foundation.Size[]): any;
        static createRectArray(value: Windows.Foundation.Rect[]): any;
    }

    export class Rect {
        x: number;
        y: number;
        width: number;
        height: number;
    }

    export class Size {
        width: number;
        height: number;
    }

    export class TimeSpan {
        duration: number;
    }

    export interface TypedEventHandler<TSender, TResult> {
        target: TSender;
        detail: any[];
        type: string;
    }

    export class Uri implements Windows.Foundation.IUriRuntimeClass, Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri {
        constructor(uri: string);
        constructor(baseUri: string, relativeUri: string);
        equals(pUri: Windows.Foundation.Uri): boolean;
        combineUri(relativeUri: string): Windows.Foundation.Uri;
        static unescapeComponent(toUnescape: string): string;
        static escapeComponent(toEscape: string): string;
        absoluteUri: string;
        displayUri: string;
        domain: string;
        extension: string;
        fragment: string;
        host: string;
        password: string;
        path: string;
        port: number;
        query: string;
        queryParsed: Windows.Foundation.WwwFormUrlDecoder;
        rawUri: string;
        schemeName: string;
        suspicious: boolean;
        userName: string;
        absoluteCanonicalUri: string;
        displayIri: string;
    }

    export class WwwFormUrlDecoder implements Windows.Foundation.IWwwFormUrlDecoderRuntimeClass, Windows.Foundation.Collections.IIterable<Windows.Foundation.IWwwFormUrlDecoderEntry>, Windows.Foundation.Collections.IVectorView<Windows.Foundation.IWwwFormUrlDecoderEntry> {
        constructor(query: string);
        getFirstValueByName(name: string): string;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.IWwwFormUrlDecoderEntry>;
        getAt(index: number): Windows.Foundation.IWwwFormUrlDecoderEntry;
        indexOf(value: Windows.Foundation.IWwwFormUrlDecoderEntry): WwwFormUrlDecoder_indexOf_OUT;
        getMany(startIndex: number): WwwFormUrlDecoder_getMany_OUT;
        size: number;
    }

    interface WwwFormUrlDecoder_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface WwwFormUrlDecoder_getMany_OUT {
        __returnValue: number;
        items: Windows.Foundation.IWwwFormUrlDecoderEntry[];
    }

}
declare module Windows.Foundation.Collections {

    enum CollectionChange {
        reset,
        itemInserted,
        itemRemoved,
        itemChanged
    }

    export interface IIterable<T> {
        first(): Windows.Foundation.Collections.IIterator<T>;
    }

    export interface IIterator<T> {
        moveNext(): boolean;
        getMany(): IIterator_getMany_OUT<T>;
        current: T;
        hasCurrent: boolean;
    }

    interface IIterator_getMany_OUT<T> {
        __returnValue: number;
        items: T[];
    }

    export interface IKeyValuePair<K, V> {
        key: K;
        value: V;
    }

    export interface IMap<K, V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        lookup(key: K): V;
        hasKey(key: K): boolean;
        getView(): Windows.Foundation.Collections.IMapView<K,V>;
        insert(key: K, value: V): boolean;
        remove(key: K): void;
        clear(): void;
        size: number;
    }

    export interface IMapChangedEventArgs<K> {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        key: K;
    }

    export interface IMapView<K, V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        lookup(key: K): V;
        hasKey(key: K): boolean;
        split(): IMapView_split_OUT<K, V>;
        size: number;
    }

    interface IMapView_split_OUT<K, V> {
        first: Windows.Foundation.Collections.IMapView<K,V>;
        second: Windows.Foundation.Collections.IMapView<K,V>;
    }

    export interface IObservableMap<K, V> extends Windows.Foundation.Collections.IMap<K,V> {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<K,V>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<K,V>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<K,V>) => void;

    }

    export interface IObservableVector<T> extends Windows.Foundation.Collections.IVector<T> {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "vectorchanged", listener: Windows.Foundation.Collections.VectorChangedEventHandler<T>): void;
        removeEventListener(eventName: "vectorchanged", listener: Windows.Foundation.Collections.VectorChangedEventHandler<T>): void;
        onvectorchanged: (ev: Windows.Foundation.Collections.VectorChangedEventHandler<T>) => void;

    }

    export interface IPropertySet extends Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
    }

    export interface IVector<T> extends Windows.Foundation.Collections.IIterable<T> {
        getAt(index: number): T;
        getView(): Windows.Foundation.Collections.IVectorView<T>;
        indexOf(value: T): IVector_indexOf_OUT<T>;
        setAt(index: number, value: T): void;
        insertAt(index: number, value: T): void;
        removeAt(index: number): void;
        append(value: T): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): IVector_getMany_OUT<T>;
        replaceAll(items: T[]): void;
        size: number;
    }

    interface IVector_indexOf_OUT<T> {
        __returnValue: boolean;
        index: number;
    }

    interface IVector_getMany_OUT<T> {
        __returnValue: number;
        items: T[];
    }

    export interface IVectorChangedEventArgs {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        index: number;
    }

    export interface IVectorView<T> extends Windows.Foundation.Collections.IIterable<T> {
        getAt(index: number): T;
        indexOf(value: T): IVectorView_indexOf_OUT<T>;
        getMany(startIndex: number): IVectorView_getMany_OUT<T>;
        size: number;
    }

    interface IVectorView_indexOf_OUT<T> {
        __returnValue: boolean;
        index: number;
    }

    interface IVectorView_getMany_OUT<T> {
        __returnValue: number;
        items: T[];
    }

    export interface MapChangedEventHandler<K, V> {
        target: Windows.Foundation.Collections.IObservableMap<K,V>;
        detail: any[];
        type: string;
    }

    export class PropertySet implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        constructor();
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    export interface VectorChangedEventHandler<T> {
        target: Windows.Foundation.Collections.IObservableVector<T>;
        detail: any[];
        type: string;
    }

}
declare module Windows.Foundation.Diagnostics {

    enum ErrorOptions {
        none,
        suppressExceptions,
        forceExceptions,
        useSetErrorInfo,
        suppressSetErrorInfo
    }

    export interface IErrorReportingSettings {
        setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void;
        getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
    }

    export class RuntimeBrokerErrorSettings implements Windows.Foundation.Diagnostics.IErrorReportingSettings {
        constructor();
        setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void;
        getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
    }

}
declare module Windows.Foundation.Metadata {

    export class ActivatableAttribute {
        constructor(version: number);
        constructor(type: string /*System.Type?*/, version: number);
    }

    export class AllowMultipleAttribute {
        constructor();
    }

    enum AttributeTargets {
        delegate,
        enum,
        event,
        field,
        interface,
        method,
        parameter,
        property,
        runtimeClass,
        struct,
        interfaceImpl,
        all
    }

    export class AttributeUsageAttribute {
        constructor(targets: Windows.Foundation.Metadata.AttributeTargets);
    }

    export class ComposableAttribute {
        constructor(type: string /*System.Type?*/, compositionType: Windows.Foundation.Metadata.CompositionType, version: number);
    }

    enum CompositionType {
        protected,
        public
    }

    export class DefaultAttribute {
        constructor();
    }

    export class DefaultOverloadAttribute {
        constructor();
    }

    export class DualApiPartitionAttribute {
        constructor();
        version: number;
    }

    export class ExclusiveToAttribute {
        constructor(typeName: string /*System.Type?*/);
    }

    enum GCPressureAmount {
        low,
        medium,
        high
    }

    export class GCPressureAttribute {
        constructor();
        amount: Windows.Foundation.Metadata.GCPressureAmount;
    }

    export class GuidAttribute {
        constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number);
    }

    export class HasVariantAttribute {
        constructor();
    }

    export class LengthIsAttribute {
        constructor(indexLengthParameter: number);
    }

    export class MarshalingBehaviorAttribute {
        constructor(behavior: Windows.Foundation.Metadata.MarshalingType);
    }

    enum MarshalingType {
        invalidMarshaling,
        none,
        agile,
        standard
    }

    export class MuseAttribute {
        constructor();
        version: number;
    }

    export class OverloadAttribute {
        constructor(method: string);
    }

    export class OverridableAttribute {
        constructor();
    }

    export class ProtectedAttribute {
        constructor();
    }

    export class RangeAttribute {
        constructor(minValue: number, maxValue: number);
    }

    export class StaticAttribute {
        constructor(type: string /*System.Type?*/, version: number);
    }

    export class ThreadingAttribute {
        constructor(model: Windows.Foundation.Metadata.ThreadingModel);
    }

    enum ThreadingModel {
        invalidThreading,
        sta,
        mta,
        both
    }

    export class VariantAttribute {
        constructor();
    }

    export class VersionAttribute {
        constructor(version: number);
    }

    export class WebHostHiddenAttribute {
        constructor();
    }

}
declare module Windows.Globalization {

    export class ApplicationLanguages {
        static languages: Windows.Foundation.Collections.IVectorView<string>;
        static manifestLanguages: Windows.Foundation.Collections.IVectorView<string>;
        static primaryLanguageOverride: string;
    }

    export class Calendar implements Windows.Globalization.ICalendar {
        constructor(languages: Windows.Foundation.Collections.IIterable<string>);
        constructor(languages: Windows.Foundation.Collections.IIterable<string>, calendar: string, clock: string);
        constructor();
        clone(): Windows.Globalization.Calendar;
        setToMin(): void;
        setToMax(): void;
        getCalendarSystem(): string;
        changeCalendarSystem(value: string): void;
        getClock(): string;
        changeClock(value: string): void;
        getDateTime(): Date;
        setDateTime(value: Date): void;
        setToNow(): void;
        addEras(eras: number): void;
        eraAsString(): string;
        eraAsString(idealLength: number): string;
        addYears(years: number): void;
        yearAsString(): string;
        yearAsTruncatedString(remainingDigits: number): string;
        yearAsPaddedString(minDigits: number): string;
        addMonths(months: number): void;
        monthAsString(): string;
        monthAsString(idealLength: number): string;
        monthAsSoloString(): string;
        monthAsSoloString(idealLength: number): string;
        monthAsNumericString(): string;
        monthAsPaddedNumericString(minDigits: number): string;
        addWeeks(weeks: number): void;
        addDays(days: number): void;
        dayAsString(): string;
        dayAsPaddedString(minDigits: number): string;
        dayOfWeekAsString(): string;
        dayOfWeekAsString(idealLength: number): string;
        dayOfWeekAsSoloString(): string;
        dayOfWeekAsSoloString(idealLength: number): string;
        addPeriods(periods: number): void;
        periodAsString(): string;
        periodAsString(idealLength: number): string;
        addHours(hours: number): void;
        hourAsString(): string;
        hourAsPaddedString(minDigits: number): string;
        addMinutes(minutes: number): void;
        minuteAsString(): string;
        minuteAsPaddedString(minDigits: number): string;
        addSeconds(seconds: number): void;
        secondAsString(): string;
        secondAsPaddedString(minDigits: number): string;
        addNanoseconds(nanoseconds: number): void;
        nanosecondAsString(): string;
        nanosecondAsPaddedString(minDigits: number): string;
        compare(other: Windows.Globalization.Calendar): number;
        compareDateTime(other: Date): number;
        copyTo(other: Windows.Globalization.Calendar): void;
        day: number;
        dayOfWeek: Windows.Globalization.DayOfWeek;
        era: number;
        firstDayInThisMonth: number;
        firstEra: number;
        firstHourInThisPeriod: number;
        firstMinuteInThisHour: number;
        firstMonthInThisYear: number;
        firstPeriodInThisDay: number;
        firstSecondInThisMinute: number;
        firstYearInThisEra: number;
        hour: number;
        isDaylightSavingTime: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        lastDayInThisMonth: number;
        lastEra: number;
        lastHourInThisPeriod: number;
        lastMinuteInThisHour: number;
        lastMonthInThisYear: number;
        lastPeriodInThisDay: number;
        lastSecondInThisMinute: number;
        lastYearInThisEra: number;
        minute: number;
        month: number;
        nanosecond: number;
        numberOfDaysInThisMonth: number;
        numberOfEras: number;
        numberOfHoursInThisPeriod: number;
        numberOfMinutesInThisHour: number;
        numberOfMonthsInThisYear: number;
        numberOfPeriodsInThisDay: number;
        numberOfSecondsInThisMinute: number;
        numberOfYearsInThisEra: number;
        numeralSystem: string;
        period: number;
        resolvedLanguage: string;
        second: number;
        year: number;
    }

    export class CalendarIdentifiers {
        static gregorian: string;
        static hebrew: string;
        static hijri: string;
        static japanese: string;
        static julian: string;
        static korean: string;
        static taiwan: string;
        static thai: string;
        static umAlQura: string;
    }

    export class ClockIdentifiers {
        static twelveHour: string;
        static twentyFourHour: string;
    }

    enum DayOfWeek {
        sunday,
        monday,
        tuesday,
        wednesday,
        thursday,
        friday,
        saturday
    }

    export class GeographicRegion implements Windows.Globalization.IGeographicRegion {
        constructor(geographicRegionCode: string);
        constructor();
        static isSupported(geographicRegionCode: string): boolean;
        code: string;
        codeThreeDigit: string;
        codeThreeLetter: string;
        codeTwoLetter: string;
        currenciesInUse: Windows.Foundation.Collections.IVectorView<string>;
        displayName: string;
        nativeName: string;
    }

    export interface ICalendar {
        clone(): Windows.Globalization.Calendar;
        setToMin(): void;
        setToMax(): void;
        getCalendarSystem(): string;
        changeCalendarSystem(value: string): void;
        getClock(): string;
        changeClock(value: string): void;
        getDateTime(): Date;
        setDateTime(value: Date): void;
        setToNow(): void;
        addEras(eras: number): void;
        eraAsString(): string;
        eraAsString(idealLength: number): string;
        addYears(years: number): void;
        yearAsString(): string;
        yearAsTruncatedString(remainingDigits: number): string;
        yearAsPaddedString(minDigits: number): string;
        addMonths(months: number): void;
        monthAsString(): string;
        monthAsString(idealLength: number): string;
        monthAsSoloString(): string;
        monthAsSoloString(idealLength: number): string;
        monthAsNumericString(): string;
        monthAsPaddedNumericString(minDigits: number): string;
        addWeeks(weeks: number): void;
        addDays(days: number): void;
        dayAsString(): string;
        dayAsPaddedString(minDigits: number): string;
        dayOfWeekAsString(): string;
        dayOfWeekAsString(idealLength: number): string;
        dayOfWeekAsSoloString(): string;
        dayOfWeekAsSoloString(idealLength: number): string;
        addPeriods(periods: number): void;
        periodAsString(): string;
        periodAsString(idealLength: number): string;
        addHours(hours: number): void;
        hourAsString(): string;
        hourAsPaddedString(minDigits: number): string;
        addMinutes(minutes: number): void;
        minuteAsString(): string;
        minuteAsPaddedString(minDigits: number): string;
        addSeconds(seconds: number): void;
        secondAsString(): string;
        secondAsPaddedString(minDigits: number): string;
        addNanoseconds(nanoseconds: number): void;
        nanosecondAsString(): string;
        nanosecondAsPaddedString(minDigits: number): string;
        compare(other: Windows.Globalization.Calendar): number;
        compareDateTime(other: Date): number;
        copyTo(other: Windows.Globalization.Calendar): void;
        day: number;
        dayOfWeek: Windows.Globalization.DayOfWeek;
        era: number;
        firstDayInThisMonth: number;
        firstEra: number;
        firstHourInThisPeriod: number;
        firstMinuteInThisHour: number;
        firstMonthInThisYear: number;
        firstPeriodInThisDay: number;
        firstSecondInThisMinute: number;
        firstYearInThisEra: number;
        hour: number;
        isDaylightSavingTime: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        lastDayInThisMonth: number;
        lastEra: number;
        lastHourInThisPeriod: number;
        lastMinuteInThisHour: number;
        lastMonthInThisYear: number;
        lastPeriodInThisDay: number;
        lastSecondInThisMinute: number;
        lastYearInThisEra: number;
        minute: number;
        month: number;
        nanosecond: number;
        numberOfDaysInThisMonth: number;
        numberOfEras: number;
        numberOfHoursInThisPeriod: number;
        numberOfMinutesInThisHour: number;
        numberOfMonthsInThisYear: number;
        numberOfPeriodsInThisDay: number;
        numberOfSecondsInThisMinute: number;
        numberOfYearsInThisEra: number;
        numeralSystem: string;
        period: number;
        resolvedLanguage: string;
        second: number;
        year: number;
    }

    export interface IGeographicRegion {
        code: string;
        codeThreeDigit: string;
        codeThreeLetter: string;
        codeTwoLetter: string;
        currenciesInUse: Windows.Foundation.Collections.IVectorView<string>;
        displayName: string;
        nativeName: string;
    }

    export interface ILanguage {
        displayName: string;
        languageTag: string;
        nativeName: string;
        script: string;
    }

    export class Language implements Windows.Globalization.ILanguage {
        constructor(languageTag: string);
        static isWellFormed(languageTag: string): boolean;
        displayName: string;
        languageTag: string;
        nativeName: string;
        script: string;
        static currentInputMethodLanguageTag: string;
    }

}
declare module Windows.Globalization.Collation {

    export class CharacterGrouping implements Windows.Globalization.Collation.ICharacterGrouping {
        first: string;
        label: string;
    }

    export class CharacterGroupings implements Windows.Globalization.Collation.ICharacterGroupings, Windows.Foundation.Collections.IVectorView<Windows.Globalization.Collation.CharacterGrouping>, Windows.Foundation.Collections.IIterable<Windows.Globalization.Collation.CharacterGrouping> {
        constructor();
        lookup(text: string): string;
        getAt(index: number): Windows.Globalization.Collation.CharacterGrouping;
        indexOf(value: Windows.Globalization.Collation.CharacterGrouping): CharacterGroupings_indexOf_OUT;
        getMany(startIndex: number): CharacterGroupings_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Globalization.Collation.CharacterGrouping>;
        size: number;
    }

    interface CharacterGroupings_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface CharacterGroupings_getMany_OUT {
        __returnValue: number;
        items: Windows.Globalization.Collation.CharacterGrouping[];
    }

    export interface ICharacterGrouping {
        first: string;
        label: string;
    }

    export interface ICharacterGroupings extends Windows.Foundation.Collections.IVectorView<Windows.Globalization.Collation.CharacterGrouping>, Windows.Foundation.Collections.IIterable<Windows.Globalization.Collation.CharacterGrouping> {
        lookup(text: string): string;
    }

}
declare module Windows.Globalization.DateTimeFormatting {

    export class DateTimeFormatter implements Windows.Globalization.DateTimeFormatting.IDateTimeFormatter {
        constructor(formatTemplate: string);
        constructor(formatTemplate: string, languages: Windows.Foundation.Collections.IIterable<string>);
        constructor(formatTemplate: string, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string, calendar: string, clock: string);
        constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat);
        constructor(hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat);
        constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat, hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat, languages: Windows.Foundation.Collections.IIterable<string>);
        constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat, hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string, calendar: string, clock: string);
        format(value: Date): string;
        calendar: string;
        clock: string;
        geographicRegion: string;
        includeDay: Windows.Globalization.DateTimeFormatting.DayFormat;
        includeDayOfWeek: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat;
        includeHour: Windows.Globalization.DateTimeFormatting.HourFormat;
        includeMinute: Windows.Globalization.DateTimeFormatting.MinuteFormat;
        includeMonth: Windows.Globalization.DateTimeFormatting.MonthFormat;
        includeSecond: Windows.Globalization.DateTimeFormatting.SecondFormat;
        includeYear: Windows.Globalization.DateTimeFormatting.YearFormat;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        patterns: Windows.Foundation.Collections.IVectorView<string>;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
        template: string;
        static longDate: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
        static longTime: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
        static shortDate: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
        static shortTime: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
    }

    enum DayFormat {
        none,
        default
    }

    enum DayOfWeekFormat {
        none,
        default,
        abbreviated,
        full
    }

    enum HourFormat {
        none,
        default
    }

    export interface IDateTimeFormatter {
        format(value: Date): string;
        calendar: string;
        clock: string;
        geographicRegion: string;
        includeDay: Windows.Globalization.DateTimeFormatting.DayFormat;
        includeDayOfWeek: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat;
        includeHour: Windows.Globalization.DateTimeFormatting.HourFormat;
        includeMinute: Windows.Globalization.DateTimeFormatting.MinuteFormat;
        includeMonth: Windows.Globalization.DateTimeFormatting.MonthFormat;
        includeSecond: Windows.Globalization.DateTimeFormatting.SecondFormat;
        includeYear: Windows.Globalization.DateTimeFormatting.YearFormat;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        patterns: Windows.Foundation.Collections.IVectorView<string>;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
        template: string;
    }

    enum MinuteFormat {
        none,
        default
    }

    enum MonthFormat {
        none,
        default,
        abbreviated,
        full,
        numeric
    }

    enum SecondFormat {
        none,
        default
    }

    enum YearFormat {
        none,
        default,
        abbreviated,
        full
    }

}
declare module Windows.Globalization.Fonts {

    export interface ILanguageFont {
        fontFamily: string;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        scaleFactor: number;
    }

    export interface ILanguageFontGroup {
        documentAlternate1Font: Windows.Globalization.Fonts.LanguageFont;
        documentAlternate2Font: Windows.Globalization.Fonts.LanguageFont;
        documentHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        fixedWidthTextFont: Windows.Globalization.Fonts.LanguageFont;
        modernDocumentFont: Windows.Globalization.Fonts.LanguageFont;
        traditionalDocumentFont: Windows.Globalization.Fonts.LanguageFont;
        uICaptionFont: Windows.Globalization.Fonts.LanguageFont;
        uIHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        uINotificationHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        uITextFont: Windows.Globalization.Fonts.LanguageFont;
        uITitleFont: Windows.Globalization.Fonts.LanguageFont;
    }

    export class LanguageFont implements Windows.Globalization.Fonts.ILanguageFont {
        fontFamily: string;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        scaleFactor: number;
    }

    export class LanguageFontGroup implements Windows.Globalization.Fonts.ILanguageFontGroup {
        constructor(languageTag: string);
        documentAlternate1Font: Windows.Globalization.Fonts.LanguageFont;
        documentAlternate2Font: Windows.Globalization.Fonts.LanguageFont;
        documentHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        fixedWidthTextFont: Windows.Globalization.Fonts.LanguageFont;
        modernDocumentFont: Windows.Globalization.Fonts.LanguageFont;
        traditionalDocumentFont: Windows.Globalization.Fonts.LanguageFont;
        uICaptionFont: Windows.Globalization.Fonts.LanguageFont;
        uIHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        uINotificationHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        uITextFont: Windows.Globalization.Fonts.LanguageFont;
        uITitleFont: Windows.Globalization.Fonts.LanguageFont;
    }

}
declare module Windows.Globalization.NumberFormatting {

    export class CurrencyFormatter implements Windows.Globalization.NumberFormatting.ICurrencyFormatter, Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        constructor(currencyCode: string);
        constructor(currencyCode: string, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string);
        format(value: number): string;
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
        currency: string;
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

    export class DecimalFormatter implements Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string);
        constructor();
        format(value: number): string;
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

    export interface ICurrencyFormatter extends Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        currency: string;
    }

    export interface INumberFormatter {
        format(value: number): string;
    }

    export interface INumberFormatter2 {
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
    }

    export interface INumberFormatterOptions {
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

    export interface INumberParser {
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
    }

    export class PercentFormatter implements Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string);
        constructor();
        format(value: number): string;
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

    export class PermilleFormatter implements Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string);
        constructor();
        format(value: number): string;
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

}
declare module Windows.Graphics.Display {

    enum DisplayOrientations {
        none,
        landscape,
        portrait,
        landscapeFlipped,
        portraitFlipped
    }

    export class DisplayProperties {
        static getColorProfileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
        static autoRotationPreferences: Windows.Graphics.Display.DisplayOrientations;
        static currentOrientation: Windows.Graphics.Display.DisplayOrientations;
        static logicalDpi: number;
        static nativeOrientation: Windows.Graphics.Display.DisplayOrientations;
        static resolutionScale: Windows.Graphics.Display.ResolutionScale;
        static stereoEnabled: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "colorprofilechanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "colorprofilechanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        oncolorprofilechanged: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;
        addEventListener(eventName: "displaycontentsinvalidated", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "displaycontentsinvalidated", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        ondisplaycontentsinvalidated: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;
        addEventListener(eventName: "logicaldpichanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "logicaldpichanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        onlogicaldpichanged: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;
        addEventListener(eventName: "orientationchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "orientationchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        onorientationchanged: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;
        addEventListener(eventName: "stereoenabledchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "stereoenabledchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        onstereoenabledchanged: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;

    }

    export interface DisplayPropertiesEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum ResolutionScale {
        invalid,
        scale100Percent,
        scale140Percent,
        scale180Percent
    }

}
declare module Windows.Graphics.Imaging {

    enum BitmapAlphaMode {
        premultiplied,
        straight,
        ignore
    }

    export class BitmapBounds {
        x: number;
        y: number;
        width: number;
        height: number;
    }

    export class BitmapCodecInformation implements Windows.Graphics.Imaging.IBitmapCodecInformation {
        codecId: string;
        fileExtensions: Windows.Foundation.Collections.IVectorView<string>;
        friendlyName: string;
        mimeTypes: Windows.Foundation.Collections.IVectorView<string>;
    }

    export class BitmapDecoder implements Windows.Graphics.Imaging.IBitmapDecoder, Windows.Graphics.Imaging.IBitmapFrame {
        getPreviewAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getFrameAsync(frameIndex: number): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapFrame>;
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getPixelDataAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        getPixelDataAsync(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        static getDecoderInformationEnumerator(): Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapCodecInformation>;
        static createAsync(stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapDecoder>;
        static createAsync(decoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapDecoder>;
        bitmapContainerProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        decoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
        frameCount: number;
        bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
        bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
        bitmapProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        dpiX: number;
        dpiY: number;
        orientedPixelHeight: number;
        orientedPixelWidth: number;
        pixelHeight: number;
        pixelWidth: number;
        static bmpDecoderId: string;
        static gifDecoderId: string;
        static icoDecoderId: string;
        static jpegDecoderId: string;
        static jpegXRDecoderId: string;
        static pngDecoderId: string;
        static tiffDecoderId: string;
    }

    export class BitmapEncoder implements Windows.Graphics.Imaging.IBitmapEncoder {
        setPixelData(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, width: number, height: number, dpiX: number, dpiY: number, pixels: any): void;
        goToNextFrameAsync(): Windows.Foundation.IAsyncAction;
        goToNextFrameAsync(encodingOptions: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncAction;
        flushAsync(): Windows.Foundation.IAsyncAction;
        static getEncoderInformationEnumerator(): Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapCodecInformation>;
        static createAsync(encoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
        static createAsync(encoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream, encodingOptions: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
        static createForTranscodingAsync(stream: Windows.Storage.Streams.IRandomAccessStream, bitmapDecoder: Windows.Graphics.Imaging.BitmapDecoder): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
        static createForInPlacePropertyEncodingAsync(bitmapDecoder: Windows.Graphics.Imaging.BitmapDecoder): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
        bitmapContainerProperties: Windows.Graphics.Imaging.BitmapProperties;
        bitmapProperties: Windows.Graphics.Imaging.BitmapProperties;
        bitmapTransform: Windows.Graphics.Imaging.BitmapTransform;
        encoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
        generatedThumbnailHeight: number;
        generatedThumbnailWidth: number;
        isThumbnailGenerated: boolean;
        static bmpEncoderId: string;
        static gifEncoderId: string;
        static jpegEncoderId: string;
        static jpegXREncoderId: string;
        static pngEncoderId: string;
        static tiffEncoderId: string;
    }

    enum BitmapFlip {
        none,
        horizontal,
        vertical
    }

    export class BitmapFrame implements Windows.Graphics.Imaging.IBitmapFrame {
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getPixelDataAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        getPixelDataAsync(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
        bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
        bitmapProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        dpiX: number;
        dpiY: number;
        orientedPixelHeight: number;
        orientedPixelWidth: number;
        pixelHeight: number;
        pixelWidth: number;
    }

    enum BitmapInterpolationMode {
        nearestNeighbor,
        linear,
        cubic,
        fant
    }

    enum BitmapPixelFormat {
        unknown,
        rgba16,
        rgba8,
        bgra8
    }

    export class BitmapProperties implements Windows.Graphics.Imaging.IBitmapProperties, Windows.Graphics.Imaging.IBitmapPropertiesView {
        setPropertiesAsync(propertiesToSet: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncAction;
        getPropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapPropertySet>;
    }

    export class BitmapPropertiesView implements Windows.Graphics.Imaging.IBitmapPropertiesView {
        getPropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapPropertySet>;
    }

    export class BitmapPropertySet implements Windows.Foundation.Collections.IMap<string,Windows.Graphics.Imaging.BitmapTypedValue>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>> {
        constructor();
        lookup(key: string): Windows.Graphics.Imaging.BitmapTypedValue;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,Windows.Graphics.Imaging.BitmapTypedValue>;
        insert(key: string, value: Windows.Graphics.Imaging.BitmapTypedValue): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>;
        size: number;
    }

    enum BitmapRotation {
        none,
        clockwise90Degrees,
        clockwise180Degrees,
        clockwise270Degrees
    }

    export class BitmapTransform implements Windows.Graphics.Imaging.IBitmapTransform {
        constructor();
        bounds: Windows.Graphics.Imaging.BitmapBounds;
        flip: Windows.Graphics.Imaging.BitmapFlip;
        interpolationMode: Windows.Graphics.Imaging.BitmapInterpolationMode;
        rotation: Windows.Graphics.Imaging.BitmapRotation;
        scaledHeight: number;
        scaledWidth: number;
    }

    export class BitmapTypedValue implements Windows.Graphics.Imaging.IBitmapTypedValue {
        constructor(value: any, type: Windows.Foundation.PropertyType);
        type: Windows.Foundation.PropertyType;
        value: any;
    }

    enum ColorManagementMode {
        doNotColorManage,
        colorManageToSRgb
    }

    enum ExifOrientationMode {
        ignoreExifOrientation,
        respectExifOrientation
    }

    export interface IBitmapCodecInformation {
        codecId: string;
        fileExtensions: Windows.Foundation.Collections.IVectorView<string>;
        friendlyName: string;
        mimeTypes: Windows.Foundation.Collections.IVectorView<string>;
    }

    export interface IBitmapDecoder {
        getPreviewAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getFrameAsync(frameIndex: number): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapFrame>;
        bitmapContainerProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        decoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
        frameCount: number;
    }

    export interface IBitmapEncoder {
        setPixelData(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, width: number, height: number, dpiX: number, dpiY: number, pixels: any): void;
        goToNextFrameAsync(): Windows.Foundation.IAsyncAction;
        goToNextFrameAsync(encodingOptions: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncAction;
        flushAsync(): Windows.Foundation.IAsyncAction;
        bitmapContainerProperties: Windows.Graphics.Imaging.BitmapProperties;
        bitmapProperties: Windows.Graphics.Imaging.BitmapProperties;
        bitmapTransform: Windows.Graphics.Imaging.BitmapTransform;
        encoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
        generatedThumbnailHeight: number;
        generatedThumbnailWidth: number;
        isThumbnailGenerated: boolean;
    }

    export interface IBitmapFrame {
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getPixelDataAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        getPixelDataAsync(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
        bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
        bitmapProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        dpiX: number;
        dpiY: number;
        orientedPixelHeight: number;
        orientedPixelWidth: number;
        pixelHeight: number;
        pixelWidth: number;
    }

    export interface IBitmapProperties extends Windows.Graphics.Imaging.IBitmapPropertiesView {
        setPropertiesAsync(propertiesToSet: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncAction;
    }

    export interface IBitmapPropertiesView {
        getPropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapPropertySet>;
    }

    export interface IBitmapTransform {
        bounds: Windows.Graphics.Imaging.BitmapBounds;
        flip: Windows.Graphics.Imaging.BitmapFlip;
        interpolationMode: Windows.Graphics.Imaging.BitmapInterpolationMode;
        rotation: Windows.Graphics.Imaging.BitmapRotation;
        scaledHeight: number;
        scaledWidth: number;
    }

    export interface IBitmapTypedValue {
        type: Windows.Foundation.PropertyType;
        value: any;
    }

    export class ImageStream implements Windows.Storage.Streams.IRandomAccessStreamWithContentType, Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream, Windows.Storage.Streams.IContentTypeProvider {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
        contentType: string;
    }

    export interface IPixelDataProvider {
        detachPixelData(): any;
    }

    enum JpegSubsamplingMode {
        default,
        y4Cb2Cr0,
        y4Cb2Cr2,
        y4Cb4Cr4
    }

    export class PixelDataProvider implements Windows.Graphics.Imaging.IPixelDataProvider {
        detachPixelData(): any;
    }

    enum PngFilterMode {
        automatic,
        none,
        sub,
        up,
        average,
        paeth,
        adaptive
    }

    enum TiffCompressionMode {
        automatic,
        none,
        ccitt3,
        ccitt4,
        lzw,
        rle,
        zip,
        lzwhDifferencing
    }

}
declare module Windows.Graphics.Printing {

    export interface IPrintDocumentSource {
    }

    export interface IPrintManager {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): void;
        removeEventListener(eventName: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): void;
        onprinttaskrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>) => void;

    }

    export interface IPrintTask {
        options: Windows.Graphics.Printing.PrintTaskOptions;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
        source: Windows.Graphics.Printing.IPrintDocumentSource;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): void;
        oncompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>) => void;
        addEventListener(eventName: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        removeEventListener(eventName: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        onpreviewing: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>) => void;
        addEventListener(eventName: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): void;
        removeEventListener(eventName: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): void;
        onprogressing: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>) => void;
        addEventListener(eventName: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        removeEventListener(eventName: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        onsubmitting: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>) => void;

    }

    export interface IPrintTaskCompletedEventArgs {
        completion: Windows.Graphics.Printing.PrintTaskCompletion;
    }

    export interface IPrintTaskOptionsCore {
        getPageDescription(jobPageNumber: number): Windows.Graphics.Printing.PrintPageDescription;
    }

    export interface IPrintTaskOptionsCoreProperties {
        binding: Windows.Graphics.Printing.PrintBinding;
        collation: Windows.Graphics.Printing.PrintCollation;
        colorMode: Windows.Graphics.Printing.PrintColorMode;
        duplex: Windows.Graphics.Printing.PrintDuplex;
        holePunch: Windows.Graphics.Printing.PrintHolePunch;
        maxCopies: number;
        mediaSize: Windows.Graphics.Printing.PrintMediaSize;
        mediaType: Windows.Graphics.Printing.PrintMediaType;
        minCopies: number;
        numberOfCopies: number;
        orientation: Windows.Graphics.Printing.PrintOrientation;
        printQuality: Windows.Graphics.Printing.PrintQuality;
        staple: Windows.Graphics.Printing.PrintStaple;
    }

    export interface IPrintTaskOptionsCoreUIConfiguration {
        displayedOptions: Windows.Foundation.Collections.IVector<string>;
    }

    export interface IPrintTaskProgressingEventArgs {
        documentPageCount: number;
    }

    export interface IPrintTaskRequest {
        createPrintTask(title: string, handler: Windows.Graphics.Printing.PrintTaskSourceRequestedHandler): Windows.Graphics.Printing.PrintTask;
        getDeferral(): Windows.Graphics.Printing.PrintTaskRequestedDeferral;
        deadline: Date;
    }

    export interface IPrintTaskRequestedDeferral {
        complete(): void;
    }

    export interface IPrintTaskRequestedEventArgs {
        request: Windows.Graphics.Printing.PrintTaskRequest;
    }

    export interface IPrintTaskSourceRequestedArgs {
        setSource(source: Windows.Graphics.Printing.IPrintDocumentSource): void;
        getDeferral(): Windows.Graphics.Printing.PrintTaskSourceRequestedDeferral;
        deadline: Date;
    }

    export interface IPrintTaskSourceRequestedDeferral {
        complete(): void;
    }

    enum PrintBinding {
        default,
        notAvailable,
        printerCustom,
        none,
        bale,
        bindBottom,
        bindLeft,
        bindRight,
        bindTop,
        booklet,
        edgeStitchBottom,
        edgeStitchLeft,
        edgeStitchRight,
        edgeStitchTop,
        fold,
        jogOffset,
        trim
    }

    enum PrintCollation {
        default,
        notAvailable,
        printerCustom,
        collated,
        uncollated
    }

    enum PrintColorMode {
        default,
        notAvailable,
        printerCustom,
        color,
        grayscale,
        monochrome
    }

    enum PrintDuplex {
        default,
        notAvailable,
        printerCustom,
        oneSided,
        twoSidedShortEdge,
        twoSidedLongEdge
    }

    enum PrintHolePunch {
        default,
        notAvailable,
        printerCustom,
        none,
        leftEdge,
        rightEdge,
        topEdge,
        bottomEdge
    }

    export class PrintManager implements Windows.Graphics.Printing.IPrintManager {
        static getForCurrentView(): Windows.Graphics.Printing.PrintManager;
        static showPrintUIAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): void;
        removeEventListener(eventName: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): void;
        onprinttaskrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>) => void;

    }

    enum PrintMediaSize {
        default,
        notAvailable,
        printerCustom,
        businessCard,
        creditCard,
        isoA0,
        isoA1,
        isoA10,
        isoA2,
        isoA3,
        isoA3Extra,
        isoA3Rotated,
        isoA4,
        isoA4Extra,
        isoA4Rotated,
        isoA5,
        isoA5Extra,
        isoA5Rotated,
        isoA6,
        isoA6Rotated,
        isoA7,
        isoA8,
        isoA9,
        isoB0,
        isoB1,
        isoB10,
        isoB2,
        isoB3,
        isoB4,
        isoB4Envelope,
        isoB5Envelope,
        isoB5Extra,
        isoB7,
        isoB8,
        isoB9,
        isoC0,
        isoC1,
        isoC10,
        isoC2,
        isoC3,
        isoC3Envelope,
        isoC4,
        isoC4Envelope,
        isoC5,
        isoC5Envelope,
        isoC6,
        isoC6C5Envelope,
        isoC6Envelope,
        isoC7,
        isoC8,
        isoC9,
        isoDLEnvelope,
        isoDLEnvelopeRotated,
        isoSRA3,
        japan2LPhoto,
        japanChou3Envelope,
        japanChou3EnvelopeRotated,
        japanChou4Envelope,
        japanChou4EnvelopeRotated,
        japanDoubleHagakiPostcard,
        japanDoubleHagakiPostcardRotated,
        japanHagakiPostcard,
        japanHagakiPostcardRotated,
        japanKaku2Envelope,
        japanKaku2EnvelopeRotated,
        japanKaku3Envelope,
        japanKaku3EnvelopeRotated,
        japanLPhoto,
        japanQuadrupleHagakiPostcard,
        japanYou1Envelope,
        japanYou2Envelope,
        japanYou3Envelope,
        japanYou4Envelope,
        japanYou4EnvelopeRotated,
        japanYou6Envelope,
        japanYou6EnvelopeRotated,
        jisB0,
        jisB1,
        jisB10,
        jisB2,
        jisB3,
        jisB4,
        jisB4Rotated,
        jisB5,
        jisB5Rotated,
        jisB6,
        jisB6Rotated,
        jisB7,
        jisB8,
        jisB9,
        northAmerica10x11,
        northAmerica10x12,
        northAmerica10x14,
        northAmerica11x17,
        northAmerica14x17,
        northAmerica4x6,
        northAmerica4x8,
        northAmerica5x7,
        northAmerica8x10,
        northAmerica9x11,
        northAmericaArchitectureASheet,
        northAmericaArchitectureBSheet,
        northAmericaArchitectureCSheet,
        northAmericaArchitectureDSheet,
        northAmericaArchitectureESheet,
        northAmericaCSheet,
        northAmericaDSheet,
        northAmericaESheet,
        northAmericaExecutive,
        northAmericaGermanLegalFanfold,
        northAmericaGermanStandardFanfold,
        northAmericaLegal,
        northAmericaLegalExtra,
        northAmericaLetter,
        northAmericaLetterExtra,
        northAmericaLetterPlus,
        northAmericaLetterRotated,
        northAmericaMonarchEnvelope,
        northAmericaNote,
        northAmericaNumber10Envelope,
        northAmericaNumber10EnvelopeRotated,
        northAmericaNumber11Envelope,
        northAmericaNumber12Envelope,
        northAmericaNumber14Envelope,
        northAmericaNumber9Envelope,
        northAmericaPersonalEnvelope,
        northAmericaQuarto,
        northAmericaStatement,
        northAmericaSuperA,
        northAmericaSuperB,
        northAmericaTabloid,
        northAmericaTabloidExtra,
        otherMetricA3Plus,
        otherMetricA4Plus,
        otherMetricFolio,
        otherMetricInviteEnvelope,
        otherMetricItalianEnvelope,
        prc10Envelope,
        prc10EnvelopeRotated,
        prc16K,
        prc16KRotated,
        prc1Envelope,
        prc1EnvelopeRotated,
        prc2Envelope,
        prc2EnvelopeRotated,
        prc32K,
        prc32KBig,
        prc32KRotated,
        prc3Envelope,
        prc3EnvelopeRotated,
        prc4Envelope,
        prc4EnvelopeRotated,
        prc5Envelope,
        prc5EnvelopeRotated,
        prc6Envelope,
        prc6EnvelopeRotated,
        prc7Envelope,
        prc7EnvelopeRotated,
        prc8Envelope,
        prc8EnvelopeRotated,
        prc9Envelope,
        prc9EnvelopeRotated,
        roll04Inch,
        roll06Inch,
        roll08Inch,
        roll12Inch,
        roll15Inch,
        roll18Inch,
        roll22Inch,
        roll24Inch,
        roll30Inch,
        roll36Inch,
        roll54Inch
    }

    enum PrintMediaType {
        default,
        notAvailable,
        printerCustom,
        autoSelect,
        archival,
        backPrintFilm,
        bond,
        cardStock,
        continuous,
        envelopePlain,
        envelopeWindow,
        fabric,
        highResolution,
        label,
        multiLayerForm,
        multiPartForm,
        photographic,
        photographicFilm,
        photographicGlossy,
        photographicHighGloss,
        photographicMatte,
        photographicSatin,
        photographicSemiGloss,
        plain,
        screen,
        screenPaged,
        stationery,
        tabStockFull,
        tabStockPreCut,
        transparency,
        tShirtTransfer,
        none
    }

    enum PrintOrientation {
        default,
        notAvailable,
        printerCustom,
        portrait,
        portraitFlipped,
        landscape,
        landscapeFlipped
    }

    export class PrintPageDescription {
        pageSize: Windows.Foundation.Size;
        imageableRect: Windows.Foundation.Rect;
        dpiX: number;
        dpiY: number;
    }

    enum PrintQuality {
        default,
        notAvailable,
        printerCustom,
        automatic,
        draft,
        fax,
        high,
        normal,
        photographic,
        text
    }

    enum PrintStaple {
        default,
        notAvailable,
        printerCustom,
        none,
        stapleTopLeft,
        stapleTopRight,
        stapleBottomLeft,
        stapleBottomRight,
        stapleDualLeft,
        stapleDualRight,
        stapleDualTop,
        stapleDualBottom,
        saddleStitch
    }

    export class PrintTask implements Windows.Graphics.Printing.IPrintTask {
        options: Windows.Graphics.Printing.PrintTaskOptions;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
        source: Windows.Graphics.Printing.IPrintDocumentSource;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): void;
        oncompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>) => void;
        addEventListener(eventName: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        removeEventListener(eventName: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        onpreviewing: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>) => void;
        addEventListener(eventName: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): void;
        removeEventListener(eventName: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): void;
        onprogressing: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>) => void;
        addEventListener(eventName: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        removeEventListener(eventName: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        onsubmitting: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>) => void;

    }

    export class PrintTaskCompletedEventArgs implements Windows.Graphics.Printing.IPrintTaskCompletedEventArgs {
        completion: Windows.Graphics.Printing.PrintTaskCompletion;
    }

    enum PrintTaskCompletion {
        abandoned,
        canceled,
        failed,
        submitted
    }

    export class PrintTaskOptions implements Windows.Graphics.Printing.IPrintTaskOptionsCore, Windows.Graphics.Printing.IPrintTaskOptionsCoreProperties, Windows.Graphics.Printing.IPrintTaskOptionsCoreUIConfiguration {
        getPageDescription(jobPageNumber: number): Windows.Graphics.Printing.PrintPageDescription;
        binding: Windows.Graphics.Printing.PrintBinding;
        collation: Windows.Graphics.Printing.PrintCollation;
        colorMode: Windows.Graphics.Printing.PrintColorMode;
        duplex: Windows.Graphics.Printing.PrintDuplex;
        holePunch: Windows.Graphics.Printing.PrintHolePunch;
        maxCopies: number;
        mediaSize: Windows.Graphics.Printing.PrintMediaSize;
        mediaType: Windows.Graphics.Printing.PrintMediaType;
        minCopies: number;
        numberOfCopies: number;
        orientation: Windows.Graphics.Printing.PrintOrientation;
        printQuality: Windows.Graphics.Printing.PrintQuality;
        staple: Windows.Graphics.Printing.PrintStaple;
        displayedOptions: Windows.Foundation.Collections.IVector<string>;
    }

    export class PrintTaskProgressingEventArgs implements Windows.Graphics.Printing.IPrintTaskProgressingEventArgs {
        documentPageCount: number;
    }

    export class PrintTaskRequest implements Windows.Graphics.Printing.IPrintTaskRequest {
        createPrintTask(title: string, handler: Windows.Graphics.Printing.PrintTaskSourceRequestedHandler): Windows.Graphics.Printing.PrintTask;
        getDeferral(): Windows.Graphics.Printing.PrintTaskRequestedDeferral;
        deadline: Date;
    }

    export class PrintTaskRequestedDeferral implements Windows.Graphics.Printing.IPrintTaskRequestedDeferral {
        complete(): void;
    }

    export class PrintTaskRequestedEventArgs implements Windows.Graphics.Printing.IPrintTaskRequestedEventArgs {
        request: Windows.Graphics.Printing.PrintTaskRequest;
    }

    export class PrintTaskSourceRequestedArgs implements Windows.Graphics.Printing.IPrintTaskSourceRequestedArgs {
        setSource(source: Windows.Graphics.Printing.IPrintDocumentSource): void;
        getDeferral(): Windows.Graphics.Printing.PrintTaskSourceRequestedDeferral;
        deadline: Date;
    }

    export class PrintTaskSourceRequestedDeferral implements Windows.Graphics.Printing.IPrintTaskSourceRequestedDeferral {
        complete(): void;
    }

    export interface PrintTaskSourceRequestedHandler {
        target: Windows.Graphics.Printing.PrintTaskSourceRequestedArgs;
        detail: any[];
        type: string;
    }

    export class StandardPrintTaskOptions {
        static binding: string;
        static collation: string;
        static colorMode: string;
        static copies: string;
        static duplex: string;
        static holePunch: string;
        static inputBin: string;
        static mediaSize: string;
        static mediaType: string;
        static nUp: string;
        static orientation: string;
        static printQuality: string;
        static staple: string;
    }

}
declare module Windows.Graphics.Printing.OptionDetails {

    export interface IPrintCustomItemDetails {
        itemDisplayName: string;
        itemId: string;
    }

    export interface IPrintCustomItemListOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails {
        addItem(itemId: string, displayName: string): void;
    }

    export interface IPrintCustomOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        displayName: string;
    }

    export interface IPrintCustomTextOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        maxCharacters: number;
    }

    export interface IPrintItemListOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export interface IPrintNumberOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        maxValue: number;
        minValue: number;
    }

    export interface IPrintOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
    }

    export interface IPrintTaskOptionChangedEventArgs {
        optionId: any;
    }

    export interface IPrintTaskOptionDetails {
        createItemListOption(optionId: string, displayName: string): Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails;
        createTextOption(optionId: string, displayName: string): Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails;
        options: Windows.Foundation.Collections.IMapView<string,Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): void;
        removeEventListener(eventName: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): void;
        onbeginvalidation: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>) => void;
        addEventListener(eventName: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): void;
        removeEventListener(eventName: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): void;
        onoptionchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>) => void;

    }

    export interface IPrintTextOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        maxCharacters: number;
    }

    export class PrintBindingOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintCollationOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintColorModeOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintCopiesOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintNumberOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        maxValue: number;
        minValue: number;
    }

    export class PrintCustomItemDetails implements Windows.Graphics.Printing.OptionDetails.IPrintCustomItemDetails {
        itemDisplayName: string;
        itemId: string;
    }

    export class PrintCustomItemListOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomItemListOptionDetails {
        trySetValue(value: any): boolean;
        addItem(itemId: string, displayName: string): void;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        displayName: string;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintCustomTextOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomTextOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        displayName: string;
        maxCharacters: number;
    }

    export class PrintDuplexOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintHolePunchOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintMediaSizeOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintMediaTypeOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    enum PrintOptionStates {
        none,
        enabled,
        constrained
    }

    enum PrintOptionType {
        unknown,
        number,
        text,
        itemList
    }

    export class PrintOrientationOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintQualityOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintStapleOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintTaskOptionChangedEventArgs implements Windows.Graphics.Printing.OptionDetails.IPrintTaskOptionChangedEventArgs {
        optionId: any;
    }

    export class PrintTaskOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintTaskOptionDetails, Windows.Graphics.Printing.IPrintTaskOptionsCore, Windows.Graphics.Printing.IPrintTaskOptionsCoreUIConfiguration {
        createItemListOption(optionId: string, displayName: string): Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails;
        createTextOption(optionId: string, displayName: string): Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails;
        getPageDescription(jobPageNumber: number): Windows.Graphics.Printing.PrintPageDescription;
        static getFromPrintTaskOptions(printTaskOptions: Windows.Graphics.Printing.PrintTaskOptions): Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails;
        options: Windows.Foundation.Collections.IMapView<string,Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails>;
        displayedOptions: Windows.Foundation.Collections.IVector<string>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): void;
        removeEventListener(eventName: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): void;
        onbeginvalidation: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>) => void;
        addEventListener(eventName: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): void;
        removeEventListener(eventName: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): void;
        onoptionchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>) => void;

    }

}
declare module Windows.Management.Core {

    export class ApplicationDataManager implements Windows.Management.Core.IApplicationDataManager {
        static createForPackageFamily(packageFamilyName: string): Windows.Storage.ApplicationData;
    }

    export interface IApplicationDataManager {
    }

}
declare module Windows.Management.Deployment {

    enum DeploymentOptions {
        none,
        forceApplicationShutdown,
        developmentMode
    }

    export class DeploymentProgress {
        state: Windows.Management.Deployment.DeploymentProgressState;
        percentage: number;
    }

    enum DeploymentProgressState {
        queued,
        processing
    }

    export class DeploymentResult implements Windows.Management.Deployment.IDeploymentResult {
        activityId: string;
        errorText: string;
        extendedErrorCode: Windows.Foundation.HResult;
    }

    export interface IDeploymentResult {
        activityId: string;
        errorText: string;
        extendedErrorCode: Windows.Foundation.HResult;
    }

    export interface IPackageManager {
        addPackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        updatePackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        removePackageAsync(packageFullName: string): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        stagePackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        registerPackageAsync(manifestUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        findPackages(): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackages(packageName: string, packagePublisher: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string, packageName: string, packagePublisher: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findUsers(packageFullName: string): Windows.Foundation.Collections.IIterable<Windows.Management.Deployment.PackageUserInformation>;
        setPackageState(packageFullName: string, packageState: Windows.Management.Deployment.PackageState): void;
        findPackage(packageFullName: string): Windows.ApplicationModel.Package;
        cleanupPackageForUserAsync(packageName: string, userSecurityId: string): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        findPackages(packageFamilyName: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string, packageFamilyName: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackageForUser(userSecurityId: string, packageFullName: string): Windows.ApplicationModel.Package;
    }

    export interface IPackageUserInformation {
        installState: Windows.Management.Deployment.PackageInstallState;
        userSecurityId: string;
    }

    enum PackageInstallState {
        notInstalled,
        staged,
        installed
    }

    export class PackageManager implements Windows.Management.Deployment.IPackageManager {
        constructor();
        addPackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        updatePackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        removePackageAsync(packageFullName: string): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        stagePackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        registerPackageAsync(manifestUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        findPackages(): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackages(packageName: string, packagePublisher: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string, packageName: string, packagePublisher: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findUsers(packageFullName: string): Windows.Foundation.Collections.IIterable<Windows.Management.Deployment.PackageUserInformation>;
        setPackageState(packageFullName: string, packageState: Windows.Management.Deployment.PackageState): void;
        findPackage(packageFullName: string): Windows.ApplicationModel.Package;
        cleanupPackageForUserAsync(packageName: string, userSecurityId: string): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        findPackages(packageFamilyName: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string, packageFamilyName: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackageForUser(userSecurityId: string, packageFullName: string): Windows.ApplicationModel.Package;
    }

    enum PackageState {
        normal,
        licenseInvalid,
        modified,
        tampered
    }

    export class PackageUserInformation implements Windows.Management.Deployment.IPackageUserInformation {
        installState: Windows.Management.Deployment.PackageInstallState;
        userSecurityId: string;
    }

}
declare module Windows.Media.Capture {

    export class CameraCaptureUI implements Windows.Media.Capture.ICameraCaptureUI {
        constructor();
        captureFileAsync(mode: Windows.Media.Capture.CameraCaptureUIMode): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        photoSettings: Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings;
        videoSettings: Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings;
    }

    enum CameraCaptureUIMaxPhotoResolution {
        highestAvailable,
        verySmallQvga,
        smallVga,
        mediumXga,
        large3M,
        veryLarge5M
    }

    enum CameraCaptureUIMaxVideoResolution {
        highestAvailable,
        lowDefinition,
        standardDefinition,
        highDefinition
    }

    enum CameraCaptureUIMode {
        photoOrVideo,
        photo,
        video
    }

    export class CameraCaptureUIPhotoCaptureSettings implements Windows.Media.Capture.ICameraCaptureUIPhotoCaptureSettings {
        allowCropping: boolean;
        croppedAspectRatio: Windows.Foundation.Size;
        croppedSizeInPixels: Windows.Foundation.Size;
        format: Windows.Media.Capture.CameraCaptureUIPhotoFormat;
        maxResolution: Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution;
    }

    enum CameraCaptureUIPhotoFormat {
        jpeg,
        png,
        jpegXR
    }

    export class CameraCaptureUIVideoCaptureSettings implements Windows.Media.Capture.ICameraCaptureUIVideoCaptureSettings {
        allowTrimming: boolean;
        format: Windows.Media.Capture.CameraCaptureUIVideoFormat;
        maxDurationInSeconds: number;
        maxResolution: Windows.Media.Capture.CameraCaptureUIMaxVideoResolution;
    }

    enum CameraCaptureUIVideoFormat {
        mp4,
        wmv
    }

    export class CameraOptionsUI {
        static show(mediaCapture: Windows.Media.Capture.MediaCapture): void;
    }

    export interface ICameraCaptureUI {
        captureFileAsync(mode: Windows.Media.Capture.CameraCaptureUIMode): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        photoSettings: Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings;
        videoSettings: Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings;
    }

    export interface ICameraCaptureUIPhotoCaptureSettings {
        allowCropping: boolean;
        croppedAspectRatio: Windows.Foundation.Size;
        croppedSizeInPixels: Windows.Foundation.Size;
        format: Windows.Media.Capture.CameraCaptureUIPhotoFormat;
        maxResolution: Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution;
    }

    export interface ICameraCaptureUIVideoCaptureSettings {
        allowTrimming: boolean;
        format: Windows.Media.Capture.CameraCaptureUIVideoFormat;
        maxDurationInSeconds: number;
        maxResolution: Windows.Media.Capture.CameraCaptureUIMaxVideoResolution;
    }

    export interface IMediaCapture {
        initializeAsync(): Windows.Foundation.IAsyncAction;
        initializeAsync(mediaCaptureInitializationSettings: Windows.Media.Capture.MediaCaptureInitializationSettings): Windows.Foundation.IAsyncAction;
        startRecordToStorageFileAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        startRecordToStreamAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        startRecordToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension): Windows.Foundation.IAsyncAction;
        startRecordToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        stopRecordAsync(): Windows.Foundation.IAsyncAction;
        capturePhotoToStorageFileAsync(type: Windows.Media.MediaProperties.ImageEncodingProperties, file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        capturePhotoToStreamAsync(type: Windows.Media.MediaProperties.ImageEncodingProperties, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        addEffectAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, effectActivationID: string, effectSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        clearEffectsAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.IAsyncAction;
        setEncoderProperty(mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string, propertyValue: any): void;
        getEncoderProperty(mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string): any;
        setPreviewMirroring(value: boolean): void;
        getPreviewMirroring(): boolean;
        setPreviewRotation(value: Windows.Media.Capture.VideoRotation): void;
        getPreviewRotation(): Windows.Media.Capture.VideoRotation;
        setRecordRotation(value: Windows.Media.Capture.VideoRotation): void;
        getRecordRotation(): Windows.Media.Capture.VideoRotation;
        audioDeviceController: Windows.Media.Devices.AudioDeviceController;
        mediaCaptureSettings: Windows.Media.Capture.MediaCaptureSettings;
        videoDeviceController: Windows.Media.Devices.VideoDeviceController;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler): void;
        removeEventListener(eventName: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler): void;
        onfailed: (ev: Windows.Media.Capture.MediaCaptureFailedEventHandler) => void;
        addEventListener(eventName: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler): void;
        removeEventListener(eventName: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler): void;
        onrecordlimitationexceeded: (ev: Windows.Media.Capture.RecordLimitationExceededEventHandler) => void;

    }

    export interface IMediaCaptureFailedEventArgs {
        code: number;
        message: string;
    }

    export interface IMediaCaptureInitializationSettings {
        audioDeviceId: string;
        photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
        streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
        videoDeviceId: string;
    }

    export interface IMediaCaptureSettings {
        audioDeviceId: string;
        photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
        streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
        videoDeviceCharacteristic: Windows.Media.Capture.VideoDeviceCharacteristic;
        videoDeviceId: string;
    }

    export interface IMediaCaptureVideoPreview {
        startPreviewAsync(): Windows.Foundation.IAsyncAction;
        startPreviewToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension): Windows.Foundation.IAsyncAction;
        startPreviewToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        stopPreviewAsync(): Windows.Foundation.IAsyncAction;
    }

    export class MediaCapture implements Windows.Media.Capture.IMediaCapture, Windows.Media.Capture.IMediaCaptureVideoPreview {
        constructor();
        initializeAsync(): Windows.Foundation.IAsyncAction;
        initializeAsync(mediaCaptureInitializationSettings: Windows.Media.Capture.MediaCaptureInitializationSettings): Windows.Foundation.IAsyncAction;
        startRecordToStorageFileAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        startRecordToStreamAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        startRecordToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension): Windows.Foundation.IAsyncAction;
        startRecordToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        stopRecordAsync(): Windows.Foundation.IAsyncAction;
        capturePhotoToStorageFileAsync(type: Windows.Media.MediaProperties.ImageEncodingProperties, file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        capturePhotoToStreamAsync(type: Windows.Media.MediaProperties.ImageEncodingProperties, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        addEffectAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, effectActivationID: string, effectSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        clearEffectsAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.IAsyncAction;
        setEncoderProperty(mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string, propertyValue: any): void;
        getEncoderProperty(mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string): any;
        setPreviewMirroring(value: boolean): void;
        getPreviewMirroring(): boolean;
        setPreviewRotation(value: Windows.Media.Capture.VideoRotation): void;
        getPreviewRotation(): Windows.Media.Capture.VideoRotation;
        setRecordRotation(value: Windows.Media.Capture.VideoRotation): void;
        getRecordRotation(): Windows.Media.Capture.VideoRotation;
        startPreviewAsync(): Windows.Foundation.IAsyncAction;
        startPreviewToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension): Windows.Foundation.IAsyncAction;
        startPreviewToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        stopPreviewAsync(): Windows.Foundation.IAsyncAction;
        audioDeviceController: Windows.Media.Devices.AudioDeviceController;
        mediaCaptureSettings: Windows.Media.Capture.MediaCaptureSettings;
        videoDeviceController: Windows.Media.Devices.VideoDeviceController;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler): void;
        removeEventListener(eventName: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler): void;
        onfailed: (ev: Windows.Media.Capture.MediaCaptureFailedEventHandler) => void;
        addEventListener(eventName: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler): void;
        removeEventListener(eventName: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler): void;
        onrecordlimitationexceeded: (ev: Windows.Media.Capture.RecordLimitationExceededEventHandler) => void;

    }

    export class MediaCaptureFailedEventArgs implements Windows.Media.Capture.IMediaCaptureFailedEventArgs {
        code: number;
        message: string;
    }

    export interface MediaCaptureFailedEventHandler {
        target: Windows.Media.Capture.MediaCapture;
        detail: any[];
        type: string;
    }

    export class MediaCaptureInitializationSettings implements Windows.Media.Capture.IMediaCaptureInitializationSettings {
        constructor();
        audioDeviceId: string;
        photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
        streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
        videoDeviceId: string;
    }

    export class MediaCaptureSettings implements Windows.Media.Capture.IMediaCaptureSettings {
        audioDeviceId: string;
        photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
        streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
        videoDeviceCharacteristic: Windows.Media.Capture.VideoDeviceCharacteristic;
        videoDeviceId: string;
    }

    enum MediaStreamType {
        videoPreview,
        videoRecord,
        audio,
        photo
    }

    enum PhotoCaptureSource {
        auto,
        videoPreview,
        photo
    }

    enum PowerlineFrequency {
        disabled,
        fiftyHertz,
        sixtyHertz
    }

    export interface RecordLimitationExceededEventHandler {
        target: Windows.Media.Capture.MediaCapture;
        detail: any[];
        type: string;
    }

    enum StreamingCaptureMode {
        audioAndVideo,
        audio,
        video
    }

    enum VideoDeviceCharacteristic {
        allStreamsIndependent,
        previewRecordStreamsIdentical,
        previewPhotoStreamsIdentical,
        recordPhotoStreamsIdentical,
        allStreamsIdentical
    }

    enum VideoRotation {
        none,
        clockwise90Degrees,
        clockwise180Degrees,
        clockwise270Degrees
    }

}
declare module Windows.Media.Devices {

    export class AudioDeviceController implements Windows.Media.Devices.IAudioDeviceController, Windows.Media.Devices.IMediaDeviceController {
        getAvailableMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.Collections.IVectorView<Windows.Media.MediaProperties.IMediaEncodingProperties>;
        getMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Media.MediaProperties.IMediaEncodingProperties;
        setMediaStreamPropertiesAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties): Windows.Foundation.IAsyncAction;
        muted: boolean;
        volumePercent: number;
    }

    enum AudioDeviceRole {
        default,
        communications
    }

    export class CallControl implements Windows.Media.Devices.ICallControl {
        indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;
        indicateNewOutgoingCall(): number;
        indicateActiveCall(callToken: number): void;
        endCall(callToken: number): void;
        static getDefault(): Windows.Media.Devices.CallControl;
        static fromId(deviceInterfaceId: string): Windows.Media.Devices.CallControl;
        hasRinger: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onanswerrequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onaudiotransferrequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler): void;
        removeEventListener(eventName: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler): void;
        ondialrequested: (ev: Windows.Media.Devices.DialRequestedEventHandler) => void;
        addEventListener(eventName: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onhanguprequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler): void;
        removeEventListener(eventName: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler): void;
        onkeypadpressed: (ev: Windows.Media.Devices.KeypadPressedEventHandler) => void;
        addEventListener(eventName: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler): void;
        removeEventListener(eventName: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler): void;
        onredialrequested: (ev: Windows.Media.Devices.RedialRequestedEventHandler) => void;

    }

    export interface CallControlEventHandler {
        target: Windows.Media.Devices.CallControl;
        detail: any[];
        type: string;
    }

    export class DefaultAudioCaptureDeviceChangedEventArgs implements Windows.Media.Devices.IDefaultAudioDeviceChangedEventArgs {
        id: string;
        role: Windows.Media.Devices.AudioDeviceRole;
    }

    export class DefaultAudioRenderDeviceChangedEventArgs implements Windows.Media.Devices.IDefaultAudioDeviceChangedEventArgs {
        id: string;
        role: Windows.Media.Devices.AudioDeviceRole;
    }

    export class DialRequestedEventArgs implements Windows.Media.Devices.IDialRequestedEventArgs {
        handled(): void;
        contact: any;
    }

    export interface DialRequestedEventHandler {
        target: Windows.Media.Devices.CallControl;
        detail: any[];
        type: string;
    }

    export interface IAdvancedVideoCaptureDeviceController {
        setDeviceProperty(propertyId: string, propertyValue: any): void;
        getDeviceProperty(propertyId: string): any;
    }

    export interface IAudioDeviceController extends Windows.Media.Devices.IMediaDeviceController {
        muted: boolean;
        volumePercent: number;
    }

    export interface ICallControl {
        indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;
        indicateNewOutgoingCall(): number;
        indicateActiveCall(callToken: number): void;
        endCall(callToken: number): void;
        hasRinger: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onanswerrequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onaudiotransferrequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler): void;
        removeEventListener(eventName: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler): void;
        ondialrequested: (ev: Windows.Media.Devices.DialRequestedEventHandler) => void;
        addEventListener(eventName: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onhanguprequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler): void;
        removeEventListener(eventName: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler): void;
        onkeypadpressed: (ev: Windows.Media.Devices.KeypadPressedEventHandler) => void;
        addEventListener(eventName: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler): void;
        removeEventListener(eventName: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler): void;
        onredialrequested: (ev: Windows.Media.Devices.RedialRequestedEventHandler) => void;

    }

    export interface IDefaultAudioDeviceChangedEventArgs {
        id: string;
        role: Windows.Media.Devices.AudioDeviceRole;
    }

    export interface IDialRequestedEventArgs {
        handled(): void;
        contact: any;
    }

    export interface IKeypadPressedEventArgs {
        telephonyKey: Windows.Media.Devices.TelephonyKey;
    }

    export interface IMediaDeviceControl {
        tryGetValue(): IMediaDeviceControl_tryGetValue_OUT;
        trySetValue(value: number): boolean;
        tryGetAuto(): IMediaDeviceControl_tryGetAuto_OUT;
        trySetAuto(value: boolean): boolean;
        capabilities: Windows.Media.Devices.MediaDeviceControlCapabilities;
    }

    interface IMediaDeviceControl_tryGetValue_OUT {
        __returnValue: boolean;
        value: number;
    }

    interface IMediaDeviceControl_tryGetAuto_OUT {
        __returnValue: boolean;
        value: boolean;
    }

    export interface IMediaDeviceControlCapabilities {
        autoModeSupported: boolean;
        default: number;
        max: number;
        min: number;
        step: number;
        supported: boolean;
    }

    export interface IMediaDeviceController {
        getAvailableMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.Collections.IVectorView<Windows.Media.MediaProperties.IMediaEncodingProperties>;
        getMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Media.MediaProperties.IMediaEncodingProperties;
        setMediaStreamPropertiesAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties): Windows.Foundation.IAsyncAction;
    }

    export interface IRedialRequestedEventArgs {
        handled(): void;
    }

    export interface IVideoDeviceController extends Windows.Media.Devices.IMediaDeviceController {
        trySetPowerlineFrequency(value: Windows.Media.Capture.PowerlineFrequency): boolean;
        tryGetPowerlineFrequency(): IVideoDeviceController_tryGetPowerlineFrequency_OUT;
        backlightCompensation: Windows.Media.Devices.MediaDeviceControl;
        brightness: Windows.Media.Devices.MediaDeviceControl;
        contrast: Windows.Media.Devices.MediaDeviceControl;
        exposure: Windows.Media.Devices.MediaDeviceControl;
        focus: Windows.Media.Devices.MediaDeviceControl;
        hue: Windows.Media.Devices.MediaDeviceControl;
        pan: Windows.Media.Devices.MediaDeviceControl;
        roll: Windows.Media.Devices.MediaDeviceControl;
        tilt: Windows.Media.Devices.MediaDeviceControl;
        whiteBalance: Windows.Media.Devices.MediaDeviceControl;
        zoom: Windows.Media.Devices.MediaDeviceControl;
    }

    interface IVideoDeviceController_tryGetPowerlineFrequency_OUT {
        __returnValue: boolean;
        value: Windows.Media.Capture.PowerlineFrequency;
    }

    export class KeypadPressedEventArgs implements Windows.Media.Devices.IKeypadPressedEventArgs {
        telephonyKey: Windows.Media.Devices.TelephonyKey;
    }

    export interface KeypadPressedEventHandler {
        target: Windows.Media.Devices.CallControl;
        detail: any[];
        type: string;
    }

    export class MediaDevice {
        static getAudioCaptureSelector(): string;
        static getAudioRenderSelector(): string;
        static getVideoCaptureSelector(): string;
        static getDefaultAudioCaptureId(role: Windows.Media.Devices.AudioDeviceRole): string;
        static getDefaultAudioRenderId(role: Windows.Media.Devices.AudioDeviceRole): string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "defaultaudiocapturedevicechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>): void;
        removeEventListener(eventName: "defaultaudiocapturedevicechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>): void;
        ondefaultaudiocapturedevicechanged: (ev: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>) => void;
        addEventListener(eventName: "defaultaudiorenderdevicechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>): void;
        removeEventListener(eventName: "defaultaudiorenderdevicechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>): void;
        ondefaultaudiorenderdevicechanged: (ev: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>) => void;

    }

    export class MediaDeviceControl implements Windows.Media.Devices.IMediaDeviceControl {
        tryGetValue(): MediaDeviceControl_tryGetValue_OUT;
        trySetValue(value: number): boolean;
        tryGetAuto(): MediaDeviceControl_tryGetAuto_OUT;
        trySetAuto(value: boolean): boolean;
        capabilities: Windows.Media.Devices.MediaDeviceControlCapabilities;
    }

    interface MediaDeviceControl_tryGetValue_OUT {
        __returnValue: boolean;
        value: number;
    }

    interface MediaDeviceControl_tryGetAuto_OUT {
        __returnValue: boolean;
        value: boolean;
    }

    export class MediaDeviceControlCapabilities implements Windows.Media.Devices.IMediaDeviceControlCapabilities {
        autoModeSupported: boolean;
        default: number;
        max: number;
        min: number;
        step: number;
        supported: boolean;
    }

    export class RedialRequestedEventArgs implements Windows.Media.Devices.IRedialRequestedEventArgs {
        handled(): void;
    }

    export interface RedialRequestedEventHandler {
        target: Windows.Media.Devices.CallControl;
        detail: any[];
        type: string;
    }

    enum TelephonyKey {
        d0,
        d1,
        d2,
        d3,
        d4,
        d5,
        d6,
        d7,
        d8,
        d9,
        star,
        pound,
        a,
        b,
        c,
        d
    }

    export class VideoDeviceController implements Windows.Media.Devices.IVideoDeviceController, Windows.Media.Devices.IMediaDeviceController, Windows.Media.Devices.IAdvancedVideoCaptureDeviceController {
        trySetPowerlineFrequency(value: Windows.Media.Capture.PowerlineFrequency): boolean;
        tryGetPowerlineFrequency(): VideoDeviceController_tryGetPowerlineFrequency_OUT;
        getAvailableMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.Collections.IVectorView<Windows.Media.MediaProperties.IMediaEncodingProperties>;
        getMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Media.MediaProperties.IMediaEncodingProperties;
        setMediaStreamPropertiesAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties): Windows.Foundation.IAsyncAction;
        setDeviceProperty(propertyId: string, propertyValue: any): void;
        getDeviceProperty(propertyId: string): any;
        backlightCompensation: Windows.Media.Devices.MediaDeviceControl;
        brightness: Windows.Media.Devices.MediaDeviceControl;
        contrast: Windows.Media.Devices.MediaDeviceControl;
        exposure: Windows.Media.Devices.MediaDeviceControl;
        focus: Windows.Media.Devices.MediaDeviceControl;
        hue: Windows.Media.Devices.MediaDeviceControl;
        pan: Windows.Media.Devices.MediaDeviceControl;
        roll: Windows.Media.Devices.MediaDeviceControl;
        tilt: Windows.Media.Devices.MediaDeviceControl;
        whiteBalance: Windows.Media.Devices.MediaDeviceControl;
        zoom: Windows.Media.Devices.MediaDeviceControl;
    }

    interface VideoDeviceController_tryGetPowerlineFrequency_OUT {
        __returnValue: boolean;
        value: Windows.Media.Capture.PowerlineFrequency;
    }

}
declare module Windows.Media {

    export interface IMediaExtension {
        setProperties(configuration: Windows.Foundation.Collections.IPropertySet): void;
    }

    export interface IMediaExtensionManager {
        registerSchemeHandler(activatableClassId: string, scheme: string): void;
        registerSchemeHandler(activatableClassId: string, scheme: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void;
        registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
    }

    export class MediaControl {
        static albumArt: Windows.Foundation.Uri;
        static artistName: string;
        static isPlaying: boolean;
        static soundLevel: Windows.Media.SoundLevel;
        static trackName: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "channeldownpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "channeldownpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onchanneldownpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "channeluppressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "channeluppressed", listener: Windows.Foundation.EventHandler<any>): void;
        onchanneluppressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "fastforwardpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "fastforwardpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onfastforwardpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "nexttrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "nexttrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onnexttrackpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "pausepressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "pausepressed", listener: Windows.Foundation.EventHandler<any>): void;
        onpausepressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "playpausetogglepressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "playpausetogglepressed", listener: Windows.Foundation.EventHandler<any>): void;
        onplaypausetogglepressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "playpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "playpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onplaypressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "previoustrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "previoustrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onprevioustrackpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "recordpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "recordpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onrecordpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "rewindpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "rewindpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onrewindpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "soundlevelchanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "soundlevelchanged", listener: Windows.Foundation.EventHandler<any>): void;
        onsoundlevelchanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "stoppressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "stoppressed", listener: Windows.Foundation.EventHandler<any>): void;
        onstoppressed: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class MediaExtensionManager implements Windows.Media.IMediaExtensionManager {
        constructor();
        registerSchemeHandler(activatableClassId: string, scheme: string): void;
        registerSchemeHandler(activatableClassId: string, scheme: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void;
        registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
    }

    enum SoundLevel {
        muted,
        low,
        full
    }

    export class VideoEffects {
        static videoStabilization: string;
    }

}
declare module Windows.Media.MediaProperties {

    export class AudioEncodingProperties implements Windows.Media.MediaProperties.IAudioEncodingProperties, Windows.Media.MediaProperties.IMediaEncodingProperties {
        constructor();
        bitrate: number;
        bitsPerSample: number;
        channelCount: number;
        sampleRate: number;
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    enum AudioEncodingQuality {
        auto,
        high,
        medium,
        low
    }

    export class ContainerEncodingProperties implements Windows.Media.MediaProperties.IContainerEncodingProperties, Windows.Media.MediaProperties.IMediaEncodingProperties {
        constructor();
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    export interface IAudioEncodingProperties extends Windows.Media.MediaProperties.IMediaEncodingProperties {
        bitrate: number;
        bitsPerSample: number;
        channelCount: number;
        sampleRate: number;
    }

    export interface IContainerEncodingProperties extends Windows.Media.MediaProperties.IMediaEncodingProperties {
    }

    export interface IImageEncodingProperties extends Windows.Media.MediaProperties.IMediaEncodingProperties {
        height: number;
        width: number;
    }

    export class ImageEncodingProperties implements Windows.Media.MediaProperties.IImageEncodingProperties, Windows.Media.MediaProperties.IMediaEncodingProperties {
        constructor();
        static createJpeg(): Windows.Media.MediaProperties.ImageEncodingProperties;
        static createPng(): Windows.Media.MediaProperties.ImageEncodingProperties;
        static createJpegXR(): Windows.Media.MediaProperties.ImageEncodingProperties;
        height: number;
        width: number;
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    export interface IMediaEncodingProfile {
        audio: Windows.Media.MediaProperties.AudioEncodingProperties;
        container: Windows.Media.MediaProperties.ContainerEncodingProperties;
        video: Windows.Media.MediaProperties.VideoEncodingProperties;
    }

    export interface IMediaEncodingProperties {
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    export interface IMediaRatio {
        denominator: number;
        numerator: number;
    }

    export interface IVideoEncodingProperties extends Windows.Media.MediaProperties.IMediaEncodingProperties {
        bitrate: number;
        frameRate: Windows.Media.MediaProperties.MediaRatio;
        height: number;
        pixelAspectRatio: Windows.Media.MediaProperties.MediaRatio;
        width: number;
    }

    export class MediaEncodingProfile implements Windows.Media.MediaProperties.IMediaEncodingProfile {
        constructor();
        static createM4a(quality: Windows.Media.MediaProperties.AudioEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createMp3(quality: Windows.Media.MediaProperties.AudioEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createWma(quality: Windows.Media.MediaProperties.AudioEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createMp4(quality: Windows.Media.MediaProperties.VideoEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createWmv(quality: Windows.Media.MediaProperties.VideoEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createFromFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Media.MediaProperties.MediaEncodingProfile>;
        static createFromStreamAsync(stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.Media.MediaProperties.MediaEncodingProfile>;
        audio: Windows.Media.MediaProperties.AudioEncodingProperties;
        container: Windows.Media.MediaProperties.ContainerEncodingProperties;
        video: Windows.Media.MediaProperties.VideoEncodingProperties;
    }

    export class MediaPropertySet implements Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
    }

    export class MediaRatio implements Windows.Media.MediaProperties.IMediaRatio {
        denominator: number;
        numerator: number;
    }

    export class VideoEncodingProperties implements Windows.Media.MediaProperties.IVideoEncodingProperties, Windows.Media.MediaProperties.IMediaEncodingProperties {
        constructor();
        bitrate: number;
        frameRate: Windows.Media.MediaProperties.MediaRatio;
        height: number;
        pixelAspectRatio: Windows.Media.MediaProperties.MediaRatio;
        width: number;
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    enum VideoEncodingQuality {
        auto,
        hD1080p,
        hD720p,
        wvga,
        ntsc,
        pal,
        vga,
        qvga
    }

}
declare module Windows.Media.Playlists {

    export interface IPlaylist {
        saveAsync(): Windows.Foundation.IAsyncAction;
        saveAsAsync(saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        saveAsAsync(saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption, playlistFormat: Windows.Media.Playlists.PlaylistFormat): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        files: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFile>;
    }

    export class Playlist implements Windows.Media.Playlists.IPlaylist {
        constructor();
        saveAsync(): Windows.Foundation.IAsyncAction;
        saveAsAsync(saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        saveAsAsync(saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption, playlistFormat: Windows.Media.Playlists.PlaylistFormat): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static loadAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Media.Playlists.Playlist>;
        files: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFile>;
    }

    enum PlaylistFormat {
        windowsMedia,
        zune,
        m3u
    }

}
declare module Windows.Media.PlayTo {

    export class CurrentTimeChangeRequestedEventArgs implements Windows.Media.PlayTo.ICurrentTimeChangeRequestedEventArgs {
        time: Windows.Foundation.TimeSpan;
    }

    export interface ICurrentTimeChangeRequestedEventArgs {
        time: Windows.Foundation.TimeSpan;
    }

    export interface IMuteChangeRequestedEventArgs {
        mute: boolean;
    }

    export interface IPlaybackRateChangeRequestedEventArgs {
        rate: number;
    }

    export interface IPlayToConnection {
        state: Windows.Media.PlayTo.PlayToConnectionState;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): void;
        removeEventListener(eventName: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): void;
        onerror: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>) => void;
        addEventListener(eventName: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): void;
        removeEventListener(eventName: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): void;
        onstatechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>) => void;
        addEventListener(eventName: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): void;
        removeEventListener(eventName: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): void;
        ontransferred: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>) => void;

    }

    export interface IPlayToConnectionErrorEventArgs {
        code: Windows.Media.PlayTo.PlayToConnectionError;
        message: string;
    }

    export interface IPlayToConnectionStateChangedEventArgs {
        currentState: Windows.Media.PlayTo.PlayToConnectionState;
        previousState: Windows.Media.PlayTo.PlayToConnectionState;
    }

    export interface IPlayToConnectionTransferredEventArgs {
        currentSource: Windows.Media.PlayTo.PlayToSource;
        previousSource: Windows.Media.PlayTo.PlayToSource;
    }

    export interface IPlayToManager {
        defaultSourceSelection: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): void;
        removeEventListener(eventName: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): void;
        onsourcerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>) => void;
        addEventListener(eventName: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): void;
        removeEventListener(eventName: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): void;
        onsourceselected: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>) => void;

    }

    export interface IPlayToReceiver {
        notifyVolumeChange(volume: number, mute: boolean): void;
        notifyRateChange(rate: number): void;
        notifyLoadedMetadata(): void;
        notifyTimeUpdate(currentTime: Windows.Foundation.TimeSpan): void;
        notifyDurationChange(duration: Windows.Foundation.TimeSpan): void;
        notifySeeking(): void;
        notifySeeked(): void;
        notifyPaused(): void;
        notifyPlaying(): void;
        notifyEnded(): void;
        notifyError(): void;
        notifyStopped(): void;
        startAsync(): Windows.Foundation.IAsyncAction;
        stopAsync(): Windows.Foundation.IAsyncAction;
        friendlyName: string;
        properties: Windows.Foundation.Collections.IPropertySet;
        supportsAudio: boolean;
        supportsImage: boolean;
        supportsVideo: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): void;
        oncurrenttimechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): void;
        onmutechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onpauserequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onplayrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): void;
        onplaybackratechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): void;
        onsourcechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onstoprequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        ontimeupdaterequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): void;
        onvolumechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>) => void;

    }

    export interface IPlayToSource {
        playNext(): void;
        connection: Windows.Media.PlayTo.PlayToConnection;
        next: Windows.Media.PlayTo.PlayToSource;
    }

    export interface IPlayToSourceDeferral {
        complete(): void;
    }

    export interface IPlayToSourceRequest {
        displayErrorString(errorString: string): void;
        getDeferral(): Windows.Media.PlayTo.PlayToSourceDeferral;
        setSource(value: Windows.Media.PlayTo.PlayToSource): void;
        deadline: Date;
    }

    export interface IPlayToSourceRequestedEventArgs {
        sourceRequest: Windows.Media.PlayTo.PlayToSourceRequest;
    }

    export interface IPlayToSourceSelectedEventArgs {
        friendlyName: string;
        icon: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
        supportsAudio: boolean;
        supportsImage: boolean;
        supportsVideo: boolean;
    }

    export interface ISourceChangeRequestedEventArgs {
        album: string;
        author: string;
        date: Windows.Foundation.IReference<Date>;
        description: string;
        genre: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        rating: Windows.Foundation.IReference<number>;
        stream: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
        title: string;
    }

    export interface IVolumeChangeRequestedEventArgs {
        volume: number;
    }

    export class MuteChangeRequestedEventArgs implements Windows.Media.PlayTo.IMuteChangeRequestedEventArgs {
        mute: boolean;
    }

    export class PlaybackRateChangeRequestedEventArgs implements Windows.Media.PlayTo.IPlaybackRateChangeRequestedEventArgs {
        rate: number;
    }

    export class PlayToConnection implements Windows.Media.PlayTo.IPlayToConnection {
        state: Windows.Media.PlayTo.PlayToConnectionState;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): void;
        removeEventListener(eventName: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): void;
        onerror: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>) => void;
        addEventListener(eventName: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): void;
        removeEventListener(eventName: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): void;
        onstatechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>) => void;
        addEventListener(eventName: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): void;
        removeEventListener(eventName: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): void;
        ontransferred: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>) => void;

    }

    enum PlayToConnectionError {
        none,
        deviceNotResponding,
        deviceError,
        deviceLocked
    }

    export class PlayToConnectionErrorEventArgs implements Windows.Media.PlayTo.IPlayToConnectionErrorEventArgs {
        code: Windows.Media.PlayTo.PlayToConnectionError;
        message: string;
    }

    enum PlayToConnectionState {
        disconnected,
        connected,
        rendering
    }

    export class PlayToConnectionStateChangedEventArgs implements Windows.Media.PlayTo.IPlayToConnectionStateChangedEventArgs {
        currentState: Windows.Media.PlayTo.PlayToConnectionState;
        previousState: Windows.Media.PlayTo.PlayToConnectionState;
    }

    export class PlayToConnectionTransferredEventArgs implements Windows.Media.PlayTo.IPlayToConnectionTransferredEventArgs {
        currentSource: Windows.Media.PlayTo.PlayToSource;
        previousSource: Windows.Media.PlayTo.PlayToSource;
    }

    export class PlayToManager implements Windows.Media.PlayTo.IPlayToManager {
        static getForCurrentView(): Windows.Media.PlayTo.PlayToManager;
        static showPlayToUI(): void;
        defaultSourceSelection: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): void;
        removeEventListener(eventName: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): void;
        onsourcerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>) => void;
        addEventListener(eventName: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): void;
        removeEventListener(eventName: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): void;
        onsourceselected: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>) => void;

    }

    export class PlayToReceiver implements Windows.Media.PlayTo.IPlayToReceiver {
        constructor();
        notifyVolumeChange(volume: number, mute: boolean): void;
        notifyRateChange(rate: number): void;
        notifyLoadedMetadata(): void;
        notifyTimeUpdate(currentTime: Windows.Foundation.TimeSpan): void;
        notifyDurationChange(duration: Windows.Foundation.TimeSpan): void;
        notifySeeking(): void;
        notifySeeked(): void;
        notifyPaused(): void;
        notifyPlaying(): void;
        notifyEnded(): void;
        notifyError(): void;
        notifyStopped(): void;
        startAsync(): Windows.Foundation.IAsyncAction;
        stopAsync(): Windows.Foundation.IAsyncAction;
        friendlyName: string;
        properties: Windows.Foundation.Collections.IPropertySet;
        supportsAudio: boolean;
        supportsImage: boolean;
        supportsVideo: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): void;
        oncurrenttimechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): void;
        onmutechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onpauserequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onplayrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): void;
        onplaybackratechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): void;
        onsourcechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onstoprequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        ontimeupdaterequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): void;
        onvolumechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>) => void;

    }

    export class PlayToSource implements Windows.Media.PlayTo.IPlayToSource {
        playNext(): void;
        connection: Windows.Media.PlayTo.PlayToConnection;
        next: Windows.Media.PlayTo.PlayToSource;
    }

    export class PlayToSourceDeferral implements Windows.Media.PlayTo.IPlayToSourceDeferral {
        complete(): void;
    }

    export class PlayToSourceRequest implements Windows.Media.PlayTo.IPlayToSourceRequest {
        displayErrorString(errorString: string): void;
        getDeferral(): Windows.Media.PlayTo.PlayToSourceDeferral;
        setSource(value: Windows.Media.PlayTo.PlayToSource): void;
        deadline: Date;
    }

    export class PlayToSourceRequestedEventArgs implements Windows.Media.PlayTo.IPlayToSourceRequestedEventArgs {
        sourceRequest: Windows.Media.PlayTo.PlayToSourceRequest;
    }

    export class PlayToSourceSelectedEventArgs implements Windows.Media.PlayTo.IPlayToSourceSelectedEventArgs {
        friendlyName: string;
        icon: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
        supportsAudio: boolean;
        supportsImage: boolean;
        supportsVideo: boolean;
    }

    export class SourceChangeRequestedEventArgs implements Windows.Media.PlayTo.ISourceChangeRequestedEventArgs {
        album: string;
        author: string;
        date: Windows.Foundation.IReference<Date>;
        description: string;
        genre: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        rating: Windows.Foundation.IReference<number>;
        stream: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
        title: string;
    }

    export class VolumeChangeRequestedEventArgs implements Windows.Media.PlayTo.IVolumeChangeRequestedEventArgs {
        volume: number;
    }

}
declare module Windows.Media.Protection {

    export class ComponentLoadFailedEventArgs implements Windows.Media.Protection.IComponentLoadFailedEventArgs {
        completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
        information: Windows.Media.Protection.RevocationAndRenewalInformation;
    }

    export interface ComponentLoadFailedEventHandler {
        target: Windows.Media.Protection.MediaProtectionManager;
        detail: any[];
        type: string;
    }

    export class ComponentRenewal {
        static renewSystemComponentsAsync(information: Windows.Media.Protection.RevocationAndRenewalInformation): Windows.Foundation.IAsyncOperationWithProgress<Windows.Media.Protection.RenewalStatus,number>;
    }

    export interface IComponentLoadFailedEventArgs {
        completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
        information: Windows.Media.Protection.RevocationAndRenewalInformation;
    }

    export interface IMediaProtectionManager {
        properties: Windows.Foundation.Collections.IPropertySet;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler): void;
        removeEventListener(eventName: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler): void;
        oncomponentloadfailed: (ev: Windows.Media.Protection.ComponentLoadFailedEventHandler) => void;
        addEventListener(eventName: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler): void;
        removeEventListener(eventName: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler): void;
        onrebootneeded: (ev: Windows.Media.Protection.RebootNeededEventHandler) => void;
        addEventListener(eventName: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler): void;
        removeEventListener(eventName: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler): void;
        onservicerequested: (ev: Windows.Media.Protection.ServiceRequestedEventHandler) => void;

    }

    export interface IMediaProtectionServiceCompletion {
        complete(success: boolean): void;
    }

    export interface IMediaProtectionServiceRequest {
        protectionSystem: string;
        type: string;
    }

    export interface IRevocationAndRenewalInformation {
        items: Windows.Foundation.Collections.IVector<Windows.Media.Protection.RevocationAndRenewalItem>;
    }

    export interface IRevocationAndRenewalItem {
        headerHash: string;
        name: string;
        publicKeyHash: string;
        reasons: Windows.Media.Protection.RevocationAndRenewalReasons;
        renewalId: string;
    }

    export interface IServiceRequestedEventArgs {
        completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
        request: Windows.Media.Protection.IMediaProtectionServiceRequest;
    }

    export class MediaProtectionManager implements Windows.Media.Protection.IMediaProtectionManager {
        constructor();
        properties: Windows.Foundation.Collections.IPropertySet;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler): void;
        removeEventListener(eventName: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler): void;
        oncomponentloadfailed: (ev: Windows.Media.Protection.ComponentLoadFailedEventHandler) => void;
        addEventListener(eventName: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler): void;
        removeEventListener(eventName: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler): void;
        onrebootneeded: (ev: Windows.Media.Protection.RebootNeededEventHandler) => void;
        addEventListener(eventName: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler): void;
        removeEventListener(eventName: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler): void;
        onservicerequested: (ev: Windows.Media.Protection.ServiceRequestedEventHandler) => void;

    }

    export class MediaProtectionServiceCompletion implements Windows.Media.Protection.IMediaProtectionServiceCompletion {
        complete(success: boolean): void;
    }

    export interface RebootNeededEventHandler {
        target: Windows.Media.Protection.MediaProtectionManager;
        detail: any[];
        type: string;
    }

    enum RenewalStatus {
        notStarted,
        updatesInProgress,
        userCancelled,
        appComponentsMayNeedUpdating,
        noComponentsFound
    }

    export class RevocationAndRenewalInformation implements Windows.Media.Protection.IRevocationAndRenewalInformation {
        items: Windows.Foundation.Collections.IVector<Windows.Media.Protection.RevocationAndRenewalItem>;
    }

    export class RevocationAndRenewalItem implements Windows.Media.Protection.IRevocationAndRenewalItem {
        headerHash: string;
        name: string;
        publicKeyHash: string;
        reasons: Windows.Media.Protection.RevocationAndRenewalReasons;
        renewalId: string;
    }

    enum RevocationAndRenewalReasons {
        userModeComponentLoad,
        kernelModeComponentLoad,
        appComponent,
        globalRevocationListLoadFailed,
        invalidGlobalRevocationListSignature,
        globalRevocationListAbsent,
        componentRevoked,
        invalidComponentCertificateExtendedKeyUse,
        componentCertificateRevoked,
        invalidComponentCertificateRoot,
        componentHighSecurityCertificateRevoked,
        componentLowSecurityCertificateRevoked,
        bootDriverVerificationFailed,
        componentSignedWithTestCertificate,
        encryptionFailure
    }

    export class ServiceRequestedEventArgs implements Windows.Media.Protection.IServiceRequestedEventArgs {
        completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
        request: Windows.Media.Protection.IMediaProtectionServiceRequest;
    }

    export interface ServiceRequestedEventHandler {
        target: Windows.Media.Protection.MediaProtectionManager;
        detail: any[];
        type: string;
    }

}
declare module Windows.Media.Transcoding {

    export interface IMediaTranscoder {
        addAudioEffect(activatableClassId: string): void;
        addAudioEffect(activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet): void;
        addVideoEffect(activatableClassId: string): void;
        addVideoEffect(activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet): void;
        clearEffects(): void;
        prepareFileTranscodeAsync(source: Windows.Storage.IStorageFile, destination: Windows.Storage.IStorageFile, profile: Windows.Media.MediaProperties.MediaEncodingProfile): Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
        prepareStreamTranscodeAsync(source: Windows.Storage.Streams.IRandomAccessStream, destination: Windows.Storage.Streams.IRandomAccessStream, profile: Windows.Media.MediaProperties.MediaEncodingProfile): Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
        alwaysReencode: boolean;
        hardwareAccelerationEnabled: boolean;
        trimStartTime: Windows.Foundation.TimeSpan;
        trimStopTime: Windows.Foundation.TimeSpan;
    }

    export interface IPrepareTranscodeResult {
        transcodeAsync(): Windows.Foundation.IAsyncActionWithProgress<number>;
        canTranscode: boolean;
        failureReason: Windows.Media.Transcoding.TranscodeFailureReason;
    }

    export class MediaTranscoder implements Windows.Media.Transcoding.IMediaTranscoder {
        constructor();
        addAudioEffect(activatableClassId: string): void;
        addAudioEffect(activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet): void;
        addVideoEffect(activatableClassId: string): void;
        addVideoEffect(activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet): void;
        clearEffects(): void;
        prepareFileTranscodeAsync(source: Windows.Storage.IStorageFile, destination: Windows.Storage.IStorageFile, profile: Windows.Media.MediaProperties.MediaEncodingProfile): Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
        prepareStreamTranscodeAsync(source: Windows.Storage.Streams.IRandomAccessStream, destination: Windows.Storage.Streams.IRandomAccessStream, profile: Windows.Media.MediaProperties.MediaEncodingProfile): Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
        alwaysReencode: boolean;
        hardwareAccelerationEnabled: boolean;
        trimStartTime: Windows.Foundation.TimeSpan;
        trimStopTime: Windows.Foundation.TimeSpan;
    }

    export class PrepareTranscodeResult implements Windows.Media.Transcoding.IPrepareTranscodeResult {
        transcodeAsync(): Windows.Foundation.IAsyncActionWithProgress<number>;
        canTranscode: boolean;
        failureReason: Windows.Media.Transcoding.TranscodeFailureReason;
    }

    enum TranscodeFailureReason {
        none,
        unknown,
        invalidProfile,
        codecNotFound
    }

}
declare module Windows.Networking.BackgroundTransfer {

    export class BackgroundDownloader implements Windows.Networking.BackgroundTransfer.IBackgroundDownloader, Windows.Networking.BackgroundTransfer.IBackgroundTransferBase {
        constructor();
        createDownload(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.DownloadOperation;
        createDownload(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.DownloadOperation;
        createDownloadAsync(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.DownloadOperation>;
        setRequestHeader(headerName: string, headerValue: string): void;
        static getCurrentDownloadsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.DownloadOperation>>;
        static getCurrentDownloadsAsync(group: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.DownloadOperation>>;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        method: string;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
    }

    export class BackgroundDownloadProgress {
        bytesReceived: number;
        totalBytesToReceive: number;
        status: Windows.Networking.BackgroundTransfer.BackgroundTransferStatus;
        hasResponseChanged: boolean;
        hasRestarted: boolean;
    }

    export class BackgroundTransferContentPart implements Windows.Networking.BackgroundTransfer.IBackgroundTransferContentPart {
        constructor(name: string);
        constructor(name: string, fileName: string);
        constructor();
        setHeader(headerName: string, headerValue: string): void;
        setText(value: string): void;
        setFile(value: Windows.Storage.IStorageFile): void;
    }

    enum BackgroundTransferCostPolicy {
        default,
        unrestrictedOnly,
        always
    }

    export class BackgroundTransferError {
        static getStatus(hresult: number): Windows.Web.WebErrorStatus;
    }

    enum BackgroundTransferStatus {
        idle,
        running,
        pausedByApplication,
        pausedCostedNetwork,
        pausedNoNetwork,
        completed,
        canceled,
        error
    }

    export class BackgroundUploader implements Windows.Networking.BackgroundTransfer.IBackgroundUploader, Windows.Networking.BackgroundTransfer.IBackgroundTransferBase {
        constructor();
        createUpload(uri: Windows.Foundation.Uri, sourceFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.UploadOperation;
        createUploadFromStreamAsync(uri: Windows.Foundation.Uri, sourceStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string, boundary: string): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        setRequestHeader(headerName: string, headerValue: string): void;
        static getCurrentUploadsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.UploadOperation>>;
        static getCurrentUploadsAsync(group: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.UploadOperation>>;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        method: string;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
    }

    export class BackgroundUploadProgress {
        bytesReceived: number;
        bytesSent: number;
        totalBytesToReceive: number;
        totalBytesToSend: number;
        status: Windows.Networking.BackgroundTransfer.BackgroundTransferStatus;
        hasResponseChanged: boolean;
        hasRestarted: boolean;
    }

    export class DownloadOperation implements Windows.Networking.BackgroundTransfer.IDownloadOperation, Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation {
        startAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation,Windows.Networking.BackgroundTransfer.DownloadOperation>;
        attachAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation,Windows.Networking.BackgroundTransfer.DownloadOperation>;
        pause(): void;
        resume(): void;
        getResultStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getResponseInformation(): Windows.Networking.BackgroundTransfer.ResponseInformation;
        progress: Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress;
        resultFile: Windows.Storage.IStorageFile;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        guid: string;
        method: string;
        requestedUri: Windows.Foundation.Uri;
    }

    export interface IBackgroundDownloader extends Windows.Networking.BackgroundTransfer.IBackgroundTransferBase {
        createDownload(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.DownloadOperation;
        createDownload(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.DownloadOperation;
        createDownloadAsync(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.DownloadOperation>;
    }

    export interface IBackgroundTransferBase {
        setRequestHeader(headerName: string, headerValue: string): void;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        method: string;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
    }

    export interface IBackgroundTransferContentPart {
        setHeader(headerName: string, headerValue: string): void;
        setText(value: string): void;
        setFile(value: Windows.Storage.IStorageFile): void;
    }

    export interface IBackgroundTransferContentPartFactory {
        createWithName(name: string): Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart;
        createWithNameAndFileName(name: string, fileName: string): Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart;
    }

    export interface IBackgroundTransferOperation {
        getResultStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getResponseInformation(): Windows.Networking.BackgroundTransfer.ResponseInformation;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        guid: string;
        method: string;
        requestedUri: Windows.Foundation.Uri;
    }

    export interface IBackgroundUploader extends Windows.Networking.BackgroundTransfer.IBackgroundTransferBase {
        createUpload(uri: Windows.Foundation.Uri, sourceFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.UploadOperation;
        createUploadFromStreamAsync(uri: Windows.Foundation.Uri, sourceStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string, boundary: string): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
    }

    export interface IDownloadOperation extends Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation {
        startAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation,Windows.Networking.BackgroundTransfer.DownloadOperation>;
        attachAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation,Windows.Networking.BackgroundTransfer.DownloadOperation>;
        pause(): void;
        resume(): void;
        progress: Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress;
        resultFile: Windows.Storage.IStorageFile;
    }

    export interface IResponseInformation {
        actualUri: Windows.Foundation.Uri;
        headers: Windows.Foundation.Collections.IMapView<string,string>;
        isResumable: boolean;
        statusCode: number;
    }

    export interface IUploadOperation extends Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation {
        startAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation,Windows.Networking.BackgroundTransfer.UploadOperation>;
        attachAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation,Windows.Networking.BackgroundTransfer.UploadOperation>;
        progress: Windows.Networking.BackgroundTransfer.BackgroundUploadProgress;
        sourceFile: Windows.Storage.IStorageFile;
    }

    export class ResponseInformation implements Windows.Networking.BackgroundTransfer.IResponseInformation {
        actualUri: Windows.Foundation.Uri;
        headers: Windows.Foundation.Collections.IMapView<string,string>;
        isResumable: boolean;
        statusCode: number;
    }

    export class UploadOperation implements Windows.Networking.BackgroundTransfer.IUploadOperation, Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation {
        startAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation,Windows.Networking.BackgroundTransfer.UploadOperation>;
        attachAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation,Windows.Networking.BackgroundTransfer.UploadOperation>;
        getResultStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getResponseInformation(): Windows.Networking.BackgroundTransfer.ResponseInformation;
        progress: Windows.Networking.BackgroundTransfer.BackgroundUploadProgress;
        sourceFile: Windows.Storage.IStorageFile;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        guid: string;
        method: string;
        requestedUri: Windows.Foundation.Uri;
    }

}
declare module Windows.Networking.Connectivity {

    export class ConnectionCost implements Windows.Networking.Connectivity.IConnectionCost {
        approachingDataLimit: boolean;
        networkCostType: Windows.Networking.Connectivity.NetworkCostType;
        overDataLimit: boolean;
        roaming: boolean;
    }

    export class ConnectionProfile implements Windows.Networking.Connectivity.IConnectionProfile {
        getNetworkConnectivityLevel(): Windows.Networking.Connectivity.NetworkConnectivityLevel;
        getNetworkNames(): Windows.Foundation.Collections.IVectorView<string>;
        getConnectionCost(): Windows.Networking.Connectivity.ConnectionCost;
        getDataPlanStatus(): Windows.Networking.Connectivity.DataPlanStatus;
        getLocalUsage(StartTime: Date, EndTime: Date): Windows.Networking.Connectivity.DataUsage;
        getLocalUsage(StartTime: Date, EndTime: Date, States: Windows.Networking.Connectivity.RoamingStates): Windows.Networking.Connectivity.DataUsage;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        networkSecuritySettings: Windows.Networking.Connectivity.NetworkSecuritySettings;
        profileName: string;
    }

    export class DataPlanStatus implements Windows.Networking.Connectivity.IDataPlanStatus {
        dataLimitInMegabytes: Windows.Foundation.IReference<number>;
        dataPlanUsage: Windows.Networking.Connectivity.DataPlanUsage;
        inboundBitsPerSecond: Windows.Foundation.IReference<number>;
        maxTransferSizeInMegabytes: Windows.Foundation.IReference<number>;
        nextBillingCycle: Windows.Foundation.IReference<Date>;
        outboundBitsPerSecond: Windows.Foundation.IReference<number>;
    }

    export class DataPlanUsage implements Windows.Networking.Connectivity.IDataPlanUsage {
        lastSyncTime: Date;
        megabytesUsed: number;
    }

    export class DataUsage implements Windows.Networking.Connectivity.IDataUsage {
        bytesReceived: number;
        bytesSent: number;
    }

    export interface IConnectionCost {
        approachingDataLimit: boolean;
        networkCostType: Windows.Networking.Connectivity.NetworkCostType;
        overDataLimit: boolean;
        roaming: boolean;
    }

    export interface IConnectionProfile {
        getNetworkConnectivityLevel(): Windows.Networking.Connectivity.NetworkConnectivityLevel;
        getNetworkNames(): Windows.Foundation.Collections.IVectorView<string>;
        getConnectionCost(): Windows.Networking.Connectivity.ConnectionCost;
        getDataPlanStatus(): Windows.Networking.Connectivity.DataPlanStatus;
        getLocalUsage(StartTime: Date, EndTime: Date): Windows.Networking.Connectivity.DataUsage;
        getLocalUsage(StartTime: Date, EndTime: Date, States: Windows.Networking.Connectivity.RoamingStates): Windows.Networking.Connectivity.DataUsage;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        networkSecuritySettings: Windows.Networking.Connectivity.NetworkSecuritySettings;
        profileName: string;
    }

    export interface IDataPlanStatus {
        dataLimitInMegabytes: Windows.Foundation.IReference<number>;
        dataPlanUsage: Windows.Networking.Connectivity.DataPlanUsage;
        inboundBitsPerSecond: Windows.Foundation.IReference<number>;
        maxTransferSizeInMegabytes: Windows.Foundation.IReference<number>;
        nextBillingCycle: Windows.Foundation.IReference<Date>;
        outboundBitsPerSecond: Windows.Foundation.IReference<number>;
    }

    export interface IDataPlanUsage {
        lastSyncTime: Date;
        megabytesUsed: number;
    }

    export interface IDataUsage {
        bytesReceived: number;
        bytesSent: number;
    }

    export interface IIPInformation {
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        prefixLength: Windows.Foundation.IReference<number>;
    }

    export interface ILanIdentifier {
        infrastructureId: Windows.Networking.Connectivity.LanIdentifierData;
        networkAdapterId: string;
        portId: Windows.Networking.Connectivity.LanIdentifierData;
    }

    export interface ILanIdentifierData {
        type: number;
        value: Windows.Foundation.Collections.IVectorView<number>;
    }

    export interface INetworkAdapter {
        getConnectedProfileAsync(): Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ConnectionProfile>;
        ianaInterfaceType: number;
        inboundMaxBitsPerSecond: number;
        networkAdapterId: string;
        networkItem: Windows.Networking.Connectivity.NetworkItem;
        outboundMaxBitsPerSecond: number;
    }

    export interface INetworkItem {
        getNetworkTypes(): Windows.Networking.Connectivity.NetworkTypes;
        networkId: string;
    }

    export interface INetworkSecuritySettings {
        networkAuthenticationType: Windows.Networking.Connectivity.NetworkAuthenticationType;
        networkEncryptionType: Windows.Networking.Connectivity.NetworkEncryptionType;
    }

    export class IPInformation implements Windows.Networking.Connectivity.IIPInformation {
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        prefixLength: Windows.Foundation.IReference<number>;
    }

    export interface IProxyConfiguration {
        canConnectDirectly: boolean;
        proxyUris: Windows.Foundation.Collections.IVectorView<Windows.Foundation.Uri>;
    }

    export class LanIdentifier implements Windows.Networking.Connectivity.ILanIdentifier {
        infrastructureId: Windows.Networking.Connectivity.LanIdentifierData;
        networkAdapterId: string;
        portId: Windows.Networking.Connectivity.LanIdentifierData;
    }

    export class LanIdentifierData implements Windows.Networking.Connectivity.ILanIdentifierData {
        type: number;
        value: Windows.Foundation.Collections.IVectorView<number>;
    }

    export class NetworkAdapter implements Windows.Networking.Connectivity.INetworkAdapter {
        getConnectedProfileAsync(): Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ConnectionProfile>;
        ianaInterfaceType: number;
        inboundMaxBitsPerSecond: number;
        networkAdapterId: string;
        networkItem: Windows.Networking.Connectivity.NetworkItem;
        outboundMaxBitsPerSecond: number;
    }

    enum NetworkAuthenticationType {
        none,
        unknown,
        open80211,
        sharedKey80211,
        wpa,
        wpaPsk,
        wpaNone,
        rsna,
        rsnaPsk,
        ihv
    }

    enum NetworkConnectivityLevel {
        none,
        localAccess,
        constrainedInternetAccess,
        internetAccess
    }

    enum NetworkCostType {
        unknown,
        unrestricted,
        fixed,
        variable
    }

    enum NetworkEncryptionType {
        none,
        unknown,
        wep,
        wep40,
        wep104,
        tkip,
        ccmp,
        wpaUseGroup,
        rsnUseGroup,
        ihv
    }

    export class NetworkInformation {
        static getConnectionProfiles(): Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.ConnectionProfile>;
        static getInternetConnectionProfile(): Windows.Networking.Connectivity.ConnectionProfile;
        static getLanIdentifiers(): Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.LanIdentifier>;
        static getHostNames(): Windows.Foundation.Collections.IVectorView<Windows.Networking.HostName>;
        static getProxyConfigurationAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ProxyConfiguration>;
        static getSortedEndpointPairs(destinationList: Windows.Foundation.Collections.IIterable<Windows.Networking.EndpointPair>, sortOptions: Windows.Networking.HostNameSortOptions): Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "networkstatuschanged", listener: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler): void;
        removeEventListener(eventName: "networkstatuschanged", listener: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler): void;
        onnetworkstatuschanged: (ev: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler) => void;

    }

    export class NetworkItem implements Windows.Networking.Connectivity.INetworkItem {
        getNetworkTypes(): Windows.Networking.Connectivity.NetworkTypes;
        networkId: string;
    }

    export class NetworkSecuritySettings implements Windows.Networking.Connectivity.INetworkSecuritySettings {
        networkAuthenticationType: Windows.Networking.Connectivity.NetworkAuthenticationType;
        networkEncryptionType: Windows.Networking.Connectivity.NetworkEncryptionType;
    }

    export interface NetworkStatusChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum NetworkTypes {
        none,
        internet,
        privateNetwork
    }

    export class ProxyConfiguration implements Windows.Networking.Connectivity.IProxyConfiguration {
        canConnectDirectly: boolean;
        proxyUris: Windows.Foundation.Collections.IVectorView<Windows.Foundation.Uri>;
    }

    enum RoamingStates {
        none,
        notRoaming,
        roaming
    }

}
declare module Windows.Networking {

    export class EndpointPair implements Windows.Networking.IEndpointPair {
        constructor(localHostName: Windows.Networking.HostName, localServiceName: string, remoteHostName: Windows.Networking.HostName, remoteServiceName: string);
        localHostName: Windows.Networking.HostName;
        localServiceName: string;
        remoteHostName: Windows.Networking.HostName;
        remoteServiceName: string;
    }

    export class HostName implements Windows.Networking.IHostName {
        constructor(hostName: string);
        isEqual(hostName: Windows.Networking.HostName): boolean;
        static compare(value1: string, value2: string): number;
        canonicalName: string;
        displayName: string;
        iPInformation: Windows.Networking.Connectivity.IPInformation;
        rawName: string;
        type: Windows.Networking.HostNameType;
    }

    enum HostNameSortOptions {
        none,
        optimizeForLongConnections
    }

    enum HostNameType {
        domainName,
        ipv4,
        ipv6,
        bluetooth
    }

    export interface IEndpointPair {
        localHostName: Windows.Networking.HostName;
        localServiceName: string;
        remoteHostName: Windows.Networking.HostName;
        remoteServiceName: string;
    }

    export interface IHostName {
        isEqual(hostName: Windows.Networking.HostName): boolean;
        canonicalName: string;
        displayName: string;
        iPInformation: Windows.Networking.Connectivity.IPInformation;
        rawName: string;
        type: Windows.Networking.HostNameType;
    }

}
declare module Windows.Networking.NetworkOperators {

    enum DataClasses {
        none,
        gprs,
        edge,
        umts,
        hsdpa,
        hsupa,
        lteAdvanced,
        cdma1xRtt,
        cdma1xEvdo,
        cdma1xEvdoRevA,
        cdma1xEvdv,
        cdma3xRtt,
        cdma1xEvdoRevB,
        cdmaUmb,
        custom
    }

    export class HotspotAuthenticationContext implements Windows.Networking.NetworkOperators.IHotspotAuthenticationContext {
        issueCredentials(userName: string, password: string, extraParameters: string, markAsManualConnectOnFailure: boolean): void;
        abortAuthentication(markAsManual: boolean): void;
        skipAuthentication(): void;
        triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void;
        static tryGetAuthenticationContext(evenToken: string): HotspotAuthenticationContext_tryGetAuthenticationContext_OUT;
        authenticationUrl: Windows.Foundation.Uri;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        redirectMessageUrl: Windows.Foundation.Uri;
        redirectMessageXml: Windows.Data.Xml.Dom.XmlDocument;
        wirelessNetworkId: any;
    }

    interface HotspotAuthenticationContext_tryGetAuthenticationContext_OUT {
        __returnValue: boolean;
        context: Windows.Networking.NetworkOperators.HotspotAuthenticationContext;
    }

    export class HotspotAuthenticationEventDetails implements Windows.Networking.NetworkOperators.IHotspotAuthenticationEventDetails {
        eventToken: string;
    }

    export interface IHotspotAuthenticationContext {
        issueCredentials(userName: string, password: string, extraParameters: string, markAsManualConnectOnFailure: boolean): void;
        abortAuthentication(markAsManual: boolean): void;
        skipAuthentication(): void;
        triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void;
        authenticationUrl: Windows.Foundation.Uri;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        redirectMessageUrl: Windows.Foundation.Uri;
        redirectMessageXml: Windows.Data.Xml.Dom.XmlDocument;
        wirelessNetworkId: any;
    }

    export interface IHotspotAuthenticationEventDetails {
        eventToken: string;
    }

    export interface IMobileBroadbandAccount {
        currentDeviceInformation: Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation;
        currentNetwork: Windows.Networking.NetworkOperators.MobileBroadbandNetwork;
        networkAccountId: string;
        serviceProviderGuid: string;
        serviceProviderName: string;
    }

    export interface IMobileBroadbandAccountEventArgs {
        networkAccountId: string;
    }

    export interface IMobileBroadbandAccountUpdatedEventArgs {
        hasDeviceInformationChanged: boolean;
        hasNetworkChanged: boolean;
        networkAccountId: string;
    }

    export interface IMobileBroadbandAccountWatcher {
        start(): void;
        stop(): void;
        status: Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        removeEventListener(eventName: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        onaccountadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>) => void;
        addEventListener(eventName: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        removeEventListener(eventName: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        onaccountremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>) => void;
        addEventListener(eventName: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): void;
        removeEventListener(eventName: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): void;
        onaccountupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>) => void;

    }

    export interface IMobileBroadbandDeviceInformation {
        cellularClass: Windows.Devices.Sms.CellularClass;
        currentRadioState: Windows.Networking.NetworkOperators.MobileBroadbandRadioState;
        customDataClass: string;
        dataClasses: Windows.Networking.NetworkOperators.DataClasses;
        deviceId: string;
        deviceType: Windows.Networking.NetworkOperators.MobileBroadbandDeviceType;
        firmwareInformation: string;
        manufacturer: string;
        mobileEquipmentId: string;
        model: string;
        networkDeviceStatus: Windows.Networking.NetworkOperators.NetworkDeviceStatus;
        simIccId: string;
        subscriberId: string;
        telephoneNumbers: Windows.Foundation.Collections.IVectorView<string>;
    }

    export interface IMobileBroadbandNetwork {
        showConnectionUI(): void;
        accessPointName: string;
        activationNetworkError: number;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        networkRegistrationState: Windows.Networking.NetworkOperators.NetworkRegistrationState;
        packetAttachNetworkError: number;
        registeredDataClass: Windows.Networking.NetworkOperators.DataClasses;
        registeredProviderId: string;
        registeredProviderName: string;
        registrationNetworkError: number;
    }

    export interface INetworkOperatorNotificationEventDetails {
        encodingType: number;
        message: string;
        networkAccountId: string;
        notificationType: Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType;
        ruleId: string;
        smsMessage: Windows.Devices.Sms.ISmsMessage;
    }

    export interface IProvisionedProfile {
        updateCost(value: Windows.Networking.Connectivity.NetworkCostType): void;
        updateUsage(value: Windows.Networking.NetworkOperators.ProfileUsage): void;
    }

    export interface IProvisionFromXmlDocumentResults {
        allElementsProvisioned: boolean;
        provisionResultsXml: string;
    }

    export interface IProvisioningAgent {
        provisionFromXmlDocumentAsync(provisioningXmlDocument: string): Windows.Foundation.IAsyncOperation<Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults>;
        getProvisionedProfile(mediaType: Windows.Networking.NetworkOperators.ProfileMediaType, profileName: string): Windows.Networking.NetworkOperators.ProvisionedProfile;
    }

    export interface IUssdMessage {
        getPayload(): any;
        setPayload(value: any): void;
        dataCodingScheme: number;
        payloadAsText: string;
    }

    export interface IUssdReply {
        message: Windows.Networking.NetworkOperators.UssdMessage;
        resultCode: Windows.Networking.NetworkOperators.UssdResultCode;
    }

    export interface IUssdSession {
        sendMessageAndGetReplyAsync(message: Windows.Networking.NetworkOperators.UssdMessage): Windows.Foundation.IAsyncOperation<Windows.Networking.NetworkOperators.UssdReply>;
        close(): void;
    }

    export class MobileBroadbandAccount implements Windows.Networking.NetworkOperators.IMobileBroadbandAccount {
        static createFromNetworkAccountId(networkAccountId: string): Windows.Networking.NetworkOperators.MobileBroadbandAccount;
        currentDeviceInformation: Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation;
        currentNetwork: Windows.Networking.NetworkOperators.MobileBroadbandNetwork;
        networkAccountId: string;
        serviceProviderGuid: string;
        serviceProviderName: string;
        static availableNetworkAccountIds: Windows.Foundation.Collections.IVectorView<string>;
    }

    export class MobileBroadbandAccountEventArgs implements Windows.Networking.NetworkOperators.IMobileBroadbandAccountEventArgs {
        networkAccountId: string;
    }

    export class MobileBroadbandAccountUpdatedEventArgs implements Windows.Networking.NetworkOperators.IMobileBroadbandAccountUpdatedEventArgs {
        hasDeviceInformationChanged: boolean;
        hasNetworkChanged: boolean;
        networkAccountId: string;
    }

    export class MobileBroadbandAccountWatcher implements Windows.Networking.NetworkOperators.IMobileBroadbandAccountWatcher {
        constructor();
        start(): void;
        stop(): void;
        status: Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        removeEventListener(eventName: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        onaccountadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>) => void;
        addEventListener(eventName: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        removeEventListener(eventName: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        onaccountremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>) => void;
        addEventListener(eventName: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): void;
        removeEventListener(eventName: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): void;
        onaccountupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>) => void;

    }

    enum MobileBroadbandAccountWatcherStatus {
        created,
        started,
        enumerationCompleted,
        stopped,
        aborted
    }

    export class MobileBroadbandDeviceInformation implements Windows.Networking.NetworkOperators.IMobileBroadbandDeviceInformation {
        cellularClass: Windows.Devices.Sms.CellularClass;
        currentRadioState: Windows.Networking.NetworkOperators.MobileBroadbandRadioState;
        customDataClass: string;
        dataClasses: Windows.Networking.NetworkOperators.DataClasses;
        deviceId: string;
        deviceType: Windows.Networking.NetworkOperators.MobileBroadbandDeviceType;
        firmwareInformation: string;
        manufacturer: string;
        mobileEquipmentId: string;
        model: string;
        networkDeviceStatus: Windows.Networking.NetworkOperators.NetworkDeviceStatus;
        simIccId: string;
        subscriberId: string;
        telephoneNumbers: Windows.Foundation.Collections.IVectorView<string>;
    }

    enum MobileBroadbandDeviceType {
        unknown,
        embedded,
        removable,
        remote
    }

    export class MobileBroadbandNetwork implements Windows.Networking.NetworkOperators.IMobileBroadbandNetwork {
        showConnectionUI(): void;
        accessPointName: string;
        activationNetworkError: number;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        networkRegistrationState: Windows.Networking.NetworkOperators.NetworkRegistrationState;
        packetAttachNetworkError: number;
        registeredDataClass: Windows.Networking.NetworkOperators.DataClasses;
        registeredProviderId: string;
        registeredProviderName: string;
        registrationNetworkError: number;
    }

    enum MobileBroadbandRadioState {
        off,
        on
    }

    enum NetworkDeviceStatus {
        deviceNotReady,
        deviceReady,
        simNotInserted,
        badSim,
        deviceHardwareFailure,
        accountNotActivated,
        deviceLocked,
        deviceBlocked
    }

    enum NetworkOperatorEventMessageType {
        gsm,
        cdma,
        ussd,
        dataPlanThresholdReached,
        dataPlanReset,
        dataPlanDeleted,
        profileConnected,
        profileDisconnected,
        registeredRoaming,
        registeredHome
    }

    export class NetworkOperatorNotificationEventDetails implements Windows.Networking.NetworkOperators.INetworkOperatorNotificationEventDetails {
        encodingType: number;
        message: string;
        networkAccountId: string;
        notificationType: Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType;
        ruleId: string;
        smsMessage: Windows.Devices.Sms.ISmsMessage;
    }

    enum NetworkRegistrationState {
        none,
        deregistered,
        searching,
        home,
        roaming,
        partner,
        denied
    }

    enum ProfileMediaType {
        wlan,
        wwan
    }

    export class ProfileUsage {
        usageInMegabytes: number;
        lastSyncTime: Date;
    }

    export class ProvisionedProfile implements Windows.Networking.NetworkOperators.IProvisionedProfile {
        updateCost(value: Windows.Networking.Connectivity.NetworkCostType): void;
        updateUsage(value: Windows.Networking.NetworkOperators.ProfileUsage): void;
    }

    export class ProvisionFromXmlDocumentResults implements Windows.Networking.NetworkOperators.IProvisionFromXmlDocumentResults {
        allElementsProvisioned: boolean;
        provisionResultsXml: string;
    }

    export class ProvisioningAgent implements Windows.Networking.NetworkOperators.IProvisioningAgent {
        constructor();
        provisionFromXmlDocumentAsync(provisioningXmlDocument: string): Windows.Foundation.IAsyncOperation<Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults>;
        getProvisionedProfile(mediaType: Windows.Networking.NetworkOperators.ProfileMediaType, profileName: string): Windows.Networking.NetworkOperators.ProvisionedProfile;
        static createFromNetworkAccountId(networkAccountId: string): Windows.Networking.NetworkOperators.ProvisioningAgent;
    }

    export class UssdMessage implements Windows.Networking.NetworkOperators.IUssdMessage {
        constructor(messageText: string);
        getPayload(): any;
        setPayload(value: any): void;
        dataCodingScheme: number;
        payloadAsText: string;
    }

    export class UssdReply implements Windows.Networking.NetworkOperators.IUssdReply {
        message: Windows.Networking.NetworkOperators.UssdMessage;
        resultCode: Windows.Networking.NetworkOperators.UssdResultCode;
    }

    enum UssdResultCode {
        noActionRequired,
        actionRequired,
        terminated,
        otherLocalClient,
        operationNotSupported,
        networkTimeout
    }

    export class UssdSession implements Windows.Networking.NetworkOperators.IUssdSession {
        sendMessageAndGetReplyAsync(message: Windows.Networking.NetworkOperators.UssdMessage): Windows.Foundation.IAsyncOperation<Windows.Networking.NetworkOperators.UssdReply>;
        close(): void;
        static createFromNetworkAccountId(networkAccountId: string): Windows.Networking.NetworkOperators.UssdSession;
        static createFromNetworkInterfaceId(networkInterfaceId: string): Windows.Networking.NetworkOperators.UssdSession;
    }

}
declare module Windows.Networking.Proximity {

    export class ConnectionRequestedEventArgs implements Windows.Networking.Proximity.IConnectionRequestedEventArgs {
        peerInformation: Windows.Networking.Proximity.PeerInformation;
    }

    export interface DeviceArrivedEventHandler {
        target: Windows.Networking.Proximity.ProximityDevice;
        detail: any[];
        type: string;
    }

    export interface DeviceDepartedEventHandler {
        target: Windows.Networking.Proximity.ProximityDevice;
        detail: any[];
        type: string;
    }

    export interface IConnectionRequestedEventArgs {
        peerInformation: Windows.Networking.Proximity.PeerInformation;
    }

    export interface IPeerInformation {
        displayName: string;
    }

    export interface IProximityDevice {
        subscribeForMessage(messageType: string, messageReceivedHandler: Windows.Networking.Proximity.MessageReceivedHandler): number;
        publishMessage(messageType: string, message: string): number;
        publishMessage(messageType: string, message: string, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer): number;
        publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        publishUriMessage(message: Windows.Foundation.Uri): number;
        publishUriMessage(message: Windows.Foundation.Uri, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        stopSubscribingForMessage(subscriptionId: number): void;
        stopPublishingMessage(messageId: number): void;
        bitsPerSecond: number;
        deviceId: string;
        maxMessageBytes: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler): void;
        removeEventListener(eventName: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler): void;
        ondevicearrived: (ev: Windows.Networking.Proximity.DeviceArrivedEventHandler) => void;
        addEventListener(eventName: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler): void;
        removeEventListener(eventName: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler): void;
        ondevicedeparted: (ev: Windows.Networking.Proximity.DeviceDepartedEventHandler) => void;

    }

    export interface IProximityMessage {
        data: Windows.Storage.Streams.IBuffer;
        dataAsString: string;
        messageType: string;
        subscriptionId: number;
    }

    export interface ITriggeredConnectionStateChangedEventArgs {
        id: number;
        socket: Windows.Networking.Sockets.StreamSocket;
        state: Windows.Networking.Proximity.TriggeredConnectState;
    }

    export interface MessageReceivedHandler {
        target: Windows.Networking.Proximity.ProximityDevice;
        detail: any[];
        type: string;
    }

    export interface MessageTransmittedHandler {
        target: Windows.Networking.Proximity.ProximityDevice;
        detail: any[];
        type: string;
    }

    enum PeerDiscoveryTypes {
        none,
        browse,
        triggered
    }

    export class PeerFinder {
        static start(): void;
        static start(peerMessage: string): void;
        static stop(): void;
        static findAllPeersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.Proximity.PeerInformation>>;
        static connectAsync(peerInformation: Windows.Networking.Proximity.PeerInformation): Windows.Foundation.IAsyncOperation<Windows.Networking.Sockets.StreamSocket>;
        static allowBluetooth: boolean;
        static allowInfrastructure: boolean;
        static allowWiFiDirect: boolean;
        static alternateIdentities: Windows.Foundation.Collections.IMap<string,string>;
        static displayName: string;
        static supportedDiscoveryTypes: Windows.Networking.Proximity.PeerDiscoveryTypes;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "connectionrequested", listener: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.ConnectionRequestedEventArgs>): void;
        removeEventListener(eventName: "connectionrequested", listener: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.ConnectionRequestedEventArgs>): void;
        onconnectionrequested: (ev: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.ConnectionRequestedEventArgs>) => void;
        addEventListener(eventName: "triggeredconnectionstatechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>): void;
        removeEventListener(eventName: "triggeredconnectionstatechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>): void;
        ontriggeredconnectionstatechanged: (ev: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>) => void;

    }

    export class PeerInformation implements Windows.Networking.Proximity.IPeerInformation {
        displayName: string;
    }

    export class ProximityDevice implements Windows.Networking.Proximity.IProximityDevice {
        subscribeForMessage(messageType: string, messageReceivedHandler: Windows.Networking.Proximity.MessageReceivedHandler): number;
        publishMessage(messageType: string, message: string): number;
        publishMessage(messageType: string, message: string, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer): number;
        publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        publishUriMessage(message: Windows.Foundation.Uri): number;
        publishUriMessage(message: Windows.Foundation.Uri, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        stopSubscribingForMessage(subscriptionId: number): void;
        stopPublishingMessage(messageId: number): void;
        static getDeviceSelector(): string;
        static getDefault(): Windows.Networking.Proximity.ProximityDevice;
        static fromId(deviceInterfaceId: string): Windows.Networking.Proximity.ProximityDevice;
        bitsPerSecond: number;
        deviceId: string;
        maxMessageBytes: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler): void;
        removeEventListener(eventName: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler): void;
        ondevicearrived: (ev: Windows.Networking.Proximity.DeviceArrivedEventHandler) => void;
        addEventListener(eventName: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler): void;
        removeEventListener(eventName: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler): void;
        ondevicedeparted: (ev: Windows.Networking.Proximity.DeviceDepartedEventHandler) => void;

    }

    export class ProximityMessage implements Windows.Networking.Proximity.IProximityMessage {
        data: Windows.Storage.Streams.IBuffer;
        dataAsString: string;
        messageType: string;
        subscriptionId: number;
    }

    export class TriggeredConnectionStateChangedEventArgs implements Windows.Networking.Proximity.ITriggeredConnectionStateChangedEventArgs {
        id: number;
        socket: Windows.Networking.Sockets.StreamSocket;
        state: Windows.Networking.Proximity.TriggeredConnectState;
    }

    enum TriggeredConnectState {
        peerFound,
        listening,
        connecting,
        completed,
        canceled,
        failed
    }

}
declare module Windows.Networking.PushNotifications {

    export interface IPushNotificationChannel {
        close(): void;
        expirationTime: Date;
        uri: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): void;
        removeEventListener(eventName: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): void;
        onpushnotificationreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>) => void;

    }

    export interface IPushNotificationReceivedEventArgs {
        badgeNotification: Windows.UI.Notifications.BadgeNotification;
        cancel: boolean;
        notificationType: Windows.Networking.PushNotifications.PushNotificationType;
        rawNotification: Windows.Networking.PushNotifications.RawNotification;
        tileNotification: Windows.UI.Notifications.TileNotification;
        toastNotification: Windows.UI.Notifications.ToastNotification;
    }

    export interface IRawNotification {
        content: string;
    }

    export class PushNotificationChannel implements Windows.Networking.PushNotifications.IPushNotificationChannel {
        close(): void;
        expirationTime: Date;
        uri: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): void;
        removeEventListener(eventName: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): void;
        onpushnotificationreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>) => void;

    }

    export class PushNotificationChannelManager {
        static createPushNotificationChannelForApplicationAsync(): Windows.Foundation.IAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>;
        static createPushNotificationChannelForApplicationAsync(applicationId: string): Windows.Foundation.IAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>;
        static createPushNotificationChannelForSecondaryTileAsync(tileId: string): Windows.Foundation.IAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>;
    }

    export class PushNotificationReceivedEventArgs implements Windows.Networking.PushNotifications.IPushNotificationReceivedEventArgs {
        badgeNotification: Windows.UI.Notifications.BadgeNotification;
        cancel: boolean;
        notificationType: Windows.Networking.PushNotifications.PushNotificationType;
        rawNotification: Windows.Networking.PushNotifications.RawNotification;
        tileNotification: Windows.UI.Notifications.TileNotification;
        toastNotification: Windows.UI.Notifications.ToastNotification;
    }

    enum PushNotificationType {
        toast,
        tile,
        badge,
        raw
    }

    export class RawNotification implements Windows.Networking.PushNotifications.IRawNotification {
        content: string;
    }

}
declare module Windows.Networking.Sockets {

    export class BandwidthStatistics {
        outboundBitsPerSecond: number;
        inboundBitsPerSecond: number;
        outboundBitsPerSecondInstability: number;
        inboundBitsPerSecondInstability: number;
        outboundBandwidthPeaked: boolean;
        inboundBandwidthPeaked: boolean;
    }

    export class ControlChannelTrigger implements Windows.Networking.Sockets.IControlChannelTrigger, Windows.Foundation.IClosable {
        constructor(channelId: string, serverKeepAliveIntervalInMinutes: number);
        constructor(channelId: string, serverKeepAliveIntervalInMinutes: number, resourceRequestType: Windows.Networking.Sockets.ControlChannelTriggerResourceType);
        usingTransport(transport: any): void;
        waitForPushEnabled(): Windows.Networking.Sockets.ControlChannelTriggerStatus;
        decreaseNetworkKeepAliveInterval(): void;
        flushTransport(): void;
        close(): void;
        controlChannelTriggerId: string;
        currentKeepAliveIntervalInMinutes: number;
        keepAliveTrigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
        pushNotificationTrigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
        serverKeepAliveIntervalInMinutes: number;
        transportObject: any;
    }

    enum ControlChannelTriggerResetReason {
        fastUserSwitched,
        lowPowerExit
    }

    enum ControlChannelTriggerResourceType {
        requestSoftwareSlot,
        requestHardwareSlot
    }

    enum ControlChannelTriggerStatus {
        hardwareSlotRequested,
        softwareSlotAllocated,
        hardwareSlotAllocated,
        policyError,
        systemError,
        transportDisconnected,
        serviceUnavailable
    }

    export class DatagramSocket implements Windows.Networking.Sockets.IDatagramSocket, Windows.Foundation.IClosable {
        constructor();
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncAction;
        connectAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncAction;
        bindServiceNameAsync(localServiceName: string): Windows.Foundation.IAsyncAction;
        bindEndpointAsync(localHostName: Windows.Networking.HostName, localServiceName: string): Windows.Foundation.IAsyncAction;
        joinMulticastGroup(host: Windows.Networking.HostName): void;
        getOutputStreamAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IOutputStream>;
        getOutputStreamAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IOutputStream>;
        close(): void;
        static getEndpointPairsAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>>;
        static getEndpointPairsAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string, sortOptions: Windows.Networking.HostNameSortOptions): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>>;
        control: Windows.Networking.Sockets.DatagramSocketControl;
        information: Windows.Networking.Sockets.DatagramSocketInformation;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): void;
        removeEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): void;
        onmessagereceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>) => void;

    }

    export class DatagramSocketControl implements Windows.Networking.Sockets.IDatagramSocketControl {
        outboundUnicastHopLimit: number;
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export class DatagramSocketInformation implements Windows.Networking.Sockets.IDatagramSocketInformation {
        localAddress: Windows.Networking.HostName;
        localPort: string;
        remoteAddress: Windows.Networking.HostName;
        remotePort: string;
    }

    export class DatagramSocketMessageReceivedEventArgs implements Windows.Networking.Sockets.IDatagramSocketMessageReceivedEventArgs {
        getDataReader(): Windows.Storage.Streams.DataReader;
        getDataStream(): Windows.Storage.Streams.IInputStream;
        localAddress: Windows.Networking.HostName;
        remoteAddress: Windows.Networking.HostName;
        remotePort: string;
    }

    export interface IControlChannelTrigger extends Windows.Foundation.IClosable {
        usingTransport(transport: any): void;
        waitForPushEnabled(): Windows.Networking.Sockets.ControlChannelTriggerStatus;
        decreaseNetworkKeepAliveInterval(): void;
        flushTransport(): void;
        controlChannelTriggerId: string;
        currentKeepAliveIntervalInMinutes: number;
        keepAliveTrigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
        pushNotificationTrigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
        serverKeepAliveIntervalInMinutes: number;
        transportObject: any;
    }

    export interface IControlChannelTriggerEventDetails {
        controlChannelTrigger: Windows.Networking.Sockets.ControlChannelTrigger;
    }

    export interface IControlChannelTriggerResetEventDetails {
        hardwareSlotReset: boolean;
        resetReason: Windows.Networking.Sockets.ControlChannelTriggerResetReason;
        softwareSlotReset: boolean;
    }

    export interface IDatagramSocket extends Windows.Foundation.IClosable {
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncAction;
        connectAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncAction;
        bindServiceNameAsync(localServiceName: string): Windows.Foundation.IAsyncAction;
        bindEndpointAsync(localHostName: Windows.Networking.HostName, localServiceName: string): Windows.Foundation.IAsyncAction;
        joinMulticastGroup(host: Windows.Networking.HostName): void;
        getOutputStreamAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IOutputStream>;
        getOutputStreamAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IOutputStream>;
        control: Windows.Networking.Sockets.DatagramSocketControl;
        information: Windows.Networking.Sockets.DatagramSocketInformation;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): void;
        removeEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): void;
        onmessagereceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>) => void;

    }

    export interface IDatagramSocketControl {
        outboundUnicastHopLimit: number;
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export interface IDatagramSocketInformation {
        localAddress: Windows.Networking.HostName;
        localPort: string;
        remoteAddress: Windows.Networking.HostName;
        remotePort: string;
    }

    export interface IDatagramSocketMessageReceivedEventArgs {
        getDataReader(): Windows.Storage.Streams.DataReader;
        getDataStream(): Windows.Storage.Streams.IInputStream;
        localAddress: Windows.Networking.HostName;
        remoteAddress: Windows.Networking.HostName;
        remotePort: string;
    }

    export interface IMessageWebSocket extends Windows.Networking.Sockets.IWebSocket, Windows.Foundation.IClosable {
        control: Windows.Networking.Sockets.MessageWebSocketControl;
        information: Windows.Networking.Sockets.MessageWebSocketInformation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): void;
        removeEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): void;
        onmessagereceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>) => void;

    }

    export interface IMessageWebSocketControl extends Windows.Networking.Sockets.IWebSocketControl {
        maxMessageSize: number;
        messageType: Windows.Networking.Sockets.SocketMessageType;
    }

    export interface IMessageWebSocketMessageReceivedEventArgs {
        getDataReader(): Windows.Storage.Streams.DataReader;
        getDataStream(): Windows.Storage.Streams.IInputStream;
        messageType: Windows.Networking.Sockets.SocketMessageType;
    }

    export interface IStreamSocket extends Windows.Foundation.IClosable {
        connectAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncAction;
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncAction;
        connectAsync(endpointPair: Windows.Networking.EndpointPair, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel): Windows.Foundation.IAsyncAction;
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel): Windows.Foundation.IAsyncAction;
        upgradeToSslAsync(protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel, validationHostName: Windows.Networking.HostName): Windows.Foundation.IAsyncAction;
        control: Windows.Networking.Sockets.StreamSocketControl;
        information: Windows.Networking.Sockets.StreamSocketInformation;
        inputStream: Windows.Storage.Streams.IInputStream;
        outputStream: Windows.Storage.Streams.IOutputStream;
    }

    export interface IStreamSocketControl {
        keepAlive: boolean;
        noDelay: boolean;
        outboundBufferSizeInBytes: number;
        outboundUnicastHopLimit: number;
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export interface IStreamSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        localPort: string;
        protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel;
        remoteAddress: Windows.Networking.HostName;
        remoteHostName: Windows.Networking.HostName;
        remotePort: string;
        remoteServiceName: string;
        roundTripTimeStatistics: Windows.Networking.Sockets.RoundTripTimeStatistics;
        sessionKey: Windows.Storage.Streams.IBuffer;
    }

    export interface IStreamSocketListener extends Windows.Foundation.IClosable {
        bindServiceNameAsync(localServiceName: string): Windows.Foundation.IAsyncAction;
        bindEndpointAsync(localHostName: Windows.Networking.HostName, localServiceName: string): Windows.Foundation.IAsyncAction;
        control: Windows.Networking.Sockets.StreamSocketListenerControl;
        information: Windows.Networking.Sockets.StreamSocketListenerInformation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): void;
        removeEventListener(eventName: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): void;
        onconnectionreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>) => void;

    }

    export interface IStreamSocketListenerConnectionReceivedEventArgs {
        socket: Windows.Networking.Sockets.StreamSocket;
    }

    export interface IStreamSocketListenerControl {
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export interface IStreamSocketListenerInformation {
        localPort: string;
    }

    export interface IStreamWebSocket extends Windows.Networking.Sockets.IWebSocket, Windows.Foundation.IClosable {
        control: Windows.Networking.Sockets.StreamWebSocketControl;
        information: Windows.Networking.Sockets.StreamWebSocketInformation;
        inputStream: Windows.Storage.Streams.IInputStream;
    }

    export interface IStreamWebSocketControl extends Windows.Networking.Sockets.IWebSocketControl {
        noDelay: boolean;
    }

    export interface IWebSocket extends Windows.Foundation.IClosable {
        connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncAction;
        setRequestHeader(headerName: string, headerValue: string): void;
        close(code: number, reason: string): void;
        close(): void;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>) => void;

    }

    export interface IWebSocketClosedEventArgs {
        code: number;
        reason: string;
    }

    export interface IWebSocketControl {
        outboundBufferSizeInBytes: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        supportedProtocols: Windows.Foundation.Collections.IVector<string>;
    }

    export interface IWebSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        protocol: string;
    }

    export class MessageWebSocket implements Windows.Networking.Sockets.IMessageWebSocket, Windows.Networking.Sockets.IWebSocket, Windows.Foundation.IClosable {
        constructor();
        connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncAction;
        setRequestHeader(headerName: string, headerValue: string): void;
        close(code: number, reason: string): void;
        close(): void;
        control: Windows.Networking.Sockets.MessageWebSocketControl;
        information: Windows.Networking.Sockets.MessageWebSocketInformation;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): void;
        removeEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): void;
        onmessagereceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>) => void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>) => void;

    }

    export class MessageWebSocketControl implements Windows.Networking.Sockets.IMessageWebSocketControl, Windows.Networking.Sockets.IWebSocketControl {
        maxMessageSize: number;
        messageType: Windows.Networking.Sockets.SocketMessageType;
        outboundBufferSizeInBytes: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        supportedProtocols: Windows.Foundation.Collections.IVector<string>;
    }

    export class MessageWebSocketInformation implements Windows.Networking.Sockets.IWebSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        protocol: string;
    }

    export class MessageWebSocketMessageReceivedEventArgs implements Windows.Networking.Sockets.IMessageWebSocketMessageReceivedEventArgs {
        getDataReader(): Windows.Storage.Streams.DataReader;
        getDataStream(): Windows.Storage.Streams.IInputStream;
        messageType: Windows.Networking.Sockets.SocketMessageType;
    }

    export class RoundTripTimeStatistics {
        variance: number;
        max: number;
        min: number;
        sum: number;
    }

    export class SocketError {
        static getStatus(hresult: number): Windows.Networking.Sockets.SocketErrorStatus;
    }

    enum SocketErrorStatus {
        unknown,
        operationAborted,
        httpInvalidServerResponse,
        connectionTimedOut,
        addressFamilyNotSupported,
        socketTypeNotSupported,
        hostNotFound,
        noDataRecordOfRequestedType,
        nonAuthoritativeHostNotFound,
        classTypeNotFound,
        addressAlreadyInUse,
        cannotAssignRequestedAddress,
        connectionRefused,
        networkIsUnreachable,
        unreachableHost,
        networkIsDown,
        networkDroppedConnectionOnReset,
        softwareCausedConnectionAbort,
        connectionResetByPeer,
        hostIsDown,
        noAddressesFound,
        tooManyOpenFiles,
        messageTooLong,
        certificateExpired,
        certificateUntrustedRoot,
        certificateCommonNameIsIncorrect,
        certificateWrongUsage,
        certificateRevoked,
        certificateNoRevocationCheck,
        certificateRevocationServerOffline,
        certificateIsInvalid
    }

    enum SocketMessageType {
        binary,
        utf8
    }

    enum SocketProtectionLevel {
        plainSocket,
        ssl,
        sslAllowNullEncryption
    }

    enum SocketQualityOfService {
        normal,
        lowLatency
    }

    export class StreamSocket implements Windows.Networking.Sockets.IStreamSocket, Windows.Foundation.IClosable {
        constructor();
        connectAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncAction;
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncAction;
        connectAsync(endpointPair: Windows.Networking.EndpointPair, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel): Windows.Foundation.IAsyncAction;
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel): Windows.Foundation.IAsyncAction;
        upgradeToSslAsync(protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel, validationHostName: Windows.Networking.HostName): Windows.Foundation.IAsyncAction;
        close(): void;
        control: Windows.Networking.Sockets.StreamSocketControl;
        information: Windows.Networking.Sockets.StreamSocketInformation;
        inputStream: Windows.Storage.Streams.IInputStream;
        outputStream: Windows.Storage.Streams.IOutputStream;
    }

    export class StreamSocketControl implements Windows.Networking.Sockets.IStreamSocketControl {
        keepAlive: boolean;
        noDelay: boolean;
        outboundBufferSizeInBytes: number;
        outboundUnicastHopLimit: number;
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export class StreamSocketInformation implements Windows.Networking.Sockets.IStreamSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        localPort: string;
        protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel;
        remoteAddress: Windows.Networking.HostName;
        remoteHostName: Windows.Networking.HostName;
        remotePort: string;
        remoteServiceName: string;
        roundTripTimeStatistics: Windows.Networking.Sockets.RoundTripTimeStatistics;
        sessionKey: Windows.Storage.Streams.IBuffer;
    }

    export class StreamSocketListener implements Windows.Networking.Sockets.IStreamSocketListener, Windows.Foundation.IClosable {
        constructor();
        bindServiceNameAsync(localServiceName: string): Windows.Foundation.IAsyncAction;
        bindEndpointAsync(localHostName: Windows.Networking.HostName, localServiceName: string): Windows.Foundation.IAsyncAction;
        close(): void;
        control: Windows.Networking.Sockets.StreamSocketListenerControl;
        information: Windows.Networking.Sockets.StreamSocketListenerInformation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): void;
        removeEventListener(eventName: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): void;
        onconnectionreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>) => void;

    }

    export class StreamSocketListenerConnectionReceivedEventArgs implements Windows.Networking.Sockets.IStreamSocketListenerConnectionReceivedEventArgs {
        socket: Windows.Networking.Sockets.StreamSocket;
    }

    export class StreamSocketListenerControl implements Windows.Networking.Sockets.IStreamSocketListenerControl {
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export class StreamSocketListenerInformation implements Windows.Networking.Sockets.IStreamSocketListenerInformation {
        localPort: string;
    }

    export class StreamWebSocket implements Windows.Networking.Sockets.IStreamWebSocket, Windows.Networking.Sockets.IWebSocket, Windows.Foundation.IClosable {
        constructor();
        connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncAction;
        setRequestHeader(headerName: string, headerValue: string): void;
        close(code: number, reason: string): void;
        close(): void;
        control: Windows.Networking.Sockets.StreamWebSocketControl;
        information: Windows.Networking.Sockets.StreamWebSocketInformation;
        inputStream: Windows.Storage.Streams.IInputStream;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>) => void;

    }

    export class StreamWebSocketControl implements Windows.Networking.Sockets.IStreamWebSocketControl, Windows.Networking.Sockets.IWebSocketControl {
        noDelay: boolean;
        outboundBufferSizeInBytes: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        supportedProtocols: Windows.Foundation.Collections.IVector<string>;
    }

    export class StreamWebSocketInformation implements Windows.Networking.Sockets.IWebSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        protocol: string;
    }

    export class WebSocketClosedEventArgs implements Windows.Networking.Sockets.IWebSocketClosedEventArgs {
        code: number;
        reason: string;
    }

    export class WebSocketError {
        static getStatus(hresult: number): Windows.Web.WebErrorStatus;
    }

    export class WebSocketKeepAlive implements Windows.ApplicationModel.Background.IBackgroundTask {
        constructor();
        run(taskInstance: Windows.ApplicationModel.Background.IBackgroundTaskInstance): void;
    }

}
declare module Windows.Security.Authentication.OnlineId {

    enum CredentialPromptType {
        promptIfNeeded,
        retypeCredentials,
        doNotPrompt
    }

    export interface IOnlineIdAuthenticator {
        authenticateUserAsync(request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest): Windows.Security.Authentication.OnlineId.UserAuthenticationOperation;
        authenticateUserAsync(requests: Windows.Foundation.Collections.IIterable<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest>, credentialPromptType: Windows.Security.Authentication.OnlineId.CredentialPromptType): Windows.Security.Authentication.OnlineId.UserAuthenticationOperation;
        signOutUserAsync(): Windows.Security.Authentication.OnlineId.SignOutUserOperation;
        applicationId: string;
        authenticatedSafeCustomerId: string;
        canSignOut: boolean;
    }

    export interface IOnlineIdServiceTicket {
        errorCode: number;
        request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest;
        value: string;
    }

    export interface IOnlineIdServiceTicketRequest {
        policy: string;
        service: string;
    }

    export interface IUserIdentity {
        firstName: string;
        id: string;
        isBetaAccount: boolean;
        isConfirmedPC: boolean;
        lastName: string;
        safeCustomerId: string;
        signInName: string;
        tickets: Windows.Foundation.Collections.IVectorView<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket>;
    }

    export class OnlineIdAuthenticator implements Windows.Security.Authentication.OnlineId.IOnlineIdAuthenticator {
        constructor();
        authenticateUserAsync(request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest): Windows.Security.Authentication.OnlineId.UserAuthenticationOperation;
        authenticateUserAsync(requests: Windows.Foundation.Collections.IIterable<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest>, credentialPromptType: Windows.Security.Authentication.OnlineId.CredentialPromptType): Windows.Security.Authentication.OnlineId.UserAuthenticationOperation;
        signOutUserAsync(): Windows.Security.Authentication.OnlineId.SignOutUserOperation;
        applicationId: string;
        authenticatedSafeCustomerId: string;
        canSignOut: boolean;
    }

    export class OnlineIdServiceTicket implements Windows.Security.Authentication.OnlineId.IOnlineIdServiceTicket {
        errorCode: number;
        request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest;
        value: string;
    }

    export class OnlineIdServiceTicketRequest implements Windows.Security.Authentication.OnlineId.IOnlineIdServiceTicketRequest {
        constructor(service: string, policy: string);
        constructor(service: string);
        policy: string;
        service: string;
    }

    export class SignOutUserOperation implements Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncInfo {
        getResults(): void;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export class UserAuthenticationOperation implements Windows.Foundation.IAsyncOperation<Windows.Security.Authentication.OnlineId.UserIdentity>, Windows.Foundation.IAsyncInfo {
        getResults(): Windows.Security.Authentication.OnlineId.UserIdentity;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Security.Authentication.OnlineId.UserIdentity>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class UserIdentity implements Windows.Security.Authentication.OnlineId.IUserIdentity {
        firstName: string;
        id: string;
        isBetaAccount: boolean;
        isConfirmedPC: boolean;
        lastName: string;
        safeCustomerId: string;
        signInName: string;
        tickets: Windows.Foundation.Collections.IVectorView<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket>;
    }

}
declare module Windows.Security.Authentication.Web {

    export interface IWebAuthenticationResult {
        responseData: string;
        responseErrorDetail: number;
        responseStatus: Windows.Security.Authentication.Web.WebAuthenticationStatus;
    }

    export class WebAuthenticationBroker {
        static authenticateAsync(options: Windows.Security.Authentication.Web.WebAuthenticationOptions, requestUri: Windows.Foundation.Uri, callbackUri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Security.Authentication.Web.WebAuthenticationResult>;
        static authenticateAsync(options: Windows.Security.Authentication.Web.WebAuthenticationOptions, requestUri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Security.Authentication.Web.WebAuthenticationResult>;
        static getCurrentApplicationCallbackUri(): Windows.Foundation.Uri;
    }

    enum WebAuthenticationOptions {
        none,
        silentMode,
        useTitle,
        useHttpPost,
        useCorporateNetwork
    }

    export class WebAuthenticationResult implements Windows.Security.Authentication.Web.IWebAuthenticationResult {
        responseData: string;
        responseErrorDetail: number;
        responseStatus: Windows.Security.Authentication.Web.WebAuthenticationStatus;
    }

    enum WebAuthenticationStatus {
        success,
        userCancel,
        errorHttp
    }

}
declare module Windows.Security.Credentials {

    export interface IPasswordCredential {
        retrievePassword(): void;
        password: string;
        properties: Windows.Foundation.Collections.IPropertySet;
        resource: string;
        userName: string;
    }

    export interface IPasswordVault {
        add(credential: Windows.Security.Credentials.PasswordCredential): void;
        remove(credential: Windows.Security.Credentials.PasswordCredential): void;
        retrieve(resource: string, userName: string): Windows.Security.Credentials.PasswordCredential;
        findAllByResource(resource: string): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
        findAllByUserName(userName: string): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
        retrieveAll(): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
    }

    export class PasswordCredential implements Windows.Security.Credentials.IPasswordCredential {
        constructor(resource: string, userName: string, password: string);
        constructor();
        retrievePassword(): void;
        password: string;
        properties: Windows.Foundation.Collections.IPropertySet;
        resource: string;
        userName: string;
    }

    export class PasswordCredentialPropertyStore implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        constructor();
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    export class PasswordVault implements Windows.Security.Credentials.IPasswordVault {
        constructor();
        add(credential: Windows.Security.Credentials.PasswordCredential): void;
        remove(credential: Windows.Security.Credentials.PasswordCredential): void;
        retrieve(resource: string, userName: string): Windows.Security.Credentials.PasswordCredential;
        findAllByResource(resource: string): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
        findAllByUserName(userName: string): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
        retrieveAll(): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
    }

}
declare module Windows.Security.Credentials.UI {

    enum AuthenticationProtocol {
        basic,
        digest,
        ntlm,
        kerberos,
        negotiate,
        credSsp,
        custom
    }

    export class CredentialPicker {
        static pickAsync(options: Windows.Security.Credentials.UI.CredentialPickerOptions): Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>;
        static pickAsync(targetName: string, message: string): Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>;
        static pickAsync(targetName: string, message: string, caption: string): Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>;
    }

    export class CredentialPickerOptions implements Windows.Security.Credentials.UI.ICredentialPickerOptions {
        constructor();
        alwaysDisplayDialog: boolean;
        authenticationProtocol: Windows.Security.Credentials.UI.AuthenticationProtocol;
        callerSavesCredential: boolean;
        caption: string;
        credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
        customAuthenticationProtocol: string;
        errorCode: number;
        message: string;
        previousCredential: Windows.Storage.Streams.IBuffer;
        targetName: string;
    }

    export class CredentialPickerResults implements Windows.Security.Credentials.UI.ICredentialPickerResults {
        credential: Windows.Storage.Streams.IBuffer;
        credentialDomainName: string;
        credentialPassword: string;
        credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
        credentialSaved: boolean;
        credentialUserName: string;
        errorCode: number;
    }

    enum CredentialSaveOption {
        unselected,
        selected,
        hidden
    }

    export interface ICredentialPickerOptions {
        alwaysDisplayDialog: boolean;
        authenticationProtocol: Windows.Security.Credentials.UI.AuthenticationProtocol;
        callerSavesCredential: boolean;
        caption: string;
        credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
        customAuthenticationProtocol: string;
        errorCode: number;
        message: string;
        previousCredential: Windows.Storage.Streams.IBuffer;
        targetName: string;
    }

    export interface ICredentialPickerResults {
        credential: Windows.Storage.Streams.IBuffer;
        credentialDomainName: string;
        credentialPassword: string;
        credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
        credentialSaved: boolean;
        credentialUserName: string;
        errorCode: number;
    }

}
declare module Windows.Security.Cryptography {

    enum BinaryStringEncoding {
        utf8,
        utf16LE,
        utf16BE
    }

    export class CryptographicBuffer {
        static compare(object1: Windows.Storage.Streams.IBuffer, object2: Windows.Storage.Streams.IBuffer): boolean;
        static generateRandom(length: number): Windows.Storage.Streams.IBuffer;
        static generateRandomNumber(): number;
        static createFromByteArray(value: any): Windows.Storage.Streams.IBuffer;
        static copyToByteArray(buffer: Windows.Storage.Streams.IBuffer): CryptographicBuffer_copyToByteArray_OUT;
        static decodeFromHexString(value: string): Windows.Storage.Streams.IBuffer;
        static encodeToHexString(buffer: Windows.Storage.Streams.IBuffer): string;
        static decodeFromBase64String(value: string): Windows.Storage.Streams.IBuffer;
        static encodeToBase64String(buffer: Windows.Storage.Streams.IBuffer): string;
        static convertStringToBinary(value: string, encoding: Windows.Security.Cryptography.BinaryStringEncoding): Windows.Storage.Streams.IBuffer;
        static convertBinaryToString(encoding: Windows.Security.Cryptography.BinaryStringEncoding, buffer: Windows.Storage.Streams.IBuffer): string;
    }

    interface CryptographicBuffer_copyToByteArray_OUT {
        value: number[];
    }

}
declare module Windows.Security.Cryptography.Certificates {

    export class CertificateEnrollmentManager {
        static createRequestAsync(request: Windows.Security.Cryptography.Certificates.CertificateRequestProperties): Windows.Foundation.IAsyncOperation<string>;
        static installCertificateAsync(certificate: string, installOption: Windows.Security.Cryptography.Certificates.InstallOptions): Windows.Foundation.IAsyncAction;
        static importPfxDataAsync(pfxData: string, password: string, exportable: Windows.Security.Cryptography.Certificates.ExportOption, keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel, installOption: Windows.Security.Cryptography.Certificates.InstallOptions, friendlyName: string): Windows.Foundation.IAsyncAction;
    }

    export class CertificateRequestProperties implements Windows.Security.Cryptography.Certificates.ICertificateRequestProperties {
        constructor();
        exportable: Windows.Security.Cryptography.Certificates.ExportOption;
        friendlyName: string;
        hashAlgorithmName: string;
        keyAlgorithmName: string;
        keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
        keySize: number;
        keyStorageProviderName: string;
        keyUsages: Windows.Security.Cryptography.Certificates.EnrollKeyUsages;
        subject: string;
    }

    enum EnrollKeyUsages {
        none,
        decryption,
        signing,
        keyAgreement,
        all
    }

    enum ExportOption {
        notExportable,
        exportable
    }

    export interface ICertificateRequestProperties {
        exportable: Windows.Security.Cryptography.Certificates.ExportOption;
        friendlyName: string;
        hashAlgorithmName: string;
        keyAlgorithmName: string;
        keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
        keySize: number;
        keyStorageProviderName: string;
        keyUsages: Windows.Security.Cryptography.Certificates.EnrollKeyUsages;
        subject: string;
    }

    enum InstallOptions {
        none,
        deleteExpired
    }

    export class KeyAlgorithmNames {
        static dsa: string;
        static ecdh256: string;
        static ecdh384: string;
        static ecdh521: string;
        static ecdsa256: string;
        static ecdsa384: string;
        static ecdsa521: string;
        static rsa: string;
    }

    enum KeyProtectionLevel {
        noConsent,
        consentOnly,
        consentWithPassword
    }

    enum KeySize {
        invalid,
        rsa2048,
        rsa4096
    }

    export class KeyStorageProviderNames {
        static platformKeyStorageProvider: string;
        static smartcardKeyStorageProvider: string;
        static softwareKeyStorageProvider: string;
    }

}
declare module Windows.Security.Cryptography.Core {

    export class AsymmetricAlgorithmNames {
        static dsaSha1: string;
        static dsaSha256: string;
        static ecdsaP256Sha256: string;
        static ecdsaP384Sha384: string;
        static ecdsaP521Sha512: string;
        static rsaOaepSha1: string;
        static rsaOaepSha256: string;
        static rsaOaepSha384: string;
        static rsaOaepSha512: string;
        static rsaPkcs1: string;
        static rsaSignPkcs1Sha1: string;
        static rsaSignPkcs1Sha256: string;
        static rsaSignPkcs1Sha384: string;
        static rsaSignPkcs1Sha512: string;
        static rsaSignPssSha1: string;
        static rsaSignPssSha256: string;
        static rsaSignPssSha384: string;
        static rsaSignPssSha512: string;
    }

    export class AsymmetricKeyAlgorithmProvider implements Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider {
        createKeyPair(keySize: number): Windows.Security.Cryptography.Core.CryptographicKey;
        importKeyPair(keyBlob: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        importKeyPair(keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows.Security.Cryptography.Core.CryptographicKey;
        importPublicKey(keyBlob: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        importPublicKey(keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows.Security.Cryptography.Core.CryptographicKey;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider;
        algorithmName: string;
    }

    export class CryptographicEngine {
        static encrypt(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, iv: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        static decrypt(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, iv: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        static encryptAndAuthenticate(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, nonce: Windows.Storage.Streams.IBuffer, authenticatedData: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData;
        static decryptAndAuthenticate(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, nonce: Windows.Storage.Streams.IBuffer, authenticationTag: Windows.Storage.Streams.IBuffer, authenticatedData: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        static sign(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        static verifySignature(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, signature: Windows.Storage.Streams.IBuffer): boolean;
        static deriveKeyMaterial(key: Windows.Security.Cryptography.Core.CryptographicKey, parameters: Windows.Security.Cryptography.Core.KeyDerivationParameters, desiredKeySize: number): Windows.Storage.Streams.IBuffer;
    }

    export class CryptographicHash implements Windows.Security.Cryptography.Core.IHashComputation {
        append(data: Windows.Storage.Streams.IBuffer): void;
        getValueAndReset(): Windows.Storage.Streams.IBuffer;
    }

    export class CryptographicKey implements Windows.Security.Cryptography.Core.ICryptographicKey {
        export(): Windows.Storage.Streams.IBuffer;
        export(BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows.Storage.Streams.IBuffer;
        exportPublicKey(): Windows.Storage.Streams.IBuffer;
        exportPublicKey(BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows.Storage.Streams.IBuffer;
        keySize: number;
    }

    enum CryptographicPrivateKeyBlobType {
        pkcs8RawPrivateKeyInfo,
        pkcs1RsaPrivateKey,
        bCryptPrivateKey,
        capi1PrivateKey
    }

    enum CryptographicPublicKeyBlobType {
        x509SubjectPublicKeyInfo,
        pkcs1RsaPublicKey,
        bCryptPublicKey,
        capi1PublicKey
    }

    export class EncryptedAndAuthenticatedData implements Windows.Security.Cryptography.Core.IEncryptedAndAuthenticatedData {
        authenticationTag: Windows.Storage.Streams.IBuffer;
        encryptedData: Windows.Storage.Streams.IBuffer;
    }

    export class HashAlgorithmNames {
        static md5: string;
        static sha1: string;
        static sha256: string;
        static sha384: string;
        static sha512: string;
    }

    export class HashAlgorithmProvider implements Windows.Security.Cryptography.Core.IHashAlgorithmProvider {
        hashData(data: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        createHash(): Windows.Security.Cryptography.Core.CryptographicHash;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.HashAlgorithmProvider;
        algorithmName: string;
        hashLength: number;
    }

    export interface IAsymmetricKeyAlgorithmProvider {
        createKeyPair(keySize: number): Windows.Security.Cryptography.Core.CryptographicKey;
        importKeyPair(keyBlob: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        importKeyPair(keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows.Security.Cryptography.Core.CryptographicKey;
        importPublicKey(keyBlob: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        importPublicKey(keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows.Security.Cryptography.Core.CryptographicKey;
        algorithmName: string;
    }

    export interface ICryptographicKey {
        export(): Windows.Storage.Streams.IBuffer;
        export(BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows.Storage.Streams.IBuffer;
        exportPublicKey(): Windows.Storage.Streams.IBuffer;
        exportPublicKey(BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows.Storage.Streams.IBuffer;
        keySize: number;
    }

    export interface IEncryptedAndAuthenticatedData {
        authenticationTag: Windows.Storage.Streams.IBuffer;
        encryptedData: Windows.Storage.Streams.IBuffer;
    }

    export interface IHashAlgorithmProvider {
        hashData(data: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        createHash(): Windows.Security.Cryptography.Core.CryptographicHash;
        algorithmName: string;
        hashLength: number;
    }

    export interface IHashComputation {
        append(data: Windows.Storage.Streams.IBuffer): void;
        getValueAndReset(): Windows.Storage.Streams.IBuffer;
    }

    export interface IKeyDerivationAlgorithmProvider {
        createKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        algorithmName: string;
    }

    export interface IKeyDerivationParameters {
        iterationCount: number;
        kdfGenericBinary: Windows.Storage.Streams.IBuffer;
    }

    export interface IMacAlgorithmProvider {
        createKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        algorithmName: string;
        macLength: number;
    }

    export interface ISymmetricKeyAlgorithmProvider {
        createSymmetricKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        algorithmName: string;
        blockLength: number;
    }

    export class KeyDerivationAlgorithmNames {
        static pbkdf2Md5: string;
        static pbkdf2Sha1: string;
        static pbkdf2Sha256: string;
        static pbkdf2Sha384: string;
        static pbkdf2Sha512: string;
        static sp800108CtrHmacMd5: string;
        static sp800108CtrHmacSha1: string;
        static sp800108CtrHmacSha256: string;
        static sp800108CtrHmacSha384: string;
        static sp800108CtrHmacSha512: string;
        static sp80056aConcatMd5: string;
        static sp80056aConcatSha1: string;
        static sp80056aConcatSha256: string;
        static sp80056aConcatSha384: string;
        static sp80056aConcatSha512: string;
    }

    export class KeyDerivationAlgorithmProvider implements Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmProvider {
        createKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider;
        algorithmName: string;
    }

    export class KeyDerivationParameters implements Windows.Security.Cryptography.Core.IKeyDerivationParameters {
        static buildForPbkdf2(pbkdf2Salt: Windows.Storage.Streams.IBuffer, iterationCount: number): Windows.Security.Cryptography.Core.KeyDerivationParameters;
        static buildForSP800108(label: Windows.Storage.Streams.IBuffer, context: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.KeyDerivationParameters;
        static buildForSP80056a(algorithmId: Windows.Storage.Streams.IBuffer, partyUInfo: Windows.Storage.Streams.IBuffer, partyVInfo: Windows.Storage.Streams.IBuffer, suppPubInfo: Windows.Storage.Streams.IBuffer, suppPrivInfo: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.KeyDerivationParameters;
        iterationCount: number;
        kdfGenericBinary: Windows.Storage.Streams.IBuffer;
    }

    export class MacAlgorithmNames {
        static aesCmac: string;
        static hmacMd5: string;
        static hmacSha1: string;
        static hmacSha256: string;
        static hmacSha384: string;
        static hmacSha512: string;
    }

    export class MacAlgorithmProvider implements Windows.Security.Cryptography.Core.IMacAlgorithmProvider {
        createKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.MacAlgorithmProvider;
        algorithmName: string;
        macLength: number;
    }

    export class SymmetricAlgorithmNames {
        static aesCbc: string;
        static aesCbcPkcs7: string;
        static aesCcm: string;
        static aesEcb: string;
        static aesEcbPkcs7: string;
        static aesGcm: string;
        static desCbc: string;
        static desCbcPkcs7: string;
        static desEcb: string;
        static desEcbPkcs7: string;
        static rc2Cbc: string;
        static rc2CbcPkcs7: string;
        static rc2Ecb: string;
        static rc2EcbPkcs7: string;
        static rc4: string;
        static tripleDesCbc: string;
        static tripleDesCbcPkcs7: string;
        static tripleDesEcb: string;
        static tripleDesEcbPkcs7: string;
    }

    export class SymmetricKeyAlgorithmProvider implements Windows.Security.Cryptography.Core.ISymmetricKeyAlgorithmProvider {
        createSymmetricKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider;
        algorithmName: string;
        blockLength: number;
    }

}
declare module Windows.Security.Cryptography.DataProtection {

    export class DataProtectionProvider implements Windows.Security.Cryptography.DataProtection.IDataProtectionProvider {
        constructor(protectionDescriptor: string);
        constructor();
        protectAsync(data: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        unprotectAsync(data: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        protectStreamAsync(src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncAction;
        unprotectStreamAsync(src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncAction;
    }

    export interface IDataProtectionProvider {
        protectAsync(data: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        unprotectAsync(data: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        protectStreamAsync(src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncAction;
        unprotectStreamAsync(src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncAction;
    }

}
declare module Windows.Security.ExchangeActiveSyncProvisioning {

    export class EasClientDeviceInformation implements Windows.Security.ExchangeActiveSyncProvisioning.IEasClientDeviceInformation {
        constructor();
        friendlyName: string;
        id: string;
        operatingSystem: string;
        systemManufacturer: string;
        systemProductName: string;
        systemSku: string;
    }

    export class EasClientSecurityPolicy implements Windows.Security.ExchangeActiveSyncProvisioning.IEasClientSecurityPolicy {
        constructor();
        checkCompliance(): Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults;
        applyAsync(): Windows.Foundation.IAsyncOperation<Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults>;
        disallowConvenienceLogon: boolean;
        maxInactivityTimeLock: Windows.Foundation.TimeSpan;
        maxPasswordFailedAttempts: number;
        minPasswordComplexCharacters: number;
        minPasswordLength: number;
        passwordExpiration: Windows.Foundation.TimeSpan;
        passwordHistory: number;
        requireEncryption: boolean;
    }

    export class EasComplianceResults implements Windows.Security.ExchangeActiveSyncProvisioning.IEasComplianceResults {
        compliant: boolean;
        disallowConvenienceLogonResult: Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult;
        maxInactivityTimeLockResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult;
        maxPasswordFailedAttemptsResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult;
        minPasswordComplexCharactersResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult;
        minPasswordLengthResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult;
        passwordExpirationResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult;
        passwordHistoryResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult;
        requireEncryptionResult: Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult;
    }

    enum EasDisallowConvenienceLogonResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter
    }

    enum EasMaxInactivityTimeLockResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        invalidParameter
    }

    enum EasMaxPasswordFailedAttemptsResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        invalidParameter
    }

    enum EasMinPasswordComplexCharactersResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        requestedPolicyNotEnforceable,
        invalidParameter,
        currentUserHasBlankPassword,
        adminsHaveBlankPassword,
        userCannotChangePassword,
        adminsCannotChangePassword,
        localControlledUsersCannotChangePassword,
        connectedAdminsProviderPolicyIsWeak,
        connectedUserProviderPolicyIsWeak,
        changeConnectedAdminsPassword,
        changeConnectedUserPassword
    }

    enum EasMinPasswordLengthResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        requestedPolicyNotEnforceable,
        invalidParameter,
        currentUserHasBlankPassword,
        adminsHaveBlankPassword,
        userCannotChangePassword,
        adminsCannotChangePassword,
        localControlledUsersCannotChangePassword,
        connectedAdminsProviderPolicyIsWeak,
        connectedUserProviderPolicyIsWeak,
        changeConnectedAdminsPassword,
        changeConnectedUserPassword
    }

    enum EasPasswordExpirationResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        requestedExpirationIncompatible,
        invalidParameter,
        userCannotChangePassword,
        adminsCannotChangePassword,
        localControlledUsersCannotChangePassword
    }

    enum EasPasswordHistoryResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        invalidParameter
    }

    enum EasRequireEncryptionResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        notProvisionedOnAllVolumes,
        deFixedDataNotSupported,
        deHardwareNotCompliant,
        deWinReNotConfigured,
        deProtectionSuspended,
        deOsVolumeNotProtected,
        deProtectionNotYetEnabled,
        noFeatureLicense,
        osNotProtected
    }

    export interface IEasClientDeviceInformation {
        friendlyName: string;
        id: string;
        operatingSystem: string;
        systemManufacturer: string;
        systemProductName: string;
        systemSku: string;
    }

    export interface IEasClientSecurityPolicy {
        checkCompliance(): Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults;
        applyAsync(): Windows.Foundation.IAsyncOperation<Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults>;
        disallowConvenienceLogon: boolean;
        maxInactivityTimeLock: Windows.Foundation.TimeSpan;
        maxPasswordFailedAttempts: number;
        minPasswordComplexCharacters: number;
        minPasswordLength: number;
        passwordExpiration: Windows.Foundation.TimeSpan;
        passwordHistory: number;
        requireEncryption: boolean;
    }

    export interface IEasComplianceResults {
        compliant: boolean;
        disallowConvenienceLogonResult: Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult;
        maxInactivityTimeLockResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult;
        maxPasswordFailedAttemptsResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult;
        minPasswordComplexCharactersResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult;
        minPasswordLengthResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult;
        passwordExpirationResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult;
        passwordHistoryResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult;
        requireEncryptionResult: Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult;
    }

}
declare module Windows.Storage.AccessCache {

    enum AccessCacheOptions {
        none,
        disallowUserInput,
        fastLocationsOnly,
        useReadOnlyCachedCopy,
        suppressAccessTimeUpdate
    }

    export class AccessListEntry {
        token: string;
        metadata: string;
    }

    export class AccessListEntryView implements Windows.Foundation.Collections.IVectorView<Windows.Storage.AccessCache.AccessListEntry>, Windows.Foundation.Collections.IIterable<Windows.Storage.AccessCache.AccessListEntry> {
        getAt(index: number): Windows.Storage.AccessCache.AccessListEntry;
        indexOf(value: Windows.Storage.AccessCache.AccessListEntry): AccessListEntryView_indexOf_OUT;
        getMany(startIndex: number): AccessListEntryView_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Storage.AccessCache.AccessListEntry>;
        size: number;
    }

    interface AccessListEntryView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface AccessListEntryView_getMany_OUT {
        __returnValue: number;
        items: Windows.Storage.AccessCache.AccessListEntry[];
    }

    export interface IItemRemovedEventArgs {
        removedEntry: Windows.Storage.AccessCache.AccessListEntry;
    }

    export interface IStorageItemAccessList {
        add(file: Windows.Storage.IStorageItem): string;
        add(file: Windows.Storage.IStorageItem, metadata: string): string;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem): void;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem, metadata: string): void;
        getItemAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        remove(token: string): void;
        containsItem(token: string): boolean;
        clear(): void;
        checkAccess(file: Windows.Storage.IStorageItem): boolean;
        entries: Windows.Storage.AccessCache.AccessListEntryView;
        maximumItemsAllowed: number;
    }

    export interface IStorageItemMostRecentlyUsedList extends Windows.Storage.AccessCache.IStorageItemAccessList {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): void;
        removeEventListener(eventName: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): void;
        onitemremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>) => void;

    }

    export class ItemRemovedEventArgs implements Windows.Storage.AccessCache.IItemRemovedEventArgs {
        removedEntry: Windows.Storage.AccessCache.AccessListEntry;
    }

    export class StorageApplicationPermissions {
        static futureAccessList: Windows.Storage.AccessCache.StorageItemAccessList;
        static mostRecentlyUsedList: Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList;
    }

    export class StorageItemAccessList implements Windows.Storage.AccessCache.IStorageItemAccessList {
        add(file: Windows.Storage.IStorageItem): string;
        add(file: Windows.Storage.IStorageItem, metadata: string): string;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem): void;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem, metadata: string): void;
        getItemAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        remove(token: string): void;
        containsItem(token: string): boolean;
        clear(): void;
        checkAccess(file: Windows.Storage.IStorageItem): boolean;
        entries: Windows.Storage.AccessCache.AccessListEntryView;
        maximumItemsAllowed: number;
    }

    export class StorageItemMostRecentlyUsedList implements Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList, Windows.Storage.AccessCache.IStorageItemAccessList {
        add(file: Windows.Storage.IStorageItem): string;
        add(file: Windows.Storage.IStorageItem, metadata: string): string;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem): void;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem, metadata: string): void;
        getItemAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        remove(token: string): void;
        containsItem(token: string): boolean;
        clear(): void;
        checkAccess(file: Windows.Storage.IStorageItem): boolean;
        entries: Windows.Storage.AccessCache.AccessListEntryView;
        maximumItemsAllowed: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): void;
        removeEventListener(eventName: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): void;
        onitemremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>) => void;

    }

}
declare module Windows.Storage {

    export class ApplicationData implements Windows.Storage.IApplicationData {
        setVersionAsync(desiredVersion: number, handler: Windows.Storage.ApplicationDataSetVersionHandler): Windows.Foundation.IAsyncAction;
        clearAsync(): Windows.Foundation.IAsyncAction;
        clearAsync(locality: Windows.Storage.ApplicationDataLocality): Windows.Foundation.IAsyncAction;
        signalDataChanged(): void;
        localFolder: Windows.Storage.StorageFolder;
        localSettings: Windows.Storage.ApplicationDataContainer;
        roamingFolder: Windows.Storage.StorageFolder;
        roamingSettings: Windows.Storage.ApplicationDataContainer;
        roamingStorageQuota: number;
        temporaryFolder: Windows.Storage.StorageFolder;
        version: number;
        static current: Windows.Storage.ApplicationData;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): void;
        removeEventListener(eventName: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): void;
        ondatachanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>) => void;

    }

    export class ApplicationDataCompositeValue implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        constructor();
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    export class ApplicationDataContainer implements Windows.Storage.IApplicationDataContainer {
        createContainer(name: string, disposition: Windows.Storage.ApplicationDataCreateDisposition): Windows.Storage.ApplicationDataContainer;
        deleteContainer(name: string): void;
        containers: Windows.Foundation.Collections.IMapView<string,Windows.Storage.ApplicationDataContainer>;
        locality: Windows.Storage.ApplicationDataLocality;
        name: string;
        values: Windows.Foundation.Collections.IPropertySet;
    }

    export class ApplicationDataContainerSettings implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    enum ApplicationDataCreateDisposition {
        always,
        existing
    }

    enum ApplicationDataLocality {
        local,
        roaming,
        temporary
    }

    export interface ApplicationDataSetVersionHandler {
        target: Windows.Storage.SetVersionRequest;
        detail: any[];
        type: string;
    }

    export class CachedFileManager {
        static deferUpdates(file: Windows.Storage.IStorageFile): void;
        static completeUpdatesAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Storage.Provider.FileUpdateStatus>;
    }

    enum CreationCollisionOption {
        generateUniqueName,
        replaceExisting,
        failIfExists,
        openIfExists
    }

    export class DownloadsFolder {
        static createFileAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static createFolderAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        static createFileAsync(desiredName: string, option: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static createFolderAsync(desiredName: string, option: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
    }

    enum FileAccessMode {
        read,
        readWrite
    }

    enum FileAttributes {
        normal,
        readOnly,
        directory,
        archive,
        temporary
    }

    export class FileIO {
        static readTextAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<string>;
        static readTextAsync(file: Windows.Storage.IStorageFile, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncOperation<string>;
        static writeTextAsync(file: Windows.Storage.IStorageFile, contents: string): Windows.Foundation.IAsyncAction;
        static writeTextAsync(file: Windows.Storage.IStorageFile, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static appendTextAsync(file: Windows.Storage.IStorageFile, contents: string): Windows.Foundation.IAsyncAction;
        static appendTextAsync(file: Windows.Storage.IStorageFile, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static readLinesAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVector<string>>;
        static readLinesAsync(file: Windows.Storage.IStorageFile, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVector<string>>;
        static writeLinesAsync(file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncAction;
        static writeLinesAsync(file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static appendLinesAsync(file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncAction;
        static appendLinesAsync(file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static readBufferAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        static writeBufferAsync(file: Windows.Storage.IStorageFile, buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncAction;
        static writeBytesAsync(file: Windows.Storage.IStorageFile, buffer: any): Windows.Foundation.IAsyncAction;
    }

    export interface IApplicationData {
        setVersionAsync(desiredVersion: number, handler: Windows.Storage.ApplicationDataSetVersionHandler): Windows.Foundation.IAsyncAction;
        clearAsync(): Windows.Foundation.IAsyncAction;
        clearAsync(locality: Windows.Storage.ApplicationDataLocality): Windows.Foundation.IAsyncAction;
        signalDataChanged(): void;
        localFolder: Windows.Storage.StorageFolder;
        localSettings: Windows.Storage.ApplicationDataContainer;
        roamingFolder: Windows.Storage.StorageFolder;
        roamingSettings: Windows.Storage.ApplicationDataContainer;
        roamingStorageQuota: number;
        temporaryFolder: Windows.Storage.StorageFolder;
        version: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): void;
        removeEventListener(eventName: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): void;
        ondatachanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>) => void;

    }

    export interface IApplicationDataContainer {
        createContainer(name: string, disposition: Windows.Storage.ApplicationDataCreateDisposition): Windows.Storage.ApplicationDataContainer;
        deleteContainer(name: string): void;
        containers: Windows.Foundation.Collections.IMapView<string,Windows.Storage.ApplicationDataContainer>;
        locality: Windows.Storage.ApplicationDataLocality;
        name: string;
        values: Windows.Foundation.Collections.IPropertySet;
    }

    export interface ISetVersionDeferral {
        complete(): void;
    }

    export interface ISetVersionRequest {
        getDeferral(): Windows.Storage.SetVersionDeferral;
        currentVersion: number;
        desiredVersion: number;
    }

    export interface IStorageFile extends Windows.Storage.IStorageItem, Windows.Storage.Streams.IRandomAccessStreamReference, Windows.Storage.Streams.IInputStreamReference {
        openAsync(accessMode: Windows.Storage.FileAccessMode): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
        openTransactedWriteAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageStreamTransaction>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        moveAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        contentType: string;
        fileType: string;
    }

    export interface IStorageFolder extends Windows.Storage.IStorageItem {
        createFileAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFileAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFolderAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        createFolderAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getFileAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
    }

    export interface IStorageItem {
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
    }

    export interface IStorageItemProperties {
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
    }

    export interface IStorageStreamTransaction extends Windows.Foundation.IClosable {
        commitAsync(): Windows.Foundation.IAsyncAction;
        stream: Windows.Storage.Streams.IRandomAccessStream;
    }

    export interface IStreamedFileDataRequest {
        failAndClose(failureMode: Windows.Storage.StreamedFileFailureMode): void;
    }

    export class KnownFolders {
        static documentsLibrary: Windows.Storage.StorageFolder;
        static homeGroup: Windows.Storage.StorageFolder;
        static mediaServerDevices: Windows.Storage.StorageFolder;
        static musicLibrary: Windows.Storage.StorageFolder;
        static picturesLibrary: Windows.Storage.StorageFolder;
        static removableDevices: Windows.Storage.StorageFolder;
        static videosLibrary: Windows.Storage.StorageFolder;
    }

    enum NameCollisionOption {
        generateUniqueName,
        replaceExisting,
        failIfExists
    }

    export class PathIO {
        static readTextAsync(absolutePath: string): Windows.Foundation.IAsyncOperation<string>;
        static readTextAsync(absolutePath: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncOperation<string>;
        static writeTextAsync(absolutePath: string, contents: string): Windows.Foundation.IAsyncAction;
        static writeTextAsync(absolutePath: string, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static appendTextAsync(absolutePath: string, contents: string): Windows.Foundation.IAsyncAction;
        static appendTextAsync(absolutePath: string, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static readLinesAsync(absolutePath: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVector<string>>;
        static readLinesAsync(absolutePath: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVector<string>>;
        static writeLinesAsync(absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncAction;
        static writeLinesAsync(absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static appendLinesAsync(absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncAction;
        static appendLinesAsync(absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static readBufferAsync(absolutePath: string): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        static writeBufferAsync(absolutePath: string, buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncAction;
        static writeBytesAsync(absolutePath: string, buffer: any): Windows.Foundation.IAsyncAction;
    }

    export class SetVersionDeferral implements Windows.Storage.ISetVersionDeferral {
        complete(): void;
    }

    export class SetVersionRequest implements Windows.Storage.ISetVersionRequest {
        getDeferral(): Windows.Storage.SetVersionDeferral;
        currentVersion: number;
        desiredVersion: number;
    }

    enum StorageDeleteOption {
        default,
        permanentDelete
    }

    export class StorageFile implements Windows.Storage.IStorageFile, Windows.Storage.IStorageItem, Windows.Storage.Streams.IRandomAccessStreamReference, Windows.Storage.Streams.IInputStreamReference, Windows.Storage.IStorageItemProperties {
        openAsync(accessMode: Windows.Storage.FileAccessMode): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
        openTransactedWriteAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageStreamTransaction>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        moveAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        openReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        openSequentialReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IInputStream>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        static getFileFromPathAsync(path: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static getFileFromApplicationUriAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static createStreamedFileAsync(displayNameWithExtension: string, dataRequested: Windows.Storage.StreamedFileDataRequestedHandler, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static replaceWithStreamedFileAsync(fileToReplace: Windows.Storage.IStorageFile, dataRequested: Windows.Storage.StreamedFileDataRequestedHandler, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static createStreamedFileFromUriAsync(displayNameWithExtension: string, uri: Windows.Foundation.Uri, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static replaceWithStreamedFileFromUriAsync(fileToReplace: Windows.Storage.IStorageFile, uri: Windows.Foundation.Uri, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        contentType: string;
        fileType: string;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
    }

    export class StorageFolder implements Windows.Storage.IStorageFolder, Windows.Storage.IStorageItem, Windows.Storage.Search.IStorageFolderQueryOperations, Windows.Storage.IStorageItemProperties {
        createFileAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFileAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFolderAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        createFolderAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getFileAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        getIndexedStateAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Search.IndexedState>;
        createFileQuery(): Windows.Storage.Search.StorageFileQueryResult;
        createFileQuery(query: Windows.Storage.Search.CommonFileQuery): Windows.Storage.Search.StorageFileQueryResult;
        createFileQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFileQueryResult;
        createFolderQuery(): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQuery(query: Windows.Storage.Search.CommonFolderQuery): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFolderQueryResult;
        createItemQuery(): Windows.Storage.Search.StorageItemQueryResult;
        createItemQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageItemQueryResult;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        areQueryOptionsSupported(queryOptions: Windows.Storage.Search.QueryOptions): boolean;
        isCommonFolderQuerySupported(query: Windows.Storage.Search.CommonFolderQuery): boolean;
        isCommonFileQuerySupported(query: Windows.Storage.Search.CommonFileQuery): boolean;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        static getFolderFromPathAsync(path: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
    }

    enum StorageItemTypes {
        none,
        file,
        folder
    }

    export class StorageStreamTransaction implements Windows.Storage.IStorageStreamTransaction, Windows.Foundation.IClosable {
        commitAsync(): Windows.Foundation.IAsyncAction;
        close(): void;
        stream: Windows.Storage.Streams.IRandomAccessStream;
    }

    export class StreamedFileDataRequest implements Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable, Windows.Storage.IStreamedFileDataRequest {
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        close(): void;
        failAndClose(failureMode: Windows.Storage.StreamedFileFailureMode): void;
    }

    export interface StreamedFileDataRequestedHandler {
        target: Windows.Storage.StreamedFileDataRequest;
        detail: any[];
        type: string;
    }

    enum StreamedFileFailureMode {
        failed,
        currentlyUnavailable,
        incomplete
    }

}
declare module Windows.Storage.BulkAccess {

    export class FileInformation implements Windows.Storage.BulkAccess.IStorageItemInformation, Windows.Storage.IStorageFile, Windows.Storage.IStorageItem, Windows.Storage.Streams.IRandomAccessStreamReference, Windows.Storage.Streams.IInputStreamReference, Windows.Storage.IStorageItemProperties {
        openAsync(accessMode: Windows.Storage.FileAccessMode): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
        openTransactedWriteAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageStreamTransaction>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        moveAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        openReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        openSequentialReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IInputStream>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        basicProperties: Windows.Storage.FileProperties.BasicProperties;
        documentProperties: Windows.Storage.FileProperties.DocumentProperties;
        imageProperties: Windows.Storage.FileProperties.ImageProperties;
        musicProperties: Windows.Storage.FileProperties.MusicProperties;
        thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail;
        videoProperties: Windows.Storage.FileProperties.VideoProperties;
        contentType: string;
        fileType: string;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onpropertiesupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;
        addEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onthumbnailupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;

    }

    export class FileInformationFactory implements Windows.Storage.BulkAccess.IFileInformationFactory {
        constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode);
        constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number);
        constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: Windows.Storage.FileProperties.ThumbnailOptions);
        constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: Windows.Storage.FileProperties.ThumbnailOptions, delayLoad: boolean);
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.IStorageItemInformation>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.IStorageItemInformation>>;
        getFilesAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FileInformation>>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FileInformation>>;
        getFoldersAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FolderInformation>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FolderInformation>>;
        getVirtualizedItemsVector(): any;
        getVirtualizedFilesVector(): any;
        getVirtualizedFoldersVector(): any;
    }

    export class FolderInformation implements Windows.Storage.BulkAccess.IStorageItemInformation, Windows.Storage.IStorageFolder, Windows.Storage.IStorageItem, Windows.Storage.IStorageItemProperties, Windows.Storage.Search.IStorageFolderQueryOperations {
        createFileAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFileAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFolderAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        createFolderAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getFileAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getIndexedStateAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Search.IndexedState>;
        createFileQuery(): Windows.Storage.Search.StorageFileQueryResult;
        createFileQuery(query: Windows.Storage.Search.CommonFileQuery): Windows.Storage.Search.StorageFileQueryResult;
        createFileQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFileQueryResult;
        createFolderQuery(): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQuery(query: Windows.Storage.Search.CommonFolderQuery): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFolderQueryResult;
        createItemQuery(): Windows.Storage.Search.StorageItemQueryResult;
        createItemQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageItemQueryResult;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        areQueryOptionsSupported(queryOptions: Windows.Storage.Search.QueryOptions): boolean;
        isCommonFolderQuerySupported(query: Windows.Storage.Search.CommonFolderQuery): boolean;
        isCommonFileQuerySupported(query: Windows.Storage.Search.CommonFileQuery): boolean;
        basicProperties: Windows.Storage.FileProperties.BasicProperties;
        documentProperties: Windows.Storage.FileProperties.DocumentProperties;
        imageProperties: Windows.Storage.FileProperties.ImageProperties;
        musicProperties: Windows.Storage.FileProperties.MusicProperties;
        thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail;
        videoProperties: Windows.Storage.FileProperties.VideoProperties;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onpropertiesupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;
        addEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onthumbnailupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;

    }

    export interface IFileInformationFactory {
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.IStorageItemInformation>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.IStorageItemInformation>>;
        getFilesAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FileInformation>>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FileInformation>>;
        getFoldersAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FolderInformation>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FolderInformation>>;
        getVirtualizedItemsVector(): any;
        getVirtualizedFilesVector(): any;
        getVirtualizedFoldersVector(): any;
    }

    export interface IStorageItemInformation {
        basicProperties: Windows.Storage.FileProperties.BasicProperties;
        documentProperties: Windows.Storage.FileProperties.DocumentProperties;
        imageProperties: Windows.Storage.FileProperties.ImageProperties;
        musicProperties: Windows.Storage.FileProperties.MusicProperties;
        thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail;
        videoProperties: Windows.Storage.FileProperties.VideoProperties;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onpropertiesupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;
        addEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onthumbnailupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;

    }

}
declare module Windows.Storage.Compression {

    enum CompressAlgorithm {
        invalidAlgorithm,
        nullAlgorithm,
        mszip,
        xpress,
        xpressHuff,
        lzms
    }

    export class Compressor implements Windows.Storage.Compression.ICompressor, Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable {
        constructor(underlyingStream: Windows.Storage.Streams.IOutputStream);
        constructor(underlyingStream: Windows.Storage.Streams.IOutputStream, algorithm: Windows.Storage.Compression.CompressAlgorithm, blockSize: number);
        finishAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        detachStream(): Windows.Storage.Streams.IOutputStream;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        close(): void;
    }

    export class Decompressor implements Windows.Storage.Compression.IDecompressor, Windows.Storage.Streams.IInputStream, Windows.Foundation.IClosable {
        constructor(underlyingStream: Windows.Storage.Streams.IInputStream);
        detachStream(): Windows.Storage.Streams.IInputStream;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        close(): void;
    }

    export interface ICompressor extends Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable {
        finishAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        detachStream(): Windows.Storage.Streams.IOutputStream;
    }

    export interface IDecompressor extends Windows.Storage.Streams.IInputStream, Windows.Foundation.IClosable {
        detachStream(): Windows.Storage.Streams.IInputStream;
    }

}
declare module Windows.Storage.FileProperties {

    export class BasicProperties implements Windows.Storage.FileProperties.IBasicProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        dateModified: Date;
        itemDate: Date;
        size: number;
    }

    export class DocumentProperties implements Windows.Storage.FileProperties.IDocumentProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        author: Windows.Foundation.Collections.IVector<string>;
        comment: string;
        keywords: Windows.Foundation.Collections.IVector<string>;
        title: string;
    }

    export interface IBasicProperties {
        dateModified: Date;
        itemDate: Date;
        size: number;
    }

    export interface IDocumentProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        author: Windows.Foundation.Collections.IVector<string>;
        comment: string;
        keywords: Windows.Foundation.Collections.IVector<string>;
        title: string;
    }

    export interface IImageProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        cameraManufacturer: string;
        cameraModel: string;
        dateTaken: Date;
        height: number;
        keywords: Windows.Foundation.Collections.IVector<string>;
        latitude: Windows.Foundation.IReference<number>;
        longitude: Windows.Foundation.IReference<number>;
        orientation: Windows.Storage.FileProperties.PhotoOrientation;
        peopleNames: Windows.Foundation.Collections.IVectorView<string>;
        rating: number;
        title: string;
        width: number;
    }

    export class ImageProperties implements Windows.Storage.FileProperties.IImageProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        cameraManufacturer: string;
        cameraModel: string;
        dateTaken: Date;
        height: number;
        keywords: Windows.Foundation.Collections.IVector<string>;
        latitude: Windows.Foundation.IReference<number>;
        longitude: Windows.Foundation.IReference<number>;
        orientation: Windows.Storage.FileProperties.PhotoOrientation;
        peopleNames: Windows.Foundation.Collections.IVectorView<string>;
        rating: number;
        title: string;
        width: number;
    }

    export interface IMusicProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        album: string;
        albumArtist: string;
        artist: string;
        bitrate: number;
        composers: Windows.Foundation.Collections.IVector<string>;
        conductors: Windows.Foundation.Collections.IVector<string>;
        duration: Windows.Foundation.TimeSpan;
        genre: Windows.Foundation.Collections.IVector<string>;
        producers: Windows.Foundation.Collections.IVector<string>;
        publisher: string;
        rating: number;
        subtitle: string;
        title: string;
        trackNumber: number;
        writers: Windows.Foundation.Collections.IVector<string>;
        year: number;
    }

    export interface IStorageItemContentProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        getMusicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.MusicProperties>;
        getVideoPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.VideoProperties>;
        getImagePropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.ImageProperties>;
        getDocumentPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.DocumentProperties>;
    }

    export interface IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface IThumbnailProperties {
        originalHeight: number;
        originalWidth: number;
        returnedSmallerCachedSize: boolean;
        type: Windows.Storage.FileProperties.ThumbnailType;
    }

    export interface IVideoProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        bitrate: number;
        directors: Windows.Foundation.Collections.IVector<string>;
        duration: Windows.Foundation.TimeSpan;
        height: number;
        keywords: Windows.Foundation.Collections.IVector<string>;
        latitude: Windows.Foundation.IReference<number>;
        longitude: Windows.Foundation.IReference<number>;
        orientation: Windows.Storage.FileProperties.VideoOrientation;
        producers: Windows.Foundation.Collections.IVector<string>;
        publisher: string;
        rating: number;
        subtitle: string;
        title: string;
        width: number;
        writers: Windows.Foundation.Collections.IVector<string>;
        year: number;
    }

    export class MusicProperties implements Windows.Storage.FileProperties.IMusicProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        album: string;
        albumArtist: string;
        artist: string;
        bitrate: number;
        composers: Windows.Foundation.Collections.IVector<string>;
        conductors: Windows.Foundation.Collections.IVector<string>;
        duration: Windows.Foundation.TimeSpan;
        genre: Windows.Foundation.Collections.IVector<string>;
        producers: Windows.Foundation.Collections.IVector<string>;
        publisher: string;
        rating: number;
        subtitle: string;
        title: string;
        trackNumber: number;
        writers: Windows.Foundation.Collections.IVector<string>;
        year: number;
    }

    enum PhotoOrientation {
        unspecified,
        normal,
        flipHorizontal,
        rotate180,
        flipVertical,
        transpose,
        rotate270,
        transverse,
        rotate90
    }

    enum PropertyPrefetchOptions {
        none,
        musicProperties,
        videoProperties,
        imageProperties,
        documentProperties,
        basicProperties
    }

    export class StorageItemContentProperties implements Windows.Storage.FileProperties.IStorageItemContentProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        getMusicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.MusicProperties>;
        getVideoPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.VideoProperties>;
        getImagePropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.ImageProperties>;
        getDocumentPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.DocumentProperties>;
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
    }

    export class StorageItemThumbnail implements Windows.Storage.Streams.IRandomAccessStreamWithContentType, Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream, Windows.Storage.Streams.IContentTypeProvider, Windows.Storage.FileProperties.IThumbnailProperties {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
        contentType: string;
        originalHeight: number;
        originalWidth: number;
        returnedSmallerCachedSize: boolean;
        type: Windows.Storage.FileProperties.ThumbnailType;
    }

    enum ThumbnailMode {
        picturesView,
        videosView,
        musicView,
        documentsView,
        listView,
        singleItem
    }

    enum ThumbnailOptions {
        none,
        returnOnlyIfCached,
        resizeThumbnail,
        useCurrentScale
    }

    enum ThumbnailType {
        image,
        icon
    }

    enum VideoOrientation {
        normal,
        rotate90,
        rotate180,
        rotate270
    }

    export class VideoProperties implements Windows.Storage.FileProperties.IVideoProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        bitrate: number;
        directors: Windows.Foundation.Collections.IVector<string>;
        duration: Windows.Foundation.TimeSpan;
        height: number;
        keywords: Windows.Foundation.Collections.IVector<string>;
        latitude: Windows.Foundation.IReference<number>;
        longitude: Windows.Foundation.IReference<number>;
        orientation: Windows.Storage.FileProperties.VideoOrientation;
        producers: Windows.Foundation.Collections.IVector<string>;
        publisher: string;
        rating: number;
        subtitle: string;
        title: string;
        width: number;
        writers: Windows.Foundation.Collections.IVector<string>;
        year: number;
    }

}
declare module Windows.Storage.Pickers {

    export class FileExtensionVector implements Windows.Foundation.Collections.IVector<string>, Windows.Foundation.Collections.IIterable<string> {
        getAt(index: number): string;
        getView(): Windows.Foundation.Collections.IVectorView<string>;
        indexOf(value: string): FileExtensionVector_indexOf_OUT;
        setAt(index: number, value: string): void;
        insertAt(index: number, value: string): void;
        removeAt(index: number): void;
        append(value: string): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): FileExtensionVector_getMany_OUT;
        replaceAll(items: string[]): void;
        first(): Windows.Foundation.Collections.IIterator<string>;
        size: number;
    }

    interface FileExtensionVector_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface FileExtensionVector_getMany_OUT {
        __returnValue: number;
        items: string[];
    }

    export class FileOpenPicker implements Windows.Storage.Pickers.IFileOpenPicker {
        constructor();
        pickSingleFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        pickMultipleFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        commitButtonText: string;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        settingsIdentifier: string;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
        viewMode: Windows.Storage.Pickers.PickerViewMode;
    }

    export class FilePickerFileTypesOrderedMap implements Windows.Foundation.Collections.IMap<string,Windows.Foundation.Collections.IVector<string>>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Foundation.Collections.IVector<string>>> {
        lookup(key: string): Windows.Foundation.Collections.IVector<string>;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,Windows.Foundation.Collections.IVector<string>>;
        insert(key: string, value: Windows.Foundation.Collections.IVector<string>): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Foundation.Collections.IVector<string>>>;
        size: number;
    }

    export class FilePickerSelectedFilesArray implements Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>, Windows.Foundation.Collections.IIterable<Windows.Storage.StorageFile> {
        getAt(index: number): Windows.Storage.StorageFile;
        indexOf(value: Windows.Storage.StorageFile): FilePickerSelectedFilesArray_indexOf_OUT;
        getMany(startIndex: number): FilePickerSelectedFilesArray_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Storage.StorageFile>;
        size: number;
    }

    interface FilePickerSelectedFilesArray_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface FilePickerSelectedFilesArray_getMany_OUT {
        __returnValue: number;
        items: Windows.Storage.StorageFile[];
    }

    export class FileSavePicker implements Windows.Storage.Pickers.IFileSavePicker {
        constructor();
        pickSaveFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        commitButtonText: string;
        defaultFileExtension: string;
        fileTypeChoices: Windows.Foundation.Collections.IMap<string,Windows.Foundation.Collections.IVector<string>>;
        settingsIdentifier: string;
        suggestedFileName: string;
        suggestedSaveFile: Windows.Storage.StorageFile;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
    }

    export class FolderPicker implements Windows.Storage.Pickers.IFolderPicker {
        constructor();
        pickSingleFolderAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        commitButtonText: string;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        settingsIdentifier: string;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
        viewMode: Windows.Storage.Pickers.PickerViewMode;
    }

    export interface IFileOpenPicker {
        pickSingleFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        pickMultipleFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        commitButtonText: string;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        settingsIdentifier: string;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
        viewMode: Windows.Storage.Pickers.PickerViewMode;
    }

    export interface IFileSavePicker {
        pickSaveFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        commitButtonText: string;
        defaultFileExtension: string;
        fileTypeChoices: Windows.Foundation.Collections.IMap<string,Windows.Foundation.Collections.IVector<string>>;
        settingsIdentifier: string;
        suggestedFileName: string;
        suggestedSaveFile: Windows.Storage.StorageFile;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
    }

    export interface IFolderPicker {
        pickSingleFolderAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        commitButtonText: string;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        settingsIdentifier: string;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
        viewMode: Windows.Storage.Pickers.PickerViewMode;
    }

    enum PickerLocationId {
        documentsLibrary,
        computerFolder,
        desktop,
        downloads,
        homeGroup,
        musicLibrary,
        picturesLibrary,
        videosLibrary
    }

    enum PickerViewMode {
        list,
        thumbnail
    }

}
declare module Windows.Storage.Pickers.Provider {

    enum AddFileResult {
        added,
        alreadyAdded,
        notAllowed,
        unavailable
    }

    export class FileOpenPickerUI implements Windows.Storage.Pickers.Provider.IFileOpenPickerUI {
        addFile(id: string, file: Windows.Storage.IStorageFile): Windows.Storage.Pickers.Provider.AddFileResult;
        removeFile(id: string): void;
        containsFile(id: string): boolean;
        canAddFile(file: Windows.Storage.IStorageFile): boolean;
        allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
        selectionMode: Windows.Storage.Pickers.Provider.FileSelectionMode;
        settingsIdentifier: string;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): void;
        removeEventListener(eventName: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): void;
        onclosing: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>) => void;
        addEventListener(eventName: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): void;
        removeEventListener(eventName: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): void;
        onfileremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>) => void;

    }

    export class FileRemovedEventArgs implements Windows.Storage.Pickers.Provider.IFileRemovedEventArgs {
        id: string;
    }

    export class FileSavePickerUI implements Windows.Storage.Pickers.Provider.IFileSavePickerUI {
        trySetFileName(value: string): Windows.Storage.Pickers.Provider.SetFileNameResult;
        allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
        fileName: string;
        settingsIdentifier: string;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): void;
        removeEventListener(eventName: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): void;
        onfilenamechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>) => void;
        addEventListener(eventName: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): void;
        removeEventListener(eventName: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): void;
        ontargetfilerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>) => void;

    }

    enum FileSelectionMode {
        single,
        multiple
    }

    export interface IFileOpenPickerUI {
        addFile(id: string, file: Windows.Storage.IStorageFile): Windows.Storage.Pickers.Provider.AddFileResult;
        removeFile(id: string): void;
        containsFile(id: string): boolean;
        canAddFile(file: Windows.Storage.IStorageFile): boolean;
        allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
        selectionMode: Windows.Storage.Pickers.Provider.FileSelectionMode;
        settingsIdentifier: string;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): void;
        removeEventListener(eventName: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): void;
        onclosing: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>) => void;
        addEventListener(eventName: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): void;
        removeEventListener(eventName: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): void;
        onfileremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>) => void;

    }

    export interface IFileRemovedEventArgs {
        id: string;
    }

    export interface IFileSavePickerUI {
        trySetFileName(value: string): Windows.Storage.Pickers.Provider.SetFileNameResult;
        allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
        fileName: string;
        settingsIdentifier: string;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): void;
        removeEventListener(eventName: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): void;
        onfilenamechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>) => void;
        addEventListener(eventName: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): void;
        removeEventListener(eventName: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): void;
        ontargetfilerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>) => void;

    }

    export interface IPickerClosingDeferral {
        complete(): void;
    }

    export interface IPickerClosingEventArgs {
        closingOperation: Windows.Storage.Pickers.Provider.PickerClosingOperation;
        isCanceled: boolean;
    }

    export interface IPickerClosingOperation {
        getDeferral(): Windows.Storage.Pickers.Provider.PickerClosingDeferral;
        deadline: Date;
    }

    export interface ITargetFileRequest {
        getDeferral(): Windows.Storage.Pickers.Provider.TargetFileRequestDeferral;
        targetFile: Windows.Storage.IStorageFile;
    }

    export interface ITargetFileRequestDeferral {
        complete(): void;
    }

    export interface ITargetFileRequestedEventArgs {
        request: Windows.Storage.Pickers.Provider.TargetFileRequest;
    }

    export class PickerClosingDeferral implements Windows.Storage.Pickers.Provider.IPickerClosingDeferral {
        complete(): void;
    }

    export class PickerClosingEventArgs implements Windows.Storage.Pickers.Provider.IPickerClosingEventArgs {
        closingOperation: Windows.Storage.Pickers.Provider.PickerClosingOperation;
        isCanceled: boolean;
    }

    export class PickerClosingOperation implements Windows.Storage.Pickers.Provider.IPickerClosingOperation {
        getDeferral(): Windows.Storage.Pickers.Provider.PickerClosingDeferral;
        deadline: Date;
    }

    enum SetFileNameResult {
        succeeded,
        notAllowed,
        unavailable
    }

    export class TargetFileRequest implements Windows.Storage.Pickers.Provider.ITargetFileRequest {
        getDeferral(): Windows.Storage.Pickers.Provider.TargetFileRequestDeferral;
        targetFile: Windows.Storage.IStorageFile;
    }

    export class TargetFileRequestDeferral implements Windows.Storage.Pickers.Provider.ITargetFileRequestDeferral {
        complete(): void;
    }

    export class TargetFileRequestedEventArgs implements Windows.Storage.Pickers.Provider.ITargetFileRequestedEventArgs {
        request: Windows.Storage.Pickers.Provider.TargetFileRequest;
    }

}
declare module Windows.Storage.Provider {

    enum CachedFileOptions {
        none,
        requireUpdateOnAccess,
        useCachedFileWhenOffline,
        denyAccessWhenOffline
    }

    enum CachedFileTarget {
        local,
        remote
    }

    export class CachedFileUpdater {
        static setUpdateInformation(file: Windows.Storage.IStorageFile, contentId: string, readMode: Windows.Storage.Provider.ReadActivationMode, writeMode: Windows.Storage.Provider.WriteActivationMode, options: Windows.Storage.Provider.CachedFileOptions): void;
    }

    export class CachedFileUpdaterUI implements Windows.Storage.Provider.ICachedFileUpdaterUI {
        title: string;
        uIStatus: Windows.Storage.Provider.UIStatus;
        updateTarget: Windows.Storage.Provider.CachedFileTarget;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): void;
        removeEventListener(eventName: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): void;
        onfileupdaterequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>) => void;
        addEventListener(eventName: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): void;
        removeEventListener(eventName: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): void;
        onuirequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>) => void;

    }

    export class FileUpdateRequest implements Windows.Storage.Provider.IFileUpdateRequest {
        getDeferral(): Windows.Storage.Provider.FileUpdateRequestDeferral;
        updateLocalFile(value: Windows.Storage.IStorageFile): void;
        contentId: string;
        file: Windows.Storage.StorageFile;
        status: Windows.Storage.Provider.FileUpdateStatus;
    }

    export class FileUpdateRequestDeferral implements Windows.Storage.Provider.IFileUpdateRequestDeferral {
        complete(): void;
    }

    export class FileUpdateRequestedEventArgs implements Windows.Storage.Provider.IFileUpdateRequestedEventArgs {
        request: Windows.Storage.Provider.FileUpdateRequest;
    }

    enum FileUpdateStatus {
        incomplete,
        complete,
        userInputNeeded,
        currentlyUnavailable,
        failed,
        completeAndRenamed
    }

    export interface ICachedFileUpdaterUI {
        title: string;
        uIStatus: Windows.Storage.Provider.UIStatus;
        updateTarget: Windows.Storage.Provider.CachedFileTarget;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): void;
        removeEventListener(eventName: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): void;
        onfileupdaterequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>) => void;
        addEventListener(eventName: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): void;
        removeEventListener(eventName: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): void;
        onuirequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>) => void;

    }

    export interface IFileUpdateRequest {
        getDeferral(): Windows.Storage.Provider.FileUpdateRequestDeferral;
        updateLocalFile(value: Windows.Storage.IStorageFile): void;
        contentId: string;
        file: Windows.Storage.StorageFile;
        status: Windows.Storage.Provider.FileUpdateStatus;
    }

    export interface IFileUpdateRequestDeferral {
        complete(): void;
    }

    export interface IFileUpdateRequestedEventArgs {
        request: Windows.Storage.Provider.FileUpdateRequest;
    }

    enum ReadActivationMode {
        notNeeded,
        beforeAccess
    }

    enum UIStatus {
        unavailable,
        hidden,
        visible,
        complete
    }

    enum WriteActivationMode {
        readOnly,
        notNeeded,
        afterWrite
    }

}
declare module Windows.Storage.Search {

    enum CommonFileQuery {
        defaultQuery,
        orderByName,
        orderByTitle,
        orderByMusicProperties,
        orderBySearchRank,
        orderByDate
    }

    enum CommonFolderQuery {
        defaultQuery,
        groupByYear,
        groupByMonth,
        groupByArtist,
        groupByAlbum,
        groupByAlbumArtist,
        groupByComposer,
        groupByGenre,
        groupByPublishedYear,
        groupByRating,
        groupByTag,
        groupByAuthor,
        groupByType
    }

    enum DateStackOption {
        none,
        year,
        month
    }

    enum FolderDepth {
        shallow,
        deep
    }

    enum IndexedState {
        unknown,
        notIndexed,
        partiallyIndexed,
        fullyIndexed
    }

    enum IndexerOption {
        useIndexerWhenAvailable,
        onlyUseIndexer,
        doNotUseIndexer
    }

    export interface IQueryOptions {
        saveToString(): string;
        loadFromString(value: string): void;
        setThumbnailPrefetch(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): void;
        setPropertyPrefetch(options: Windows.Storage.FileProperties.PropertyPrefetchOptions, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): void;
        applicationSearchFilter: string;
        dateStackOption: Windows.Storage.Search.DateStackOption;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        folderDepth: Windows.Storage.Search.FolderDepth;
        groupPropertyName: string;
        indexerOption: Windows.Storage.Search.IndexerOption;
        language: string;
        sortOrder: Windows.Foundation.Collections.IVector<Windows.Storage.Search.SortEntry>;
        userSearchFilter: string;
    }

    export interface IStorageFileQueryResult extends Windows.Storage.Search.IStorageQueryResultBase {
        getFilesAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
    }

    export interface IStorageFolderQueryOperations {
        getIndexedStateAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Search.IndexedState>;
        createFileQuery(): Windows.Storage.Search.StorageFileQueryResult;
        createFileQuery(query: Windows.Storage.Search.CommonFileQuery): Windows.Storage.Search.StorageFileQueryResult;
        createFileQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFileQueryResult;
        createFolderQuery(): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQuery(query: Windows.Storage.Search.CommonFolderQuery): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFolderQueryResult;
        createItemQuery(): Windows.Storage.Search.StorageItemQueryResult;
        createItemQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageItemQueryResult;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        areQueryOptionsSupported(queryOptions: Windows.Storage.Search.QueryOptions): boolean;
        isCommonFolderQuerySupported(query: Windows.Storage.Search.CommonFolderQuery): boolean;
        isCommonFileQuerySupported(query: Windows.Storage.Search.CommonFileQuery): boolean;
    }

    export interface IStorageFolderQueryResult extends Windows.Storage.Search.IStorageQueryResultBase {
        getFoldersAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
    }

    export interface IStorageItemQueryResult extends Windows.Storage.Search.IStorageQueryResultBase {
        getItemsAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
    }

    export interface IStorageQueryResultBase {
        getItemCountAsync(): Windows.Foundation.IAsyncOperation<number>;
        findStartIndexAsync(value: any): Windows.Foundation.IAsyncOperation<number>;
        getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
        applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
        folder: Windows.Storage.StorageFolder;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        oncontentschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;
        addEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        onoptionschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;

    }

    export class QueryOptions implements Windows.Storage.Search.IQueryOptions {
        constructor(query: Windows.Storage.Search.CommonFileQuery, fileTypeFilter: Windows.Foundation.Collections.IIterable<string>);
        constructor(query: Windows.Storage.Search.CommonFolderQuery);
        constructor();
        saveToString(): string;
        loadFromString(value: string): void;
        setThumbnailPrefetch(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): void;
        setPropertyPrefetch(options: Windows.Storage.FileProperties.PropertyPrefetchOptions, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): void;
        applicationSearchFilter: string;
        dateStackOption: Windows.Storage.Search.DateStackOption;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        folderDepth: Windows.Storage.Search.FolderDepth;
        groupPropertyName: string;
        indexerOption: Windows.Storage.Search.IndexerOption;
        language: string;
        sortOrder: Windows.Foundation.Collections.IVector<Windows.Storage.Search.SortEntry>;
        userSearchFilter: string;
    }

    export class SortEntry {
        propertyName: string;
        ascendingOrder: boolean;
    }

    export class SortEntryVector implements Windows.Foundation.Collections.IVector<Windows.Storage.Search.SortEntry>, Windows.Foundation.Collections.IIterable<Windows.Storage.Search.SortEntry> {
        getAt(index: number): Windows.Storage.Search.SortEntry;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.Storage.Search.SortEntry>;
        indexOf(value: Windows.Storage.Search.SortEntry): SortEntryVector_indexOf_OUT;
        setAt(index: number, value: Windows.Storage.Search.SortEntry): void;
        insertAt(index: number, value: Windows.Storage.Search.SortEntry): void;
        removeAt(index: number): void;
        append(value: Windows.Storage.Search.SortEntry): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): SortEntryVector_getMany_OUT;
        replaceAll(items: Windows.Storage.Search.SortEntry[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Storage.Search.SortEntry>;
        size: number;
    }

    interface SortEntryVector_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface SortEntryVector_getMany_OUT {
        __returnValue: number;
        items: Windows.Storage.Search.SortEntry[];
    }

    export class StorageFileQueryResult implements Windows.Storage.Search.IStorageFileQueryResult, Windows.Storage.Search.IStorageQueryResultBase {
        getFilesAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getItemCountAsync(): Windows.Foundation.IAsyncOperation<number>;
        findStartIndexAsync(value: any): Windows.Foundation.IAsyncOperation<number>;
        getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
        applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
        folder: Windows.Storage.StorageFolder;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        oncontentschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;
        addEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        onoptionschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;

    }

    export class StorageFolderQueryResult implements Windows.Storage.Search.IStorageFolderQueryResult, Windows.Storage.Search.IStorageQueryResultBase {
        getFoldersAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemCountAsync(): Windows.Foundation.IAsyncOperation<number>;
        findStartIndexAsync(value: any): Windows.Foundation.IAsyncOperation<number>;
        getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
        applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
        folder: Windows.Storage.StorageFolder;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        oncontentschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;
        addEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        onoptionschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;

    }

    export class StorageItemQueryResult implements Windows.Storage.Search.IStorageItemQueryResult, Windows.Storage.Search.IStorageQueryResultBase {
        getItemsAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        getItemCountAsync(): Windows.Foundation.IAsyncOperation<number>;
        findStartIndexAsync(value: any): Windows.Foundation.IAsyncOperation<number>;
        getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
        applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
        folder: Windows.Storage.StorageFolder;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        oncontentschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;
        addEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        onoptionschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;

    }

}
declare module Windows.Storage.Streams {

    export class Buffer implements Windows.Storage.Streams.IBuffer {
        constructor(capacity: number);
        capacity: number;
        length: number;
    }

    enum ByteOrder {
        littleEndian,
        bigEndian
    }

    export class DataReader implements Windows.Storage.Streams.IDataReader, Windows.Foundation.IClosable {
        constructor(inputStream: Windows.Storage.Streams.IInputStream);
        readByte(): number;
        readBytes(): DataReader_readBytes_OUT;
        readBuffer(length: number): Windows.Storage.Streams.IBuffer;
        readBoolean(): boolean;
        readGuid(): string;
        readInt16(): number;
        readInt32(): number;
        readInt64(): number;
        readUInt16(): number;
        readUInt32(): number;
        readUInt64(): number;
        readSingle(): number;
        readDouble(): number;
        readString(codeUnitCount: number): string;
        readDateTime(): Date;
        readTimeSpan(): Windows.Foundation.TimeSpan;
        loadAsync(count: number): Windows.Storage.Streams.DataReaderLoadOperation;
        detachBuffer(): Windows.Storage.Streams.IBuffer;
        detachStream(): Windows.Storage.Streams.IInputStream;
        close(): void;
        static fromBuffer(buffer: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.DataReader;
        byteOrder: Windows.Storage.Streams.ByteOrder;
        inputStreamOptions: Windows.Storage.Streams.InputStreamOptions;
        unconsumedBufferLength: number;
        unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
    }

    interface DataReader_readBytes_OUT {
        value: any;
    }

    export class DataReaderLoadOperation implements Windows.Foundation.IAsyncOperation<number>, Windows.Foundation.IAsyncInfo {
        getResults(): number;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<number>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: number) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: number) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class DataWriter implements Windows.Storage.Streams.IDataWriter, Windows.Foundation.IClosable {
        constructor(outputStream: Windows.Storage.Streams.IOutputStream);
        constructor();
        writeByte(value: number): void;
        writeBytes(value: any): void;
        writeBuffer(buffer: Windows.Storage.Streams.IBuffer): void;
        writeBuffer(buffer: Windows.Storage.Streams.IBuffer, start: number, count: number): void;
        writeBoolean(value: boolean): void;
        writeGuid(value: string): void;
        writeInt16(value: number): void;
        writeInt32(value: number): void;
        writeInt64(value: number): void;
        writeUInt16(value: number): void;
        writeUInt32(value: number): void;
        writeUInt64(value: number): void;
        writeSingle(value: number): void;
        writeDouble(value: number): void;
        writeDateTime(value: Date): void;
        writeTimeSpan(value: Windows.Foundation.TimeSpan): void;
        writeString(value: string): number;
        measureString(value: string): number;
        storeAsync(): Windows.Storage.Streams.DataWriterStoreOperation;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        detachBuffer(): Windows.Storage.Streams.IBuffer;
        detachStream(): Windows.Storage.Streams.IOutputStream;
        close(): void;
        byteOrder: Windows.Storage.Streams.ByteOrder;
        unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
        unstoredBufferLength: number;
    }

    export class DataWriterStoreOperation implements Windows.Foundation.IAsyncOperation<number>, Windows.Foundation.IAsyncInfo {
        getResults(): number;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<number>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: number) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: number) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class FileInputStream implements Windows.Storage.Streams.IInputStream, Windows.Foundation.IClosable {
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        close(): void;
    }

    export class FileOutputStream implements Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable {
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        close(): void;
    }

    export class FileRandomAccessStream implements Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
    }

    export interface IBuffer {
        capacity: number;
        length: number;
    }

    export interface IBufferFactory {
        create(capacity: number): Windows.Storage.Streams.Buffer;
    }

    export interface IContentTypeProvider {
        contentType: string;
    }

    export interface IDataReader {
        readByte(): number;
        readBytes(): IDataReader_readBytes_OUT;
        readBuffer(length: number): Windows.Storage.Streams.IBuffer;
        readBoolean(): boolean;
        readGuid(): string;
        readInt16(): number;
        readInt32(): number;
        readInt64(): number;
        readUInt16(): number;
        readUInt32(): number;
        readUInt64(): number;
        readSingle(): number;
        readDouble(): number;
        readString(codeUnitCount: number): string;
        readDateTime(): Date;
        readTimeSpan(): Windows.Foundation.TimeSpan;
        loadAsync(count: number): Windows.Storage.Streams.DataReaderLoadOperation;
        detachBuffer(): Windows.Storage.Streams.IBuffer;
        detachStream(): Windows.Storage.Streams.IInputStream;
        byteOrder: Windows.Storage.Streams.ByteOrder;
        inputStreamOptions: Windows.Storage.Streams.InputStreamOptions;
        unconsumedBufferLength: number;
        unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
    }

    interface IDataReader_readBytes_OUT {
        value: any;
    }

    export interface IDataWriter {
        writeByte(value: number): void;
        writeBytes(value: any): void;
        writeBuffer(buffer: Windows.Storage.Streams.IBuffer): void;
        writeBuffer(buffer: Windows.Storage.Streams.IBuffer, start: number, count: number): void;
        writeBoolean(value: boolean): void;
        writeGuid(value: string): void;
        writeInt16(value: number): void;
        writeInt32(value: number): void;
        writeInt64(value: number): void;
        writeUInt16(value: number): void;
        writeUInt32(value: number): void;
        writeUInt64(value: number): void;
        writeSingle(value: number): void;
        writeDouble(value: number): void;
        writeDateTime(value: Date): void;
        writeTimeSpan(value: Windows.Foundation.TimeSpan): void;
        writeString(value: string): number;
        measureString(value: string): number;
        storeAsync(): Windows.Storage.Streams.DataWriterStoreOperation;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        detachBuffer(): Windows.Storage.Streams.IBuffer;
        detachStream(): Windows.Storage.Streams.IOutputStream;
        byteOrder: Windows.Storage.Streams.ByteOrder;
        unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
        unstoredBufferLength: number;
    }

    export interface IInputStream extends Windows.Foundation.IClosable {
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
    }

    export interface IInputStreamReference {
        openSequentialReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IInputStream>;
    }

    export class InMemoryRandomAccessStream implements Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream {
        constructor();
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
    }

    enum InputStreamOptions {
        none,
        partial,
        readAhead
    }

    export class InputStreamOverStream implements Windows.Storage.Streams.IInputStream, Windows.Foundation.IClosable {
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        close(): void;
    }

    export interface IOutputStream extends Windows.Foundation.IClosable {
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
    }

    export interface IRandomAccessStream extends Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
    }

    export interface IRandomAccessStreamReference {
        openReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
    }

    export interface IRandomAccessStreamWithContentType extends Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream, Windows.Storage.Streams.IContentTypeProvider {
    }

    export class OutputStreamOverStream implements Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable {
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        close(): void;
    }

    export class RandomAccessStream {
        static copyAsync(source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        static copyAsync(source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream, bytesToCopy: number): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        static copyAndCloseAsync(source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
    }

    export class RandomAccessStreamOverStream implements Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
    }

    export class RandomAccessStreamReference implements Windows.Storage.Streams.IRandomAccessStreamReference {
        openReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        static createFromFile(file: Windows.Storage.IStorageFile): Windows.Storage.Streams.RandomAccessStreamReference;
        static createFromUri(uri: Windows.Foundation.Uri): Windows.Storage.Streams.RandomAccessStreamReference;
        static createFromStream(stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Storage.Streams.RandomAccessStreamReference;
    }

    enum UnicodeEncoding {
        utf8,
        utf16LE,
        utf16BE
    }

}
declare module Windows.System.Display {

    export class DisplayRequest implements Windows.System.Display.IDisplayRequest {
        constructor();
        requestActive(): void;
        requestRelease(): void;
    }

    export interface IDisplayRequest {
        requestActive(): void;
        requestRelease(): void;
    }

}
declare module Windows.System {

    export interface ILauncherOptions {
        contentType: string;
        displayApplicationPicker: boolean;
        fallbackUri: Windows.Foundation.Uri;
        preferredApplicationDisplayName: string;
        preferredApplicationPackageFamilyName: string;
        treatAsUntrusted: boolean;
        ui: Windows.System.LauncherUIOptions;
    }

    export interface ILauncherUIOptions {
        invocationPoint: Windows.Foundation.IReference<Windows.Foundation.Point>;
        preferredPlacement: Windows.UI.Popups.Placement;
        selectionRect: Windows.Foundation.IReference<Windows.Foundation.Rect>;
    }

    export class Launcher {
        static launchFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<boolean>;
        static launchFileAsync(file: Windows.Storage.IStorageFile, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<boolean>;
        static launchUriAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<boolean>;
        static launchUriAsync(uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<boolean>;
    }

    export class LauncherOptions implements Windows.System.ILauncherOptions {
        constructor();
        contentType: string;
        displayApplicationPicker: boolean;
        fallbackUri: Windows.Foundation.Uri;
        preferredApplicationDisplayName: string;
        preferredApplicationPackageFamilyName: string;
        treatAsUntrusted: boolean;
        ui: Windows.System.LauncherUIOptions;
    }

    export class LauncherUIOptions implements Windows.System.ILauncherUIOptions {
        invocationPoint: Windows.Foundation.IReference<Windows.Foundation.Point>;
        preferredPlacement: Windows.UI.Popups.Placement;
        selectionRect: Windows.Foundation.IReference<Windows.Foundation.Rect>;
    }

    enum ProcessorArchitecture {
        x86,
        arm,
        x64,
        neutral,
        unknown
    }

    enum VirtualKey {
        none,
        leftButton,
        rightButton,
        cancel,
        middleButton,
        xButton1,
        xButton2,
        back,
        tab,
        clear,
        enter,
        shift,
        control,
        menu,
        pause,
        capitalLock,
        kana,
        hangul,
        junja,
        final,
        hanja,
        kanji,
        escape,
        convert,
        nonConvert,
        accept,
        modeChange,
        space,
        pageUp,
        pageDown,
        end,
        home,
        left,
        up,
        right,
        down,
        select,
        print,
        execute,
        snapshot,
        insert,
        delete,
        help,
        number0,
        number1,
        number2,
        number3,
        number4,
        number5,
        number6,
        number7,
        number8,
        number9,
        a,
        b,
        c,
        d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r,
        s,
        t,
        u,
        v,
        w,
        x,
        y,
        z,
        leftWindows,
        rightWindows,
        application,
        sleep,
        numberPad0,
        numberPad1,
        numberPad2,
        numberPad3,
        numberPad4,
        numberPad5,
        numberPad6,
        numberPad7,
        numberPad8,
        numberPad9,
        multiply,
        add,
        separator,
        subtract,
        decimal,
        divide,
        f1,
        f2,
        f3,
        f4,
        f5,
        f6,
        f7,
        f8,
        f9,
        f10,
        f11,
        f12,
        f13,
        f14,
        f15,
        f16,
        f17,
        f18,
        f19,
        f20,
        f21,
        f22,
        f23,
        f24,
        numberKeyLock,
        scroll,
        leftShift,
        rightShift,
        leftControl,
        rightControl,
        leftMenu,
        rightMenu
    }

    enum VirtualKeyModifiers {
        none,
        control,
        menu,
        shift,
        windows
    }

}
declare module Windows.System.Profile {

    export class HardwareIdentification {
        static getPackageSpecificToken(nonce: Windows.Storage.Streams.IBuffer): Windows.System.Profile.HardwareToken;
    }

    export class HardwareToken implements Windows.System.Profile.IHardwareToken {
        certificate: Windows.Storage.Streams.IBuffer;
        id: Windows.Storage.Streams.IBuffer;
        signature: Windows.Storage.Streams.IBuffer;
    }

    export interface IHardwareToken {
        certificate: Windows.Storage.Streams.IBuffer;
        id: Windows.Storage.Streams.IBuffer;
        signature: Windows.Storage.Streams.IBuffer;
    }

}
declare module Windows.System.RemoteDesktop {

    export class InteractiveSession {
        static isRemote: boolean;
    }

}
declare module Windows.System.Threading.Core {

    export interface IPreallocatedWorkItem {
        runAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface ISignalNotifier {
        enable(): void;
        terminate(): void;
    }

    export class PreallocatedWorkItem implements Windows.System.Threading.Core.IPreallocatedWorkItem {
        constructor(handler: Windows.System.Threading.WorkItemHandler);
        constructor(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority);
        constructor(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority, options: Windows.System.Threading.WorkItemOptions);
        runAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface SignalHandler {
        target: Windows.System.Threading.Core.SignalNotifier;
        detail: any[];
        type: string;
    }

    export class SignalNotifier implements Windows.System.Threading.Core.ISignalNotifier {
        enable(): void;
        terminate(): void;
        static attachToEvent(name: string, handler: Windows.System.Threading.Core.SignalHandler): Windows.System.Threading.Core.SignalNotifier;
        static attachToEvent(name: string, handler: Windows.System.Threading.Core.SignalHandler, timeout: Windows.Foundation.TimeSpan): Windows.System.Threading.Core.SignalNotifier;
        static attachToSemaphore(name: string, handler: Windows.System.Threading.Core.SignalHandler): Windows.System.Threading.Core.SignalNotifier;
        static attachToSemaphore(name: string, handler: Windows.System.Threading.Core.SignalHandler, timeout: Windows.Foundation.TimeSpan): Windows.System.Threading.Core.SignalNotifier;
    }

}
declare module Windows.System.Threading {

    export interface IThreadPoolTimer {
        cancel(): void;
        delay: Windows.Foundation.TimeSpan;
        period: Windows.Foundation.TimeSpan;
    }

    export class ThreadPool {
        static runAsync(handler: Windows.System.Threading.WorkItemHandler): Windows.Foundation.IAsyncAction;
        static runAsync(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority): Windows.Foundation.IAsyncAction;
        static runAsync(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority, options: Windows.System.Threading.WorkItemOptions): Windows.Foundation.IAsyncAction;
    }

    export class ThreadPoolTimer implements Windows.System.Threading.IThreadPoolTimer {
        cancel(): void;
        static createPeriodicTimer(handler: Windows.System.Threading.TimerElapsedHandler, period: Windows.Foundation.TimeSpan): Windows.System.Threading.ThreadPoolTimer;
        static createTimer(handler: Windows.System.Threading.TimerElapsedHandler, delay: Windows.Foundation.TimeSpan): Windows.System.Threading.ThreadPoolTimer;
        static createPeriodicTimer(handler: Windows.System.Threading.TimerElapsedHandler, period: Windows.Foundation.TimeSpan, destroyed: Windows.System.Threading.TimerDestroyedHandler): Windows.System.Threading.ThreadPoolTimer;
        static createTimer(handler: Windows.System.Threading.TimerElapsedHandler, delay: Windows.Foundation.TimeSpan, destroyed: Windows.System.Threading.TimerDestroyedHandler): Windows.System.Threading.ThreadPoolTimer;
        delay: Windows.Foundation.TimeSpan;
        period: Windows.Foundation.TimeSpan;
    }

    export interface TimerDestroyedHandler {
        target: Windows.System.Threading.ThreadPoolTimer;
        detail: any[];
        type: string;
    }

    export interface TimerElapsedHandler {
        target: Windows.System.Threading.ThreadPoolTimer;
        detail: any[];
        type: string;
    }

    export interface WorkItemHandler {
        target: Windows.Foundation.IAsyncAction;
        detail: any[];
        type: string;
    }

    enum WorkItemOptions {
        none,
        timeSliced
    }

    enum WorkItemPriority {
        low,
        normal,
        high
    }

}
declare module Windows.System.UserProfile {

    enum AccountPictureKind {
        smallImage,
        largeImage,
        video
    }

    export class GlobalizationPreferences {
        static calendars: Windows.Foundation.Collections.IVectorView<string>;
        static clocks: Windows.Foundation.Collections.IVectorView<string>;
        static currencies: Windows.Foundation.Collections.IVectorView<string>;
        static homeGeographicRegion: string;
        static languages: Windows.Foundation.Collections.IVectorView<string>;
        static weekStartsOn: Windows.Globalization.DayOfWeek;
    }

    export class LockScreen {
        static getImageStream(): Windows.Storage.Streams.IRandomAccessStream;
        static setImageFileAsync(value: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        static setImageStreamAsync(value: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        static originalImageFile: Windows.Foundation.Uri;
    }

    enum SetAccountPictureResult {
        success,
        changeDisabled,
        largeOrDynamicError,
        videoFrameSizeError,
        fileSizeError,
        failure
    }

    export class UserInformation {
        static getAccountPicture(kind: Windows.System.UserProfile.AccountPictureKind): Windows.Storage.IStorageFile;
        static setAccountPictureAsync(image: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPicturesAsync(smallImage: Windows.Storage.IStorageFile, largeImage: Windows.Storage.IStorageFile, video: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPictureFromStreamAsync(image: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPicturesFromStreamsAsync(smallImage: Windows.Storage.Streams.IRandomAccessStream, largeImage: Windows.Storage.Streams.IRandomAccessStream, video: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static getDisplayNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getFirstNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getLastNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getPrincipalNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getSessionInitiationProtocolUriAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Uri>;
        static getDomainNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static accountPictureChangeEnabled: boolean;
        static nameAccessAllowed: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "accountpicturechanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "accountpicturechanged", listener: Windows.Foundation.EventHandler<any>): void;
        onaccountpicturechanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

}
declare module Windows.UI.ApplicationSettings {

    export interface ISettingsPane {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): void;
        removeEventListener(eventName: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): void;
        oncommandsrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>) => void;

    }

    export interface ISettingsPaneCommandsRequest {
        applicationCommands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.SettingsCommand>;
    }

    export interface ISettingsPaneCommandsRequestedEventArgs {
        request: Windows.UI.ApplicationSettings.SettingsPaneCommandsRequest;
    }

    export class SettingsCommand implements Windows.UI.Popups.IUICommand {
        constructor(settingsCommandId: any, label: string, handler: Windows.UI.Popups.UICommandInvokedHandler);
        id: any;
        invoked: Windows.UI.Popups.UICommandInvokedHandler;
        label: string;
    }

    enum SettingsEdgeLocation {
        right,
        left
    }

    export class SettingsPane implements Windows.UI.ApplicationSettings.ISettingsPane {
        static getForCurrentView(): Windows.UI.ApplicationSettings.SettingsPane;
        static show(): void;
        static edge: Windows.UI.ApplicationSettings.SettingsEdgeLocation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): void;
        removeEventListener(eventName: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): void;
        oncommandsrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>) => void;

    }

    export class SettingsPaneCommandsRequest implements Windows.UI.ApplicationSettings.ISettingsPaneCommandsRequest {
        applicationCommands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.SettingsCommand>;
    }

    export class SettingsPaneCommandsRequestedEventArgs implements Windows.UI.ApplicationSettings.ISettingsPaneCommandsRequestedEventArgs {
        request: Windows.UI.ApplicationSettings.SettingsPaneCommandsRequest;
    }

}
declare module Windows.UI {

    export class Color {
        a: number;
        r: number;
        g: number;
        b: number;
    }

    export class ColorHelper implements Windows.UI.IColorHelper {
        static fromArgb(a: number, r: number, g: number, b: number): Windows.UI.Color;
    }

    export class Colors implements Windows.UI.IColors {
        static aliceBlue: Windows.UI.Color;
        static antiqueWhite: Windows.UI.Color;
        static aqua: Windows.UI.Color;
        static aquamarine: Windows.UI.Color;
        static azure: Windows.UI.Color;
        static beige: Windows.UI.Color;
        static bisque: Windows.UI.Color;
        static black: Windows.UI.Color;
        static blanchedAlmond: Windows.UI.Color;
        static blue: Windows.UI.Color;
        static blueViolet: Windows.UI.Color;
        static brown: Windows.UI.Color;
        static burlyWood: Windows.UI.Color;
        static cadetBlue: Windows.UI.Color;
        static chartreuse: Windows.UI.Color;
        static chocolate: Windows.UI.Color;
        static coral: Windows.UI.Color;
        static cornflowerBlue: Windows.UI.Color;
        static cornsilk: Windows.UI.Color;
        static crimson: Windows.UI.Color;
        static cyan: Windows.UI.Color;
        static darkBlue: Windows.UI.Color;
        static darkCyan: Windows.UI.Color;
        static darkGoldenrod: Windows.UI.Color;
        static darkGray: Windows.UI.Color;
        static darkGreen: Windows.UI.Color;
        static darkKhaki: Windows.UI.Color;
        static darkMagenta: Windows.UI.Color;
        static darkOliveGreen: Windows.UI.Color;
        static darkOrange: Windows.UI.Color;
        static darkOrchid: Windows.UI.Color;
        static darkRed: Windows.UI.Color;
        static darkSalmon: Windows.UI.Color;
        static darkSeaGreen: Windows.UI.Color;
        static darkSlateBlue: Windows.UI.Color;
        static darkSlateGray: Windows.UI.Color;
        static darkTurquoise: Windows.UI.Color;
        static darkViolet: Windows.UI.Color;
        static deepPink: Windows.UI.Color;
        static deepSkyBlue: Windows.UI.Color;
        static dimGray: Windows.UI.Color;
        static dodgerBlue: Windows.UI.Color;
        static firebrick: Windows.UI.Color;
        static floralWhite: Windows.UI.Color;
        static forestGreen: Windows.UI.Color;
        static fuchsia: Windows.UI.Color;
        static gainsboro: Windows.UI.Color;
        static ghostWhite: Windows.UI.Color;
        static gold: Windows.UI.Color;
        static goldenrod: Windows.UI.Color;
        static gray: Windows.UI.Color;
        static green: Windows.UI.Color;
        static greenYellow: Windows.UI.Color;
        static honeydew: Windows.UI.Color;
        static hotPink: Windows.UI.Color;
        static indianRed: Windows.UI.Color;
        static indigo: Windows.UI.Color;
        static ivory: Windows.UI.Color;
        static khaki: Windows.UI.Color;
        static lavender: Windows.UI.Color;
        static lavenderBlush: Windows.UI.Color;
        static lawnGreen: Windows.UI.Color;
        static lemonChiffon: Windows.UI.Color;
        static lightBlue: Windows.UI.Color;
        static lightCoral: Windows.UI.Color;
        static lightCyan: Windows.UI.Color;
        static lightGoldenrodYellow: Windows.UI.Color;
        static lightGray: Windows.UI.Color;
        static lightGreen: Windows.UI.Color;
        static lightPink: Windows.UI.Color;
        static lightSalmon: Windows.UI.Color;
        static lightSeaGreen: Windows.UI.Color;
        static lightSkyBlue: Windows.UI.Color;
        static lightSlateGray: Windows.UI.Color;
        static lightSteelBlue: Windows.UI.Color;
        static lightYellow: Windows.UI.Color;
        static lime: Windows.UI.Color;
        static limeGreen: Windows.UI.Color;
        static linen: Windows.UI.Color;
        static magenta: Windows.UI.Color;
        static maroon: Windows.UI.Color;
        static mediumAquamarine: Windows.UI.Color;
        static mediumBlue: Windows.UI.Color;
        static mediumOrchid: Windows.UI.Color;
        static mediumPurple: Windows.UI.Color;
        static mediumSeaGreen: Windows.UI.Color;
        static mediumSlateBlue: Windows.UI.Color;
        static mediumSpringGreen: Windows.UI.Color;
        static mediumTurquoise: Windows.UI.Color;
        static mediumVioletRed: Windows.UI.Color;
        static midnightBlue: Windows.UI.Color;
        static mintCream: Windows.UI.Color;
        static mistyRose: Windows.UI.Color;
        static moccasin: Windows.UI.Color;
        static navajoWhite: Windows.UI.Color;
        static navy: Windows.UI.Color;
        static oldLace: Windows.UI.Color;
        static olive: Windows.UI.Color;
        static oliveDrab: Windows.UI.Color;
        static orange: Windows.UI.Color;
        static orangeRed: Windows.UI.Color;
        static orchid: Windows.UI.Color;
        static paleGoldenrod: Windows.UI.Color;
        static paleGreen: Windows.UI.Color;
        static paleTurquoise: Windows.UI.Color;
        static paleVioletRed: Windows.UI.Color;
        static papayaWhip: Windows.UI.Color;
        static peachPuff: Windows.UI.Color;
        static peru: Windows.UI.Color;
        static pink: Windows.UI.Color;
        static plum: Windows.UI.Color;
        static powderBlue: Windows.UI.Color;
        static purple: Windows.UI.Color;
        static red: Windows.UI.Color;
        static rosyBrown: Windows.UI.Color;
        static royalBlue: Windows.UI.Color;
        static saddleBrown: Windows.UI.Color;
        static salmon: Windows.UI.Color;
        static sandyBrown: Windows.UI.Color;
        static seaGreen: Windows.UI.Color;
        static seaShell: Windows.UI.Color;
        static sienna: Windows.UI.Color;
        static silver: Windows.UI.Color;
        static skyBlue: Windows.UI.Color;
        static slateBlue: Windows.UI.Color;
        static slateGray: Windows.UI.Color;
        static snow: Windows.UI.Color;
        static springGreen: Windows.UI.Color;
        static steelBlue: Windows.UI.Color;
        static tan: Windows.UI.Color;
        static teal: Windows.UI.Color;
        static thistle: Windows.UI.Color;
        static tomato: Windows.UI.Color;
        static transparent: Windows.UI.Color;
        static turquoise: Windows.UI.Color;
        static violet: Windows.UI.Color;
        static wheat: Windows.UI.Color;
        static white: Windows.UI.Color;
        static whiteSmoke: Windows.UI.Color;
        static yellow: Windows.UI.Color;
        static yellowGreen: Windows.UI.Color;
    }

    export interface IColorHelper {
    }

    export interface IColors {
    }

}
declare module Windows.UI.Core {

    export class AcceleratorKeyEventArgs implements Windows.UI.Core.IAcceleratorKeyEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        eventType: Windows.UI.Core.CoreAcceleratorKeyEventType;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        virtualKey: Windows.System.VirtualKey;
        handled: boolean;
    }

    export class AutomationProviderRequestedEventArgs implements Windows.UI.Core.IAutomationProviderRequestedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        automationProvider: any;
        handled: boolean;
    }

    export class CharacterReceivedEventArgs implements Windows.UI.Core.ICharacterReceivedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        keyCode: number;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        handled: boolean;
    }

    enum CoreAcceleratorKeyEventType {
        keyDown,
        keyUp,
        character,
        deadCharacter,
        systemKeyDown,
        systemKeyUp,
        systemCharacter,
        systemDeadCharacter,
        unicodeCharacter
    }

    export class CoreAcceleratorKeys implements Windows.UI.Core.ICoreAcceleratorKeys {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        removeEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        onacceleratorkeyactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>) => void;

    }

    export class CoreCursor implements Windows.UI.Core.ICoreCursor {
        constructor(type: Windows.UI.Core.CoreCursorType, id: number);
        id: number;
        type: Windows.UI.Core.CoreCursorType;
    }

    enum CoreCursorType {
        arrow,
        cross,
        custom,
        hand,
        help,
        iBeam,
        sizeAll,
        sizeNortheastSouthwest,
        sizeNorthSouth,
        sizeNorthwestSoutheast,
        sizeWestEast,
        universalNo,
        upArrow,
        wait
    }

    export class CoreDispatcher implements Windows.UI.Core.ICoreDispatcher, Windows.UI.Core.ICoreAcceleratorKeys {
        processEvents(options: Windows.UI.Core.CoreProcessEventsOption): void;
        runAsync(priority: Windows.UI.Core.CoreDispatcherPriority, agileCallback: Windows.UI.Core.DispatchedHandler): Windows.Foundation.IAsyncAction;
        runIdleAsync(agileCallback: Windows.UI.Core.IdleDispatchedHandler): Windows.Foundation.IAsyncAction;
        hasThreadAccess: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        removeEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        onacceleratorkeyactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>) => void;

    }

    enum CoreDispatcherPriority {
        low,
        normal,
        high
    }

    export class CorePhysicalKeyStatus {
        repeatCount: number;
        scanCode: number;
        isExtendedKey: boolean;
        isMenuKeyDown: boolean;
        wasKeyDown: boolean;
        isKeyReleased: boolean;
    }

    enum CoreProcessEventsOption {
        processOneAndAllPending,
        processOneIfPresent,
        processUntilQuit,
        processAllIfPresent
    }

    export class CoreProximityEvaluation {
        score: number;
        adjustedPoint: Windows.Foundation.Point;
    }

    enum CoreProximityEvaluationScore {
        closest,
        farthest
    }

    enum CoreVirtualKeyStates {
        none,
        down,
        locked
    }

    export class CoreWindow implements Windows.UI.Core.ICoreWindow {
        activate(): void;
        close(): void;
        getAsyncKeyState(virtualKey: Windows.System.VirtualKey): Windows.UI.Core.CoreVirtualKeyStates;
        getKeyState(virtualKey: Windows.System.VirtualKey): Windows.UI.Core.CoreVirtualKeyStates;
        releasePointerCapture(): void;
        setPointerCapture(): void;
        static getForCurrentThread(): Windows.UI.Core.CoreWindow;
        automationHostProvider: any;
        bounds: Windows.Foundation.Rect;
        customProperties: Windows.Foundation.Collections.IPropertySet;
        dispatcher: Windows.UI.Core.CoreDispatcher;
        flowDirection: Windows.UI.Core.CoreWindowFlowDirection;
        isInputEnabled: boolean;
        pointerCursor: Windows.UI.Core.CoreCursor;
        pointerPosition: Windows.Foundation.Point;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>) => void;
        addEventListener(eventName: "automationproviderrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): void;
        removeEventListener(eventName: "automationproviderrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): void;
        onautomationproviderrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>) => void;
        addEventListener(eventName: "characterreceived", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): void;
        removeEventListener(eventName: "characterreceived", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): void;
        oncharacterreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>) => void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>) => void;
        addEventListener(eventName: "inputenabled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): void;
        removeEventListener(eventName: "inputenabled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): void;
        oninputenabled: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>) => void;
        addEventListener(eventName: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        removeEventListener(eventName: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        onkeydown: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>) => void;
        addEventListener(eventName: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        removeEventListener(eventName: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        onkeyup: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>) => void;
        addEventListener(eventName: "pointercapturelost", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointercapturelost", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointercapturelost: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerentered", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerentered", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerentered: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerexited", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerexited", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerexited: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointermoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointermoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointermoved: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerpressed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerpressed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerpressed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerreleased", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerreleased", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerreleased: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerwheelchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerwheelchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerwheelchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "sizechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): void;
        removeEventListener(eventName: "sizechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): void;
        onsizechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>) => void;
        addEventListener(eventName: "touchhittesting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): void;
        removeEventListener(eventName: "touchhittesting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): void;
        ontouchhittesting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): void;
        onvisibilitychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>) => void;

    }

    enum CoreWindowActivationState {
        codeActivated,
        deactivated,
        pointerActivated
    }

    export class CoreWindowDialog implements Windows.UI.Core.ICoreWindowDialog {
        constructor(title: string);
        constructor();
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        backButtonCommand: Windows.UI.Popups.UICommandInvokedHandler;
        cancelCommandIndex: number;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        defaultCommandIndex: number;
        isInteractionDelayed: number;
        maxSize: Windows.Foundation.Size;
        minSize: Windows.Foundation.Size;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>) => void;

    }

    export class CoreWindowEventArgs implements Windows.UI.Core.ICoreWindowEventArgs {
        handled: boolean;
    }

    enum CoreWindowFlowDirection {
        leftToRight,
        rightToLeft
    }

    export class CoreWindowFlyout implements Windows.UI.Core.ICoreWindowFlyout {
        constructor(position: Windows.Foundation.Point);
        constructor(position: Windows.Foundation.Point, title: string);
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        backButtonCommand: Windows.UI.Popups.UICommandInvokedHandler;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        defaultCommandIndex: number;
        isInteractionDelayed: number;
        maxSize: Windows.Foundation.Size;
        minSize: Windows.Foundation.Size;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>) => void;

    }

    export class CoreWindowPopupShowingEventArgs implements Windows.UI.Core.ICoreWindowPopupShowingEventArgs {
        setDesiredSize(value: Windows.Foundation.Size): void;
    }

    export class CoreWindowResizeManager implements Windows.UI.Core.ICoreWindowResizeManager {
        notifyLayoutCompleted(): void;
        static getForCurrentView(): Windows.UI.Core.CoreWindowResizeManager;
    }

    export interface DispatchedHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface IAcceleratorKeyEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        eventType: Windows.UI.Core.CoreAcceleratorKeyEventType;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        virtualKey: Windows.System.VirtualKey;
    }

    export interface IAutomationProviderRequestedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        automationProvider: any;
    }

    export interface ICharacterReceivedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        keyCode: number;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
    }

    export interface ICoreAcceleratorKeys {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        removeEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        onacceleratorkeyactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>) => void;

    }

    export interface ICoreCursor {
        id: number;
        type: Windows.UI.Core.CoreCursorType;
    }

    export interface ICoreDispatcher extends Windows.UI.Core.ICoreAcceleratorKeys {
        processEvents(options: Windows.UI.Core.CoreProcessEventsOption): void;
        runAsync(priority: Windows.UI.Core.CoreDispatcherPriority, agileCallback: Windows.UI.Core.DispatchedHandler): Windows.Foundation.IAsyncAction;
        runIdleAsync(agileCallback: Windows.UI.Core.IdleDispatchedHandler): Windows.Foundation.IAsyncAction;
        hasThreadAccess: boolean;
    }

    export interface ICoreWindow {
        activate(): void;
        close(): void;
        getAsyncKeyState(virtualKey: Windows.System.VirtualKey): Windows.UI.Core.CoreVirtualKeyStates;
        getKeyState(virtualKey: Windows.System.VirtualKey): Windows.UI.Core.CoreVirtualKeyStates;
        releasePointerCapture(): void;
        setPointerCapture(): void;
        automationHostProvider: any;
        bounds: Windows.Foundation.Rect;
        customProperties: Windows.Foundation.Collections.IPropertySet;
        dispatcher: Windows.UI.Core.CoreDispatcher;
        flowDirection: Windows.UI.Core.CoreWindowFlowDirection;
        isInputEnabled: boolean;
        pointerCursor: Windows.UI.Core.CoreCursor;
        pointerPosition: Windows.Foundation.Point;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>) => void;
        addEventListener(eventName: "automationproviderrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): void;
        removeEventListener(eventName: "automationproviderrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): void;
        onautomationproviderrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>) => void;
        addEventListener(eventName: "characterreceived", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): void;
        removeEventListener(eventName: "characterreceived", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): void;
        oncharacterreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>) => void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>) => void;
        addEventListener(eventName: "inputenabled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): void;
        removeEventListener(eventName: "inputenabled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): void;
        oninputenabled: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>) => void;
        addEventListener(eventName: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        removeEventListener(eventName: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        onkeydown: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>) => void;
        addEventListener(eventName: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        removeEventListener(eventName: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        onkeyup: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>) => void;
        addEventListener(eventName: "pointercapturelost", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointercapturelost", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointercapturelost: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerentered", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerentered", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerentered: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerexited", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerexited", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerexited: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointermoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointermoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointermoved: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerpressed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerpressed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerpressed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerreleased", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerreleased", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerreleased: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerwheelchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerwheelchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerwheelchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "sizechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): void;
        removeEventListener(eventName: "sizechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): void;
        onsizechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>) => void;
        addEventListener(eventName: "touchhittesting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): void;
        removeEventListener(eventName: "touchhittesting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): void;
        ontouchhittesting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): void;
        onvisibilitychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>) => void;

    }

    export interface ICoreWindowDialog {
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        backButtonCommand: Windows.UI.Popups.UICommandInvokedHandler;
        cancelCommandIndex: number;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        defaultCommandIndex: number;
        isInteractionDelayed: number;
        maxSize: Windows.Foundation.Size;
        minSize: Windows.Foundation.Size;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>) => void;

    }

    export interface ICoreWindowEventArgs {
        handled: boolean;
    }

    export interface ICoreWindowFlyout {
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        backButtonCommand: Windows.UI.Popups.UICommandInvokedHandler;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        defaultCommandIndex: number;
        isInteractionDelayed: number;
        maxSize: Windows.Foundation.Size;
        minSize: Windows.Foundation.Size;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>) => void;

    }

    export interface ICoreWindowPopupShowingEventArgs {
        setDesiredSize(value: Windows.Foundation.Size): void;
    }

    export interface ICoreWindowResizeManager {
        notifyLayoutCompleted(): void;
    }

    export interface IdleDispatchedHandler {
        target: Windows.UI.Core.IdleDispatchedHandlerArgs;
        detail: any[];
        type: string;
    }

    export class IdleDispatchedHandlerArgs implements Windows.UI.Core.IIdleDispatchedHandlerArgs {
        isDispatcherIdle: boolean;
    }

    export interface IIdleDispatchedHandlerArgs {
        isDispatcherIdle: boolean;
    }

    export interface IInitializeWithCoreWindow {
        initialize(window: Windows.UI.Core.CoreWindow): void;
    }

    export interface IInputEnabledEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        inputEnabled: boolean;
    }

    export interface IKeyEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        virtualKey: Windows.System.VirtualKey;
    }

    export class InputEnabledEventArgs implements Windows.UI.Core.IInputEnabledEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        inputEnabled: boolean;
        handled: boolean;
    }

    export interface IPointerEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        getIntermediatePoints(): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        currentPoint: Windows.UI.Input.PointerPoint;
        keyModifiers: Windows.System.VirtualKeyModifiers;
    }

    export interface ITouchHitTestingEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        evaluateProximity(controlBoundingBox: Windows.Foundation.Rect): Windows.UI.Core.CoreProximityEvaluation;
        evaluateProximity(controlVertices: Windows.Foundation.Point[]): Windows.UI.Core.CoreProximityEvaluation;
        boundingBox: Windows.Foundation.Rect;
        point: Windows.Foundation.Point;
        proximityEvaluation: Windows.UI.Core.CoreProximityEvaluation;
    }

    export interface IVisibilityChangedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        visible: boolean;
    }

    export interface IWindowActivatedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        windowActivationState: Windows.UI.Core.CoreWindowActivationState;
    }

    export interface IWindowSizeChangedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        size: Windows.Foundation.Size;
    }

    export class KeyEventArgs implements Windows.UI.Core.IKeyEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        virtualKey: Windows.System.VirtualKey;
        handled: boolean;
    }

    export class PointerEventArgs implements Windows.UI.Core.IPointerEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        getIntermediatePoints(): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        currentPoint: Windows.UI.Input.PointerPoint;
        keyModifiers: Windows.System.VirtualKeyModifiers;
        handled: boolean;
    }

    export class TouchHitTestingEventArgs implements Windows.UI.Core.ITouchHitTestingEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        evaluateProximity(controlBoundingBox: Windows.Foundation.Rect): Windows.UI.Core.CoreProximityEvaluation;
        evaluateProximity(controlVertices: Windows.Foundation.Point[]): Windows.UI.Core.CoreProximityEvaluation;
        boundingBox: Windows.Foundation.Rect;
        point: Windows.Foundation.Point;
        proximityEvaluation: Windows.UI.Core.CoreProximityEvaluation;
        handled: boolean;
    }

    export class VisibilityChangedEventArgs implements Windows.UI.Core.IVisibilityChangedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        visible: boolean;
        handled: boolean;
    }

    export class WindowActivatedEventArgs implements Windows.UI.Core.IWindowActivatedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        windowActivationState: Windows.UI.Core.CoreWindowActivationState;
        handled: boolean;
    }

    export class WindowSizeChangedEventArgs implements Windows.UI.Core.IWindowSizeChangedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        size: Windows.Foundation.Size;
        handled: boolean;
    }

}
declare module Windows.UI.Core.AnimationMetrics {

    export class AnimationDescription implements Windows.UI.Core.AnimationMetrics.IAnimationDescription {
        constructor(effect: Windows.UI.Core.AnimationMetrics.AnimationEffect, target: Windows.UI.Core.AnimationMetrics.AnimationEffectTarget);
        animations: Windows.Foundation.Collections.IVectorView<Windows.UI.Core.AnimationMetrics.IPropertyAnimation>;
        delayLimit: Windows.Foundation.TimeSpan;
        staggerDelay: Windows.Foundation.TimeSpan;
        staggerDelayFactor: number;
        zOrder: number;
    }

    enum AnimationEffect {
        expand,
        collapse,
        reposition,
        fadeIn,
        fadeOut,
        addToList,
        deleteFromList,
        addToGrid,
        deleteFromGrid,
        addToSearchGrid,
        deleteFromSearchGrid,
        addToSearchList,
        deleteFromSearchList,
        showEdgeUI,
        showPanel,
        hideEdgeUI,
        hidePanel,
        showPopup,
        hidePopup,
        pointerDown,
        pointerUp,
        dragSourceStart,
        dragSourceEnd,
        transitionContent,
        reveal,
        hide,
        dragBetweenEnter,
        dragBetweenLeave,
        swipeSelect,
        swipeDeselect,
        swipeReveal,
        enterPage,
        transitionPage,
        crossFade,
        peek,
        updateBadge
    }

    enum AnimationEffectTarget {
        primary,
        added,
        affected,
        background,
        content,
        deleted,
        deselected,
        dragSource,
        hidden,
        incoming,
        outgoing,
        outline,
        remaining,
        revealed,
        rowIn,
        rowOut,
        selected,
        selection,
        shown,
        tapped
    }

    export interface IAnimationDescription {
        animations: Windows.Foundation.Collections.IVectorView<Windows.UI.Core.AnimationMetrics.IPropertyAnimation>;
        delayLimit: Windows.Foundation.TimeSpan;
        staggerDelay: Windows.Foundation.TimeSpan;
        staggerDelayFactor: number;
        zOrder: number;
    }

    export interface IOpacityAnimation extends Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        finalOpacity: number;
        initialOpacity: Windows.Foundation.IReference<number>;
    }

    export interface IPropertyAnimation {
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

    export interface IScaleAnimation extends Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        finalScaleX: number;
        finalScaleY: number;
        initialScaleX: Windows.Foundation.IReference<number>;
        initialScaleY: Windows.Foundation.IReference<number>;
        normalizedOrigin: Windows.Foundation.Point;
    }

    export class OpacityAnimation implements Windows.UI.Core.AnimationMetrics.IOpacityAnimation, Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        finalOpacity: number;
        initialOpacity: Windows.Foundation.IReference<number>;
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

    export class PropertyAnimation implements Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

    enum PropertyAnimationType {
        scale,
        translation,
        opacity
    }

    export class ScaleAnimation implements Windows.UI.Core.AnimationMetrics.IScaleAnimation, Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        finalScaleX: number;
        finalScaleY: number;
        initialScaleX: Windows.Foundation.IReference<number>;
        initialScaleY: Windows.Foundation.IReference<number>;
        normalizedOrigin: Windows.Foundation.Point;
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

    export class TranslationAnimation implements Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

}
declare module Windows.UI.Input {

    export class CrossSlideThresholds {
        selectionStart: number;
        speedBumpStart: number;
        speedBumpEnd: number;
        rearrangeStart: number;
    }

    export class CrossSlidingEventArgs implements Windows.UI.Input.ICrossSlidingEventArgs {
        crossSlidingState: Windows.UI.Input.CrossSlidingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    enum CrossSlidingState {
        started,
        dragging,
        selecting,
        selectSpeedBumping,
        speedBumping,
        rearranging,
        completed
    }

    export class DraggingEventArgs implements Windows.UI.Input.IDraggingEventArgs {
        draggingState: Windows.UI.Input.DraggingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    enum DraggingState {
        started,
        continuing,
        completed
    }

    export class EdgeGesture implements Windows.UI.Input.IEdgeGesture {
        static getForCurrentView(): Windows.UI.Input.EdgeGesture;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        oncanceled: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        oncompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;
        addEventListener(eventName: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        onstarting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;

    }

    export class EdgeGestureEventArgs implements Windows.UI.Input.IEdgeGestureEventArgs {
        kind: Windows.UI.Input.EdgeGestureKind;
    }

    enum EdgeGestureKind {
        touch,
        keyboard,
        mouse
    }

    export class GestureRecognizer implements Windows.UI.Input.IGestureRecognizer {
        constructor();
        canBeDoubleTap(value: Windows.UI.Input.PointerPoint): boolean;
        processDownEvent(value: Windows.UI.Input.PointerPoint): void;
        processMoveEvents(value: Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>): void;
        processUpEvent(value: Windows.UI.Input.PointerPoint): void;
        processMouseWheelEvent(value: Windows.UI.Input.PointerPoint, isShiftKeyDown: boolean, isControlKeyDown: boolean): void;
        processInertia(): void;
        completeGesture(): void;
        autoProcessInertia: boolean;
        crossSlideExact: boolean;
        crossSlideHorizontally: boolean;
        crossSlideThresholds: Windows.UI.Input.CrossSlideThresholds;
        gestureSettings: Windows.UI.Input.GestureSettings;
        inertiaExpansion: number;
        inertiaExpansionDeceleration: number;
        inertiaRotationAngle: number;
        inertiaRotationDeceleration: number;
        inertiaTranslationDeceleration: number;
        inertiaTranslationDisplacement: number;
        isActive: boolean;
        isInertial: boolean;
        manipulationExact: boolean;
        mouseWheelParameters: Windows.UI.Input.MouseWheelParameters;
        pivotCenter: Windows.Foundation.Point;
        pivotRadius: number;
        showGestureFeedback: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): void;
        removeEventListener(eventName: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): void;
        oncrosssliding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>) => void;
        addEventListener(eventName: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): void;
        removeEventListener(eventName: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): void;
        ondragging: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>) => void;
        addEventListener(eventName: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): void;
        removeEventListener(eventName: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): void;
        onholding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>) => void;
        addEventListener(eventName: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): void;
        removeEventListener(eventName: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): void;
        onmanipulationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>) => void;
        addEventListener(eventName: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): void;
        removeEventListener(eventName: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): void;
        onmanipulationinertiastarting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>) => void;
        addEventListener(eventName: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): void;
        removeEventListener(eventName: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): void;
        onmanipulationstarted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>) => void;
        addEventListener(eventName: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): void;
        removeEventListener(eventName: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): void;
        onmanipulationupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>) => void;
        addEventListener(eventName: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): void;
        removeEventListener(eventName: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): void;
        onrighttapped: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>) => void;
        addEventListener(eventName: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): void;
        removeEventListener(eventName: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): void;
        ontapped: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>) => void;

    }

    enum GestureSettings {
        none,
        tap,
        doubleTap,
        hold,
        holdWithMouse,
        rightTap,
        drag,
        manipulationTranslateX,
        manipulationTranslateY,
        manipulationTranslateRailsX,
        manipulationTranslateRailsY,
        manipulationRotate,
        manipulationScale,
        manipulationTranslateInertia,
        manipulationRotateInertia,
        manipulationScaleInertia,
        crossSlide
    }

    export class HoldingEventArgs implements Windows.UI.Input.IHoldingEventArgs {
        holdingState: Windows.UI.Input.HoldingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    enum HoldingState {
        started,
        completed,
        canceled
    }

    export interface ICrossSlidingEventArgs {
        crossSlidingState: Windows.UI.Input.CrossSlidingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IDraggingEventArgs {
        draggingState: Windows.UI.Input.DraggingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IEdgeGesture {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        oncanceled: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        oncompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;
        addEventListener(eventName: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        onstarting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;

    }

    export interface IEdgeGestureEventArgs {
        kind: Windows.UI.Input.EdgeGestureKind;
    }

    export interface IGestureRecognizer {
        canBeDoubleTap(value: Windows.UI.Input.PointerPoint): boolean;
        processDownEvent(value: Windows.UI.Input.PointerPoint): void;
        processMoveEvents(value: Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>): void;
        processUpEvent(value: Windows.UI.Input.PointerPoint): void;
        processMouseWheelEvent(value: Windows.UI.Input.PointerPoint, isShiftKeyDown: boolean, isControlKeyDown: boolean): void;
        processInertia(): void;
        completeGesture(): void;
        autoProcessInertia: boolean;
        crossSlideExact: boolean;
        crossSlideHorizontally: boolean;
        crossSlideThresholds: Windows.UI.Input.CrossSlideThresholds;
        gestureSettings: Windows.UI.Input.GestureSettings;
        inertiaExpansion: number;
        inertiaExpansionDeceleration: number;
        inertiaRotationAngle: number;
        inertiaRotationDeceleration: number;
        inertiaTranslationDeceleration: number;
        inertiaTranslationDisplacement: number;
        isActive: boolean;
        isInertial: boolean;
        manipulationExact: boolean;
        mouseWheelParameters: Windows.UI.Input.MouseWheelParameters;
        pivotCenter: Windows.Foundation.Point;
        pivotRadius: number;
        showGestureFeedback: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): void;
        removeEventListener(eventName: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): void;
        oncrosssliding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>) => void;
        addEventListener(eventName: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): void;
        removeEventListener(eventName: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): void;
        ondragging: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>) => void;
        addEventListener(eventName: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): void;
        removeEventListener(eventName: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): void;
        onholding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>) => void;
        addEventListener(eventName: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): void;
        removeEventListener(eventName: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): void;
        onmanipulationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>) => void;
        addEventListener(eventName: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): void;
        removeEventListener(eventName: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): void;
        onmanipulationinertiastarting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>) => void;
        addEventListener(eventName: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): void;
        removeEventListener(eventName: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): void;
        onmanipulationstarted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>) => void;
        addEventListener(eventName: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): void;
        removeEventListener(eventName: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): void;
        onmanipulationupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>) => void;
        addEventListener(eventName: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): void;
        removeEventListener(eventName: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): void;
        onrighttapped: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>) => void;
        addEventListener(eventName: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): void;
        removeEventListener(eventName: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): void;
        ontapped: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>) => void;

    }

    export interface IHoldingEventArgs {
        holdingState: Windows.UI.Input.HoldingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IManipulationCompletedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IManipulationInertiaStartingEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IManipulationStartedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IManipulationUpdatedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IMouseWheelParameters {
        charTranslation: Windows.Foundation.Point;
        deltaRotationAngle: number;
        deltaScale: number;
        pageTranslation: Windows.Foundation.Point;
    }

    export interface IPointerPoint {
        frameId: number;
        isInContact: boolean;
        pointerDevice: Windows.Devices.Input.PointerDevice;
        pointerId: number;
        position: Windows.Foundation.Point;
        properties: Windows.UI.Input.PointerPointProperties;
        rawPosition: Windows.Foundation.Point;
        timestamp: number;
    }

    export interface IPointerPointProperties {
        hasUsage(usagePage: number, usageId: number): boolean;
        getUsageValue(usagePage: number, usageId: number): number;
        contactRect: Windows.Foundation.Rect;
        contactRectRaw: Windows.Foundation.Rect;
        isBarrelButtonPressed: boolean;
        isCanceled: boolean;
        isEraser: boolean;
        isHorizontalMouseWheel: boolean;
        isInRange: boolean;
        isInverted: boolean;
        isLeftButtonPressed: boolean;
        isMiddleButtonPressed: boolean;
        isPrimary: boolean;
        isRightButtonPressed: boolean;
        isXButton1Pressed: boolean;
        isXButton2Pressed: boolean;
        mouseWheelDelta: number;
        orientation: number;
        pointerUpdateKind: Windows.UI.Input.PointerUpdateKind;
        pressure: number;
        touchConfidence: boolean;
        twist: number;
        xTilt: number;
        yTilt: number;
    }

    export interface IPointerPointTransform {
        tryTransform(inPoint: Windows.Foundation.Point): IPointerPointTransform_tryTransform_OUT;
        transformBounds(rect: Windows.Foundation.Rect): Windows.Foundation.Rect;
        inverse: Windows.UI.Input.IPointerPointTransform;
    }

    interface IPointerPointTransform_tryTransform_OUT {
        __returnValue: boolean;
        outPoint: Windows.Foundation.Point;
    }

    export interface IPointerVisualizationSettings {
        isBarrelButtonFeedbackEnabled: boolean;
        isContactFeedbackEnabled: boolean;
    }

    export interface IRightTappedEventArgs {
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface ITappedEventArgs {
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        tapCount: number;
    }

    export class ManipulationCompletedEventArgs implements Windows.UI.Input.IManipulationCompletedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export class ManipulationDelta {
        translation: Windows.Foundation.Point;
        scale: number;
        rotation: number;
        expansion: number;
    }

    export class ManipulationInertiaStartingEventArgs implements Windows.UI.Input.IManipulationInertiaStartingEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export class ManipulationStartedEventArgs implements Windows.UI.Input.IManipulationStartedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export class ManipulationUpdatedEventArgs implements Windows.UI.Input.IManipulationUpdatedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export class ManipulationVelocities {
        linear: Windows.Foundation.Point;
        angular: number;
        expansion: number;
    }

    export class MouseWheelParameters implements Windows.UI.Input.IMouseWheelParameters {
        charTranslation: Windows.Foundation.Point;
        deltaRotationAngle: number;
        deltaScale: number;
        pageTranslation: Windows.Foundation.Point;
    }

    export class PointerPoint implements Windows.UI.Input.IPointerPoint {
        static getCurrentPoint(pointerId: number): Windows.UI.Input.PointerPoint;
        static getIntermediatePoints(pointerId: number): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        static getCurrentPoint(pointerId: number, transform: Windows.UI.Input.IPointerPointTransform): Windows.UI.Input.PointerPoint;
        static getIntermediatePoints(pointerId: number, transform: Windows.UI.Input.IPointerPointTransform): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        frameId: number;
        isInContact: boolean;
        pointerDevice: Windows.Devices.Input.PointerDevice;
        pointerId: number;
        position: Windows.Foundation.Point;
        properties: Windows.UI.Input.PointerPointProperties;
        rawPosition: Windows.Foundation.Point;
        timestamp: number;
    }

    export class PointerPointProperties implements Windows.UI.Input.IPointerPointProperties {
        hasUsage(usagePage: number, usageId: number): boolean;
        getUsageValue(usagePage: number, usageId: number): number;
        contactRect: Windows.Foundation.Rect;
        contactRectRaw: Windows.Foundation.Rect;
        isBarrelButtonPressed: boolean;
        isCanceled: boolean;
        isEraser: boolean;
        isHorizontalMouseWheel: boolean;
        isInRange: boolean;
        isInverted: boolean;
        isLeftButtonPressed: boolean;
        isMiddleButtonPressed: boolean;
        isPrimary: boolean;
        isRightButtonPressed: boolean;
        isXButton1Pressed: boolean;
        isXButton2Pressed: boolean;
        mouseWheelDelta: number;
        orientation: number;
        pointerUpdateKind: Windows.UI.Input.PointerUpdateKind;
        pressure: number;
        touchConfidence: boolean;
        twist: number;
        xTilt: number;
        yTilt: number;
    }

    enum PointerUpdateKind {
        other,
        leftButtonPressed,
        leftButtonReleased,
        rightButtonPressed,
        rightButtonReleased,
        middleButtonPressed,
        middleButtonReleased,
        xButton1Pressed,
        xButton1Released,
        xButton2Pressed,
        xButton2Released
    }

    export class PointerVisualizationSettings implements Windows.UI.Input.IPointerVisualizationSettings {
        static getForCurrentView(): Windows.UI.Input.PointerVisualizationSettings;
        isBarrelButtonFeedbackEnabled: boolean;
        isContactFeedbackEnabled: boolean;
    }

    export class RightTappedEventArgs implements Windows.UI.Input.IRightTappedEventArgs {
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export class TappedEventArgs implements Windows.UI.Input.ITappedEventArgs {
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        tapCount: number;
    }

}
declare module Windows.UI.Notifications {

    export class BadgeNotification implements Windows.UI.Notifications.IBadgeNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument);
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
    }

    enum BadgeTemplateType {
        badgeGlyph,
        badgeNumber
    }

    export class BadgeUpdateManager {
        static createBadgeUpdaterForApplication(): Windows.UI.Notifications.BadgeUpdater;
        static createBadgeUpdaterForApplication(applicationId: string): Windows.UI.Notifications.BadgeUpdater;
        static createBadgeUpdaterForSecondaryTile(tileId: string): Windows.UI.Notifications.BadgeUpdater;
        static getTemplateContent(type: Windows.UI.Notifications.BadgeTemplateType): Windows.Data.Xml.Dom.XmlDocument;
    }

    export class BadgeUpdater implements Windows.UI.Notifications.IBadgeUpdater {
        update(notification: Windows.UI.Notifications.BadgeNotification): void;
        clear(): void;
        startPeriodicUpdate(badgeContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdate(badgeContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        stopPeriodicUpdate(): void;
    }

    export interface IBadgeNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
    }

    export interface IBadgeUpdater {
        update(notification: Windows.UI.Notifications.BadgeNotification): void;
        clear(): void;
        startPeriodicUpdate(badgeContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdate(badgeContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        stopPeriodicUpdate(): void;
    }

    export interface IScheduledTileNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        deliveryTime: Date;
        expirationTime: Windows.Foundation.IReference<Date>;
        id: string;
        tag: string;
    }

    export interface IScheduledToastNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        deliveryTime: Date;
        id: string;
        maximumSnoozeCount: number;
        snoozeInterval: Windows.Foundation.IReference<Windows.Foundation.TimeSpan>;
    }

    export interface ITileNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
        tag: string;
    }

    export interface ITileUpdater {
        update(notification: Windows.UI.Notifications.TileNotification): void;
        clear(): void;
        enableNotificationQueue(enable: boolean): void;
        addToSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
        removeFromSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
        getScheduledTileNotifications(): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledTileNotification>;
        startPeriodicUpdate(tileContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdate(tileContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        stopPeriodicUpdate(): void;
        startPeriodicUpdateBatch(tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdateBatch(tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        setting: Windows.UI.Notifications.NotificationSetting;
    }

    export interface IToastDismissedEventArgs {
        reason: Windows.UI.Notifications.ToastDismissalReason;
    }

    export interface IToastFailedEventArgs {
        errorCode: Windows.Foundation.HResult;
    }

    export interface IToastNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>) => void;
        addEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): void;
        removeEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): void;
        ondismissed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>) => void;
        addEventListener(eventName: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): void;
        removeEventListener(eventName: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): void;
        onfailed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>) => void;

    }

    export interface IToastNotifier {
        show(notification: Windows.UI.Notifications.ToastNotification): void;
        hide(notification: Windows.UI.Notifications.ToastNotification): void;
        addToSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
        removeFromSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
        getScheduledToastNotifications(): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledToastNotification>;
        setting: Windows.UI.Notifications.NotificationSetting;
    }

    enum NotificationSetting {
        enabled,
        disabledForApplication,
        disabledForUser,
        disabledByGroupPolicy,
        disabledByManifest
    }

    enum PeriodicUpdateRecurrence {
        halfHour,
        hour,
        sixHours,
        twelveHours,
        daily
    }

    export class ScheduledTileNotification implements Windows.UI.Notifications.IScheduledTileNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date);
        content: Windows.Data.Xml.Dom.XmlDocument;
        deliveryTime: Date;
        expirationTime: Windows.Foundation.IReference<Date>;
        id: string;
        tag: string;
    }

    export class ScheduledToastNotification implements Windows.UI.Notifications.IScheduledToastNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date);
        constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date, snoozeInterval: Windows.Foundation.TimeSpan, maximumSnoozeCount: number);
        content: Windows.Data.Xml.Dom.XmlDocument;
        deliveryTime: Date;
        id: string;
        maximumSnoozeCount: number;
        snoozeInterval: Windows.Foundation.IReference<Windows.Foundation.TimeSpan>;
    }

    export class TileNotification implements Windows.UI.Notifications.ITileNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument);
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
        tag: string;
    }

    enum TileTemplateType {
        tileSquareImage,
        tileSquareBlock,
        tileSquareText01,
        tileSquareText02,
        tileSquareText03,
        tileSquareText04,
        tileSquarePeekImageAndText01,
        tileSquarePeekImageAndText02,
        tileSquarePeekImageAndText03,
        tileSquarePeekImageAndText04,
        tileWideImage,
        tileWideImageCollection,
        tileWideImageAndText01,
        tileWideImageAndText02,
        tileWideBlockAndText01,
        tileWideBlockAndText02,
        tileWidePeekImageCollection01,
        tileWidePeekImageCollection02,
        tileWidePeekImageCollection03,
        tileWidePeekImageCollection04,
        tileWidePeekImageCollection05,
        tileWidePeekImageCollection06,
        tileWidePeekImageAndText01,
        tileWidePeekImageAndText02,
        tileWidePeekImage01,
        tileWidePeekImage02,
        tileWidePeekImage03,
        tileWidePeekImage04,
        tileWidePeekImage05,
        tileWidePeekImage06,
        tileWideSmallImageAndText01,
        tileWideSmallImageAndText02,
        tileWideSmallImageAndText03,
        tileWideSmallImageAndText04,
        tileWideSmallImageAndText05,
        tileWideText01,
        tileWideText02,
        tileWideText03,
        tileWideText04,
        tileWideText05,
        tileWideText06,
        tileWideText07,
        tileWideText08,
        tileWideText09,
        tileWideText10,
        tileWideText11
    }

    export class TileUpdateManager {
        static createTileUpdaterForApplication(): Windows.UI.Notifications.TileUpdater;
        static createTileUpdaterForApplication(applicationId: string): Windows.UI.Notifications.TileUpdater;
        static createTileUpdaterForSecondaryTile(tileId: string): Windows.UI.Notifications.TileUpdater;
        static getTemplateContent(type: Windows.UI.Notifications.TileTemplateType): Windows.Data.Xml.Dom.XmlDocument;
    }

    export class TileUpdater implements Windows.UI.Notifications.ITileUpdater {
        update(notification: Windows.UI.Notifications.TileNotification): void;
        clear(): void;
        enableNotificationQueue(enable: boolean): void;
        addToSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
        removeFromSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
        getScheduledTileNotifications(): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledTileNotification>;
        startPeriodicUpdate(tileContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdate(tileContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        stopPeriodicUpdate(): void;
        startPeriodicUpdateBatch(tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdateBatch(tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        setting: Windows.UI.Notifications.NotificationSetting;
    }

    enum ToastDismissalReason {
        userCanceled,
        applicationHidden,
        timedOut
    }

    export class ToastDismissedEventArgs implements Windows.UI.Notifications.IToastDismissedEventArgs {
        reason: Windows.UI.Notifications.ToastDismissalReason;
    }

    export class ToastFailedEventArgs implements Windows.UI.Notifications.IToastFailedEventArgs {
        errorCode: Windows.Foundation.HResult;
    }

    export class ToastNotification implements Windows.UI.Notifications.IToastNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument);
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>) => void;
        addEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): void;
        removeEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): void;
        ondismissed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>) => void;
        addEventListener(eventName: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): void;
        removeEventListener(eventName: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): void;
        onfailed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>) => void;

    }

    export class ToastNotificationManager {
        static createToastNotifier(): Windows.UI.Notifications.ToastNotifier;
        static createToastNotifier(applicationId: string): Windows.UI.Notifications.ToastNotifier;
        static getTemplateContent(type: Windows.UI.Notifications.ToastTemplateType): Windows.Data.Xml.Dom.XmlDocument;
    }

    export class ToastNotifier implements Windows.UI.Notifications.IToastNotifier {
        show(notification: Windows.UI.Notifications.ToastNotification): void;
        hide(notification: Windows.UI.Notifications.ToastNotification): void;
        addToSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
        removeFromSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
        getScheduledToastNotifications(): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledToastNotification>;
        setting: Windows.UI.Notifications.NotificationSetting;
    }

    enum ToastTemplateType {
        toastImageAndText01,
        toastImageAndText02,
        toastImageAndText03,
        toastImageAndText04,
        toastText01,
        toastText02,
        toastText03,
        toastText04
    }

}
declare module Windows.UI.Popups {

    export interface IMessageDialog {
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        cancelCommandIndex: number;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        content: string;
        defaultCommandIndex: number;
        options: Windows.UI.Popups.MessageDialogOptions;
        title: string;
    }

    export interface IPopupMenu {
        showAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        showForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        showForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
    }

    export interface IUICommand {
        id: any;
        invoked: Windows.UI.Popups.UICommandInvokedHandler;
        label: string;
    }

    export class MessageDialog implements Windows.UI.Popups.IMessageDialog {
        constructor(content: string);
        constructor(content: string, title: string);
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        cancelCommandIndex: number;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        content: string;
        defaultCommandIndex: number;
        options: Windows.UI.Popups.MessageDialogOptions;
        title: string;
    }

    enum MessageDialogOptions {
        none,
        acceptUserInputAfterDelay
    }

    enum Placement {
        default,
        above,
        below,
        left,
        right
    }

    export class PopupMenu implements Windows.UI.Popups.IPopupMenu {
        constructor();
        showAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        showForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        showForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
    }

    export class UICommand implements Windows.UI.Popups.IUICommand {
        constructor(label: string);
        constructor(label: string, action: Windows.UI.Popups.UICommandInvokedHandler);
        constructor(label: string, action: Windows.UI.Popups.UICommandInvokedHandler, commandId: any);
        constructor();
        id: any;
        invoked: Windows.UI.Popups.UICommandInvokedHandler;
        label: string;
    }

    export interface UICommandInvokedHandler {
        target: Windows.UI.Popups.IUICommand;
        detail: any[];
        type: string;
    }

    export class UICommandSeparator implements Windows.UI.Popups.IUICommand {
        constructor();
        id: any;
        invoked: Windows.UI.Popups.UICommandInvokedHandler;
        label: string;
    }

}
declare module Windows.UI.StartScreen {

    enum ForegroundText {
        dark,
        light
    }

    export interface ISecondaryTile {
        requestCreateAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<boolean>;
        updateAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        arguments: string;
        backgroundColor: Windows.UI.Color;
        displayName: string;
        foregroundText: Windows.UI.StartScreen.ForegroundText;
        lockScreenBadgeLogo: Windows.Foundation.Uri;
        lockScreenDisplayBadgeAndTileText: boolean;
        logo: Windows.Foundation.Uri;
        shortName: string;
        smallLogo: Windows.Foundation.Uri;
        tileId: string;
        tileOptions: Windows.UI.StartScreen.TileOptions;
        wideLogo: Windows.Foundation.Uri;
    }

    export class SecondaryTile implements Windows.UI.StartScreen.ISecondaryTile {
        constructor(tileId: string, shortName: string, displayName: string, arguments: string, tileOptions: Windows.UI.StartScreen.TileOptions, logoReference: Windows.Foundation.Uri);
        constructor(tileId: string, shortName: string, displayName: string, arguments: string, tileOptions: Windows.UI.StartScreen.TileOptions, logoReference: Windows.Foundation.Uri, wideLogoReference: Windows.Foundation.Uri);
        constructor(tileId: string);
        constructor();
        requestCreateAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<boolean>;
        updateAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        static exists(tileId: string): boolean;
        static findAllAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.UI.StartScreen.SecondaryTile>>;
        static findAllAsync(applicationId: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.UI.StartScreen.SecondaryTile>>;
        static findAllForPackageAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.UI.StartScreen.SecondaryTile>>;
        arguments: string;
        backgroundColor: Windows.UI.Color;
        displayName: string;
        foregroundText: Windows.UI.StartScreen.ForegroundText;
        lockScreenBadgeLogo: Windows.Foundation.Uri;
        lockScreenDisplayBadgeAndTileText: boolean;
        logo: Windows.Foundation.Uri;
        shortName: string;
        smallLogo: Windows.Foundation.Uri;
        tileId: string;
        tileOptions: Windows.UI.StartScreen.TileOptions;
        wideLogo: Windows.Foundation.Uri;
    }

    enum TileOptions {
        none,
        showNameOnLogo,
        showNameOnWideLogo,
        copyOnDeployment
    }

}
declare module Windows.UI.Text {

    enum CaretType {
        normal,
        null
    }

    enum FindOptions {
        none,
        word,
        case
    }

    enum FontStretch {
        undefined,
        ultraCondensed,
        extraCondensed,
        condensed,
        semiCondensed,
        normal,
        semiExpanded,
        expanded,
        extraExpanded,
        ultraExpanded
    }

    enum FontStyle {
        normal,
        oblique,
        italic
    }

    export class FontWeight {
        weight: number;
    }

    export class FontWeights implements Windows.UI.Text.IFontWeights {
        static black: Windows.UI.Text.FontWeight;
        static bold: Windows.UI.Text.FontWeight;
        static extraBlack: Windows.UI.Text.FontWeight;
        static extraBold: Windows.UI.Text.FontWeight;
        static extraLight: Windows.UI.Text.FontWeight;
        static light: Windows.UI.Text.FontWeight;
        static medium: Windows.UI.Text.FontWeight;
        static normal: Windows.UI.Text.FontWeight;
        static semiBold: Windows.UI.Text.FontWeight;
        static semiLight: Windows.UI.Text.FontWeight;
        static thin: Windows.UI.Text.FontWeight;
    }

    enum FormatEffect {
        off,
        on,
        toggle,
        undefined
    }

    enum HorizontalCharacterAlignment {
        left,
        right,
        center
    }

    export interface IFontWeights {
    }

    export interface ITextCharacterFormat {
        setClone(value: Windows.UI.Text.ITextCharacterFormat): void;
        getClone(): Windows.UI.Text.ITextCharacterFormat;
        isEqual(format: Windows.UI.Text.ITextCharacterFormat): boolean;
        allCaps: Windows.UI.Text.FormatEffect;
        backgroundColor: Windows.UI.Color;
        bold: Windows.UI.Text.FormatEffect;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        foregroundColor: Windows.UI.Color;
        hidden: Windows.UI.Text.FormatEffect;
        italic: Windows.UI.Text.FormatEffect;
        kerning: number;
        languageTag: string;
        linkType: Windows.UI.Text.LinkType;
        name: string;
        outline: Windows.UI.Text.FormatEffect;
        position: number;
        protectedText: Windows.UI.Text.FormatEffect;
        size: number;
        smallCaps: Windows.UI.Text.FormatEffect;
        spacing: number;
        strikethrough: Windows.UI.Text.FormatEffect;
        subscript: Windows.UI.Text.FormatEffect;
        superscript: Windows.UI.Text.FormatEffect;
        textScript: Windows.UI.Text.TextScript;
        underline: Windows.UI.Text.UnderlineType;
        weight: number;
    }

    export interface ITextDocument {
        canCopy(): boolean;
        canPaste(): boolean;
        canRedo(): boolean;
        canUndo(): boolean;
        applyDisplayUpdates(): number;
        batchDisplayUpdates(): number;
        beginUndoGroup(): void;
        endUndoGroup(): void;
        getDefaultCharacterFormat(): Windows.UI.Text.ITextCharacterFormat;
        getDefaultParagraphFormat(): Windows.UI.Text.ITextParagraphFormat;
        getRange(startPosition: number, endPosition: number): Windows.UI.Text.ITextRange;
        getRangeFromPoint(point: Windows.Foundation.Point, options: Windows.UI.Text.PointOptions): Windows.UI.Text.ITextRange;
        getText(options: Windows.UI.Text.TextGetOptions): ITextDocument_getText_OUT;
        loadFromStream(options: Windows.UI.Text.TextSetOptions, value: Windows.Storage.Streams.IRandomAccessStream): void;
        redo(): void;
        saveToStream(options: Windows.UI.Text.TextGetOptions, value: Windows.Storage.Streams.IRandomAccessStream): void;
        setDefaultCharacterFormat(value: Windows.UI.Text.ITextCharacterFormat): void;
        setDefaultParagraphFormat(value: Windows.UI.Text.ITextParagraphFormat): void;
        setText(options: Windows.UI.Text.TextSetOptions, value: string): void;
        undo(): void;
        caretType: Windows.UI.Text.CaretType;
        defaultTabStop: number;
        selection: Windows.UI.Text.ITextSelection;
        undoLimit: number;
    }

    interface ITextDocument_getText_OUT {
        value: string;
    }

    export interface ITextParagraphFormat {
        addTab(position: number, align: Windows.UI.Text.TabAlignment, leader: Windows.UI.Text.TabLeader): void;
        clearAllTabs(): void;
        deleteTab(position: number): void;
        getClone(): Windows.UI.Text.ITextParagraphFormat;
        getTab(index: number): ITextParagraphFormat_getTab_OUT;
        isEqual(format: Windows.UI.Text.ITextParagraphFormat): boolean;
        setClone(format: Windows.UI.Text.ITextParagraphFormat): void;
        setIndents(start: number, left: number, right: number): void;
        setLineSpacing(rule: Windows.UI.Text.LineSpacingRule, spacing: number): void;
        alignment: Windows.UI.Text.ParagraphAlignment;
        firstLineIndent: number;
        keepTogether: Windows.UI.Text.FormatEffect;
        keepWithNext: Windows.UI.Text.FormatEffect;
        leftIndent: number;
        lineSpacing: number;
        lineSpacingRule: Windows.UI.Text.LineSpacingRule;
        listAlignment: Windows.UI.Text.MarkerAlignment;
        listLevelIndex: number;
        listStart: number;
        listStyle: Windows.UI.Text.MarkerStyle;
        listTab: number;
        listType: Windows.UI.Text.MarkerType;
        noLineNumber: Windows.UI.Text.FormatEffect;
        pageBreakBefore: Windows.UI.Text.FormatEffect;
        rightIndent: number;
        rightToLeft: Windows.UI.Text.FormatEffect;
        spaceAfter: number;
        spaceBefore: number;
        style: Windows.UI.Text.ParagraphStyle;
        tabCount: number;
        widowControl: Windows.UI.Text.FormatEffect;
    }

    interface ITextParagraphFormat_getTab_OUT {
        position: number;
        align: Windows.UI.Text.TabAlignment;
        leader: Windows.UI.Text.TabLeader;
    }

    export interface ITextRange {
        canPaste(format: number): boolean;
        changeCase(value: Windows.UI.Text.LetterCase): void;
        collapse(value: boolean): void;
        copy(): void;
        cut(): void;
        delete(unit: Windows.UI.Text.TextRangeUnit, count: number): number;
        endOf(unit: Windows.UI.Text.TextRangeUnit, extend: boolean): number;
        expand(unit: Windows.UI.Text.TextRangeUnit): number;
        findText(value: string, scanLength: number, options: Windows.UI.Text.FindOptions): number;
        getCharacterUtf32(offset: number): ITextRange_getCharacterUtf32_OUT;
        getClone(): Windows.UI.Text.ITextRange;
        getIndex(unit: Windows.UI.Text.TextRangeUnit): number;
        getPoint(horizontalAlign: Windows.UI.Text.HorizontalCharacterAlignment, verticalAlign: Windows.UI.Text.VerticalCharacterAlignment, options: Windows.UI.Text.PointOptions): ITextRange_getPoint_OUT;
        getRect(options: Windows.UI.Text.PointOptions): ITextRange_getRect_OUT;
        getText(options: Windows.UI.Text.TextGetOptions): ITextRange_getText_OUT;
        getTextViaStream(options: Windows.UI.Text.TextGetOptions, value: Windows.Storage.Streams.IRandomAccessStream): void;
        inRange(range: Windows.UI.Text.ITextRange): boolean;
        insertImage(width: number, height: number, ascent: number, verticalAlign: Windows.UI.Text.VerticalCharacterAlignment, alternateText: string, value: Windows.Storage.Streams.IRandomAccessStream): void;
        inStory(range: Windows.UI.Text.ITextRange): boolean;
        isEqual(range: Windows.UI.Text.ITextRange): boolean;
        move(unit: Windows.UI.Text.TextRangeUnit, count: number): number;
        moveEnd(unit: Windows.UI.Text.TextRangeUnit, count: number): number;
        moveStart(unit: Windows.UI.Text.TextRangeUnit, count: number): number;
        paste(format: number): void;
        scrollIntoView(value: Windows.UI.Text.PointOptions): void;
        matchSelection(): void;
        setIndex(unit: Windows.UI.Text.TextRangeUnit, index: number, extend: boolean): void;
        setPoint(point: Windows.Foundation.Point, options: Windows.UI.Text.PointOptions, extend: boolean): void;
        setRange(startPosition: number, endPosition: number): void;
        setText(options: Windows.UI.Text.TextSetOptions, value: string): void;
        setTextViaStream(options: Windows.UI.Text.TextSetOptions, value: Windows.Storage.Streams.IRandomAccessStream): void;
        startOf(unit: Windows.UI.Text.TextRangeUnit, extend: boolean): number;
        character: number;
        characterFormat: Windows.UI.Text.ITextCharacterFormat;
        endPosition: number;
        formattedText: Windows.UI.Text.ITextRange;
        gravity: Windows.UI.Text.RangeGravity;
        length: number;
        link: string;
        paragraphFormat: Windows.UI.Text.ITextParagraphFormat;
        startPosition: number;
        storyLength: number;
        text: string;
    }

    interface ITextRange_getCharacterUtf32_OUT {
        value: number;
    }

    interface ITextRange_getPoint_OUT {
        point: Windows.Foundation.Point;
    }

    interface ITextRange_getRect_OUT {
        rect: Windows.Foundation.Rect;
        hit: number;
    }

    interface ITextRange_getText_OUT {
        value: string;
    }

    export interface ITextSelection extends Windows.UI.Text.ITextRange {
        endKey(unit: Windows.UI.Text.TextRangeUnit, extend: boolean): number;
        homeKey(unit: Windows.UI.Text.TextRangeUnit, extend: boolean): number;
        moveDown(unit: Windows.UI.Text.TextRangeUnit, count: number, extend: boolean): number;
        moveLeft(unit: Windows.UI.Text.TextRangeUnit, count: number, extend: boolean): number;
        moveRight(unit: Windows.UI.Text.TextRangeUnit, count: number, extend: boolean): number;
        moveUp(unit: Windows.UI.Text.TextRangeUnit, count: number, extend: boolean): number;
        typeText(value: string): void;
        options: Windows.UI.Text.SelectionOptions;
        type: Windows.UI.Text.SelectionType;
    }

    enum LetterCase {
        lower,
        upper
    }

    enum LineSpacingRule {
        undefined,
        single,
        oneAndHalf,
        double,
        atLeast,
        exactly,
        multiple,
        percent
    }

    enum LinkType {
        undefined,
        notALink,
        clientLink,
        friendlyLinkName,
        friendlyLinkAddress,
        autoLink,
        autoLinkEmail,
        autoLinkPhone,
        autoLinkPath
    }

    enum MarkerAlignment {
        undefined,
        left,
        center,
        right
    }

    enum MarkerStyle {
        undefined,
        parenthesis,
        parentheses,
        period,
        plain,
        minus,
        noNumber
    }

    enum MarkerType {
        undefined,
        none,
        bullet,
        arabic,
        lowercaseEnglishLetter,
        uppercaseEnglishLetter,
        lowercaseRoman,
        uppercaseRoman,
        unicodeSequence,
        circledNumber,
        blackCircleWingding,
        whiteCircleWingding,
        arabicWide,
        simplifiedChinese,
        traditionalChinese,
        japanSimplifiedChinese,
        japanKorea,
        arabicDictionary,
        arabicAbjad,
        hebrew,
        thaiAlphabetic,
        thaiNumeric,
        devanagariVowel,
        devanagariConsonant,
        devanagariNumeric
    }

    enum ParagraphAlignment {
        undefined,
        left,
        center,
        right,
        justify
    }

    enum ParagraphStyle {
        undefined,
        none,
        normal,
        heading1,
        heading2,
        heading3,
        heading4,
        heading5,
        heading6,
        heading7,
        heading8,
        heading9
    }

    enum PointOptions {
        none,
        includeInset,
        start,
        clientCoordinates,
        allowOffClient,
        transform,
        noHorizontalScroll,
        noVerticalScroll
    }

    enum RangeGravity {
        uiBehavior,
        backward,
        forward,
        inward,
        outward
    }

    enum SelectionOptions {
        startActive,
        atEndOfLine,
        overtype,
        active,
        replace
    }

    enum SelectionType {
        none,
        insertionPoint,
        normal,
        inlineShape,
        shape
    }

    enum TabAlignment {
        left,
        center,
        right,
        decimal,
        bar
    }

    enum TabLeader {
        spaces,
        dots,
        dashes,
        lines,
        thickLines,
        equals
    }

    export class TextConstants {
        static autoColor: Windows.UI.Color;
        static maxUnitCount: number;
        static minUnitCount: number;
        static undefinedColor: Windows.UI.Color;
        static undefinedFloatValue: number;
        static undefinedFontStretch: Windows.UI.Text.FontStretch;
        static undefinedFontStyle: Windows.UI.Text.FontStyle;
        static undefinedInt32Value: number;
    }

    enum TextGetOptions {
        none,
        adjustCrlf,
        useCrlf,
        useObjectText,
        allowFinalEop,
        noHidden,
        includeNumbering,
        formatRtf
    }

    enum TextRangeUnit {
        character,
        word,
        sentence,
        paragraph,
        line,
        story,
        screen,
        section,
        window,
        characterFormat,
        paragraphFormat,
        object,
        hardParagraph,
        cluster,
        bold,
        italic,
        underline,
        strikethrough,
        protectedText,
        link,
        smallCaps,
        allCaps,
        hidden,
        outline,
        shadow,
        imprint,
        disabled,
        revised,
        subscript,
        superscript,
        fontBound,
        linkProtected
    }

    enum TextScript {
        undefined,
        ansi,
        eastEurope,
        cyrillic,
        greek,
        turkish,
        hebrew,
        arabic,
        baltic,
        vietnamese,
        default,
        symbol,
        thai,
        shiftJis,
        gb2312,
        hangul,
        big5,
        pc437,
        oem,
        mac,
        armenian,
        syriac,
        thaana,
        devanagari,
        bengali,
        gurmukhi,
        gujarati,
        oriya,
        tamil,
        telugu,
        kannada,
        malayalam,
        sinhala,
        lao,
        tibetan,
        myanmar,
        georgian,
        jamo,
        ethiopic,
        cherokee,
        aboriginal,
        ogham,
        runic,
        khmer,
        mongolian,
        braille,
        yi,
        limbu,
        taiLe,
        newTaiLue,
        sylotiNagri,
        kharoshthi,
        kayahli,
        unicodeSymbol,
        emoji,
        glagolitic,
        lisu,
        vai,
        nko,
        osmanya,
        phagsPa,
        gothic,
        deseret,
        tifinagh
    }

    enum TextSetOptions {
        none,
        unicodeBidi,
        unlink,
        unhide,
        checkTextLimit,
        formatRtf,
        applyRtfDocumentDefaults
    }

    enum UnderlineType {
        undefined,
        none,
        single,
        words,
        double,
        dotted,
        dash,
        dashDot,
        dashDotDot,
        wave,
        thick,
        thin,
        doubleWave,
        heavyWave,
        longDash,
        thickDash,
        thickDashDot,
        thickDashDotDot,
        thickDotted,
        thickLongDash
    }

    enum VerticalCharacterAlignment {
        top,
        baseline,
        bottom
    }

}
declare module Windows.UI.ViewManagement {

    export class AccessibilitySettings implements Windows.UI.ViewManagement.IAccessibilitySettings {
        constructor();
        highContrast: boolean;
        highContrastScheme: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): void;
        removeEventListener(eventName: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): void;
        onhighcontrastchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>) => void;

    }

    export class ApplicationView {
        static tryUnsnap(): boolean;
        static value: Windows.UI.ViewManagement.ApplicationViewState;
    }

    enum ApplicationViewState {
        fullScreenLandscape,
        filled,
        snapped,
        fullScreenPortrait
    }

    enum HandPreference {
        leftHanded,
        rightHanded
    }

    export interface IAccessibilitySettings {
        highContrast: boolean;
        highContrastScheme: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): void;
        removeEventListener(eventName: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): void;
        onhighcontrastchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>) => void;

    }

    export interface IInputPane {
        occludedRect: Windows.Foundation.Rect;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        removeEventListener(eventName: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        onhiding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>) => void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>) => void;

    }

    export interface IInputPaneVisibilityEventArgs {
        ensuredFocusedElementInView: boolean;
        occludedRect: Windows.Foundation.Rect;
    }

    export class InputPane implements Windows.UI.ViewManagement.IInputPane {
        static getForCurrentView(): Windows.UI.ViewManagement.InputPane;
        occludedRect: Windows.Foundation.Rect;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        removeEventListener(eventName: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        onhiding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>) => void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>) => void;

    }

    export class InputPaneVisibilityEventArgs implements Windows.UI.ViewManagement.IInputPaneVisibilityEventArgs {
        ensuredFocusedElementInView: boolean;
        occludedRect: Windows.Foundation.Rect;
    }

    export interface IUISettings {
        uIElementColor(desiredElement: Windows.UI.ViewManagement.UIElementType): Windows.UI.Color;
        animationsEnabled: boolean;
        caretBlinkRate: number;
        caretBrowsingEnabled: boolean;
        caretWidth: number;
        cursorSize: Windows.Foundation.Size;
        doubleClickTime: number;
        handPreference: Windows.UI.ViewManagement.HandPreference;
        messageDuration: number;
        mouseHoverTime: number;
        scrollBarArrowSize: Windows.Foundation.Size;
        scrollBarSize: Windows.Foundation.Size;
        scrollBarThumbBoxSize: Windows.Foundation.Size;
    }

    enum UIElementType {
        activeCaption,
        background,
        buttonFace,
        buttonText,
        captionText,
        grayText,
        highlight,
        highlightText,
        hotlight,
        inactiveCaption,
        inactiveCaptionText,
        window,
        windowText
    }

    export class UISettings implements Windows.UI.ViewManagement.IUISettings {
        constructor();
        uIElementColor(desiredElement: Windows.UI.ViewManagement.UIElementType): Windows.UI.Color;
        animationsEnabled: boolean;
        caretBlinkRate: number;
        caretBrowsingEnabled: boolean;
        caretWidth: number;
        cursorSize: Windows.Foundation.Size;
        doubleClickTime: number;
        handPreference: Windows.UI.ViewManagement.HandPreference;
        messageDuration: number;
        mouseHoverTime: number;
        scrollBarArrowSize: Windows.Foundation.Size;
        scrollBarSize: Windows.Foundation.Size;
        scrollBarThumbBoxSize: Windows.Foundation.Size;
    }

}
declare module Windows.UI.WebUI {

    export class ActivatedDeferral implements Windows.UI.WebUI.IActivatedDeferral {
        complete(): void;
    }

    export interface ActivatedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ActivatedOperation implements Windows.UI.WebUI.IActivatedOperation {
        getDeferral(): Windows.UI.WebUI.ActivatedDeferral;
    }

    export interface IActivatedDeferral {
        complete(): void;
    }

    export interface IActivatedEventArgsDeferral {
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export interface IActivatedOperation {
        getDeferral(): Windows.UI.WebUI.ActivatedDeferral;
    }

    export interface IWebUIBackgroundTaskInstance {
        succeeded: boolean;
    }

    export interface IWebUINavigatedDeferral {
        complete(): void;
    }

    export interface IWebUINavigatedEventArgs {
        navigatedOperation: Windows.UI.WebUI.WebUINavigatedOperation;
    }

    export interface IWebUINavigatedOperation {
        getDeferral(): Windows.UI.WebUI.WebUINavigatedDeferral;
    }

    export interface NavigatedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface ResumingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class SuspendingDeferral implements Windows.ApplicationModel.ISuspendingDeferral {
        complete(): void;
    }

    export class SuspendingEventArgs implements Windows.ApplicationModel.ISuspendingEventArgs {
        suspendingOperation: Windows.ApplicationModel.SuspendingOperation;
    }

    export interface SuspendingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class SuspendingOperation implements Windows.ApplicationModel.ISuspendingOperation {
        getDeferral(): Windows.ApplicationModel.SuspendingDeferral;
        deadline: Date;
    }

    export class WebUIApplication {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.UI.WebUI.ActivatedEventHandler): void;
        removeEventListener(eventName: "activated", listener: Windows.UI.WebUI.ActivatedEventHandler): void;
        onactivated: (ev: Windows.UI.WebUI.ActivatedEventHandler) => void;
        addEventListener(eventName: "navigated", listener: Windows.UI.WebUI.NavigatedEventHandler): void;
        removeEventListener(eventName: "navigated", listener: Windows.UI.WebUI.NavigatedEventHandler): void;
        onnavigated: (ev: Windows.UI.WebUI.NavigatedEventHandler) => void;
        addEventListener(eventName: "resuming", listener: Windows.UI.WebUI.ResumingEventHandler): void;
        removeEventListener(eventName: "resuming", listener: Windows.UI.WebUI.ResumingEventHandler): void;
        onresuming: (ev: Windows.UI.WebUI.ResumingEventHandler) => void;
        addEventListener(eventName: "suspending", listener: Windows.UI.WebUI.SuspendingEventHandler): void;
        removeEventListener(eventName: "suspending", listener: Windows.UI.WebUI.SuspendingEventHandler): void;
        onsuspending: (ev: Windows.UI.WebUI.SuspendingEventHandler) => void;

    }

    export class WebUIBackgroundTaskInstance {
        static current: Windows.UI.WebUI.IWebUIBackgroundTaskInstance;
    }

    export class WebUIBackgroundTaskInstanceRuntimeClass implements Windows.UI.WebUI.IWebUIBackgroundTaskInstance, Windows.ApplicationModel.Background.IBackgroundTaskInstance {
        getDeferral(): Windows.ApplicationModel.Background.BackgroundTaskDeferral;
        succeeded: boolean;
        instanceId: string;
        progress: number;
        suspendedCount: number;
        task: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        triggerDetails: any;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): void;
        removeEventListener(eventName: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): void;
        oncanceled: (ev: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler) => void;

    }

    export class WebUICachedFileUpdaterActivatedEventArgs implements Windows.ApplicationModel.Activation.ICachedFileUpdaterActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        cachedFileUpdaterUI: Windows.Storage.Provider.CachedFileUpdaterUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUICameraSettingsActivatedEventArgs implements Windows.ApplicationModel.Activation.ICameraSettingsActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        videoDeviceController: any;
        videoDeviceExtension: any;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIContactPickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IContactPickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        contactPickerUI: Windows.ApplicationModel.Contacts.Provider.ContactPickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIDeviceActivatedEventArgs implements Windows.ApplicationModel.Activation.IDeviceActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        deviceInformationId: string;
        verb: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIFileActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        files: Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>;
        verb: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIFileOpenPickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileOpenPickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        fileOpenPickerUI: Windows.Storage.Pickers.Provider.FileOpenPickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIFileSavePickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        fileSavePickerUI: Windows.Storage.Pickers.Provider.FileSavePickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUILaunchActivatedEventArgs implements Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        arguments: string;
        tileId: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUINavigatedDeferral implements Windows.UI.WebUI.IWebUINavigatedDeferral {
        complete(): void;
    }

    export class WebUINavigatedEventArgs implements Windows.UI.WebUI.IWebUINavigatedEventArgs {
        navigatedOperation: Windows.UI.WebUI.WebUINavigatedOperation;
    }

    export class WebUINavigatedOperation implements Windows.UI.WebUI.IWebUINavigatedOperation {
        getDeferral(): Windows.UI.WebUI.WebUINavigatedDeferral;
    }

    export class WebUIPrintTaskSettingsActivatedEventArgs implements Windows.ApplicationModel.Activation.IPrintTaskSettingsActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        configuration: Windows.Devices.Printers.Extensions.PrintTaskConfiguration;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIProtocolActivatedEventArgs implements Windows.ApplicationModel.Activation.IProtocolActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        uri: Windows.Foundation.Uri;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUISearchActivatedEventArgs implements Windows.ApplicationModel.Activation.ISearchActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        language: string;
        queryText: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIShareTargetActivatedEventArgs implements Windows.ApplicationModel.Activation.IShareTargetActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        shareOperation: Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

}
declare module Windows.Web.AtomPub {

    export class AtomPubClient implements Windows.Web.AtomPub.IAtomPubClient, Windows.Web.Syndication.ISyndicationClient {
        constructor(serverCredential: Windows.Security.Credentials.PasswordCredential);
        constructor();
        retrieveServiceDocumentAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.AtomPub.ServiceDocument,Windows.Web.Syndication.RetrievalProgress>;
        retrieveMediaResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream,Windows.Web.Syndication.RetrievalProgress>;
        retrieveResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.RetrievalProgress>;
        createResourceAsync(uri: Windows.Foundation.Uri, description: string, item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.TransferProgress>;
        createMediaResourceAsync(uri: Windows.Foundation.Uri, mediaType: string, description: string, mediaStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.TransferProgress>;
        updateMediaResourceAsync(uri: Windows.Foundation.Uri, mediaType: string, mediaStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        updateResourceAsync(uri: Windows.Foundation.Uri, item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        updateResourceItemAsync(item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        deleteResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        deleteResourceItemAsync(item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        cancelAsyncOperations(): void;
        setRequestHeader(name: string, value: string): void;
        retrieveFeedAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationFeed,Windows.Web.Syndication.RetrievalProgress>;
        bypassCacheOnRetrieve: boolean;
        maxResponseBufferSize: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        timeout: number;
    }

    export interface IAtomPubClient extends Windows.Web.Syndication.ISyndicationClient {
        retrieveServiceDocumentAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.AtomPub.ServiceDocument,Windows.Web.Syndication.RetrievalProgress>;
        retrieveMediaResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream,Windows.Web.Syndication.RetrievalProgress>;
        retrieveResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.RetrievalProgress>;
        createResourceAsync(uri: Windows.Foundation.Uri, description: string, item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.TransferProgress>;
        createMediaResourceAsync(uri: Windows.Foundation.Uri, mediaType: string, description: string, mediaStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.TransferProgress>;
        updateMediaResourceAsync(uri: Windows.Foundation.Uri, mediaType: string, mediaStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        updateResourceAsync(uri: Windows.Foundation.Uri, item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        updateResourceItemAsync(item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        deleteResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        deleteResourceItemAsync(item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        cancelAsyncOperations(): void;
    }

    export interface IResourceCollection extends Windows.Web.Syndication.ISyndicationNode {
        accepts: Windows.Foundation.Collections.IVectorView<string>;
        categories: Windows.Foundation.Collections.IVectorView<Windows.Web.Syndication.SyndicationCategory>;
        title: Windows.Web.Syndication.ISyndicationText;
        uri: Windows.Foundation.Uri;
    }

    export interface IServiceDocument extends Windows.Web.Syndication.ISyndicationNode {
        workspaces: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.Workspace>;
    }

    export interface IWorkspace extends Windows.Web.Syndication.ISyndicationNode {
        collections: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.ResourceCollection>;
        title: Windows.Web.Syndication.ISyndicationText;
    }

    export class ResourceCollection implements Windows.Web.AtomPub.IResourceCollection, Windows.Web.Syndication.ISyndicationNode {
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        accepts: Windows.Foundation.Collections.IVectorView<string>;
        categories: Windows.Foundation.Collections.IVectorView<Windows.Web.Syndication.SyndicationCategory>;
        title: Windows.Web.Syndication.ISyndicationText;
        uri: Windows.Foundation.Uri;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class ServiceDocument implements Windows.Web.AtomPub.IServiceDocument, Windows.Web.Syndication.ISyndicationNode {
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        workspaces: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.Workspace>;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class Workspace implements Windows.Web.AtomPub.IWorkspace, Windows.Web.Syndication.ISyndicationNode {
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        collections: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.ResourceCollection>;
        title: Windows.Web.Syndication.ISyndicationText;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

}
declare module Windows.Web.Syndication {

    export interface ISyndicationAttribute {
        name: string;
        namespace: string;
        value: string;
    }

    export interface ISyndicationCategory extends Windows.Web.Syndication.ISyndicationNode {
        label: string;
        scheme: string;
        term: string;
    }

    export interface ISyndicationClient {
        setRequestHeader(name: string, value: string): void;
        retrieveFeedAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationFeed,Windows.Web.Syndication.RetrievalProgress>;
        bypassCacheOnRetrieve: boolean;
        maxResponseBufferSize: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        timeout: number;
    }

    export interface ISyndicationContent extends Windows.Web.Syndication.ISyndicationText, Windows.Web.Syndication.ISyndicationNode {
        sourceUri: Windows.Foundation.Uri;
    }

    export interface ISyndicationFeed extends Windows.Web.Syndication.ISyndicationNode {
        load(feed: string): void;
        loadFromXml(feedDocument: Windows.Data.Xml.Dom.XmlDocument): void;
        authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
        contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        firstUri: Windows.Foundation.Uri;
        generator: Windows.Web.Syndication.SyndicationGenerator;
        iconUri: Windows.Foundation.Uri;
        id: string;
        imageUri: Windows.Foundation.Uri;
        items: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationItem>;
        lastUpdatedTime: Date;
        lastUri: Windows.Foundation.Uri;
        links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
        nextUri: Windows.Foundation.Uri;
        previousUri: Windows.Foundation.Uri;
        rights: Windows.Web.Syndication.ISyndicationText;
        sourceFormat: Windows.Web.Syndication.SyndicationFormat;
        subtitle: Windows.Web.Syndication.ISyndicationText;
        title: Windows.Web.Syndication.ISyndicationText;
    }

    export interface ISyndicationGenerator {
        text: string;
        uri: Windows.Foundation.Uri;
        version: string;
    }

    export interface ISyndicationItem extends Windows.Web.Syndication.ISyndicationNode {
        load(item: string): void;
        loadFromXml(itemDocument: Windows.Data.Xml.Dom.XmlDocument): void;
        authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
        commentsUri: Windows.Foundation.Uri;
        content: Windows.Web.Syndication.SyndicationContent;
        contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        eTag: string;
        editMediaUri: Windows.Foundation.Uri;
        editUri: Windows.Foundation.Uri;
        id: string;
        itemUri: Windows.Foundation.Uri;
        lastUpdatedTime: Date;
        links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
        publishedDate: Date;
        rights: Windows.Web.Syndication.ISyndicationText;
        source: Windows.Web.Syndication.SyndicationFeed;
        summary: Windows.Web.Syndication.ISyndicationText;
        title: Windows.Web.Syndication.ISyndicationText;
    }

    export interface ISyndicationLink extends Windows.Web.Syndication.ISyndicationNode {
        length: number;
        mediaType: string;
        relationship: string;
        resourceLanguage: string;
        title: string;
        uri: Windows.Foundation.Uri;
    }

    export interface ISyndicationNode {
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export interface ISyndicationPerson extends Windows.Web.Syndication.ISyndicationNode {
        email: string;
        name: string;
        uri: Windows.Foundation.Uri;
    }

    export interface ISyndicationText extends Windows.Web.Syndication.ISyndicationNode {
        text: string;
        type: string;
        xml: Windows.Data.Xml.Dom.XmlDocument;
    }

    export class RetrievalProgress {
        bytesRetrieved: number;
        totalBytesToRetrieve: number;
    }

    export class SyndicationAttribute implements Windows.Web.Syndication.ISyndicationAttribute {
        constructor(attributeName: string, attributeNamespace: string, attributeValue: string);
        constructor();
        name: string;
        namespace: string;
        value: string;
    }

    export class SyndicationCategory implements Windows.Web.Syndication.ISyndicationCategory, Windows.Web.Syndication.ISyndicationNode {
        constructor(term: string);
        constructor(term: string, scheme: string, label: string);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        label: string;
        scheme: string;
        term: string;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationClient implements Windows.Web.Syndication.ISyndicationClient {
        constructor(serverCredential: Windows.Security.Credentials.PasswordCredential);
        constructor();
        setRequestHeader(name: string, value: string): void;
        retrieveFeedAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationFeed,Windows.Web.Syndication.RetrievalProgress>;
        bypassCacheOnRetrieve: boolean;
        maxResponseBufferSize: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        timeout: number;
    }

    export class SyndicationContent implements Windows.Web.Syndication.ISyndicationText, Windows.Web.Syndication.ISyndicationNode, Windows.Web.Syndication.ISyndicationContent {
        constructor(text: string, type: Windows.Web.Syndication.SyndicationTextType);
        constructor(sourceUri: Windows.Foundation.Uri);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        text: string;
        type: string;
        xml: Windows.Data.Xml.Dom.XmlDocument;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
        sourceUri: Windows.Foundation.Uri;
    }

    export class SyndicationError {
        static getStatus(hresult: number): Windows.Web.Syndication.SyndicationErrorStatus;
    }

    enum SyndicationErrorStatus {
        unknown,
        missingRequiredElement,
        missingRequiredAttribute,
        invalidXml,
        unexpectedContent,
        unsupportedFormat
    }

    export class SyndicationFeed implements Windows.Web.Syndication.ISyndicationFeed, Windows.Web.Syndication.ISyndicationNode {
        constructor(title: string, subtitle: string, uri: Windows.Foundation.Uri);
        constructor();
        load(feed: string): void;
        loadFromXml(feedDocument: Windows.Data.Xml.Dom.XmlDocument): void;
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
        contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        firstUri: Windows.Foundation.Uri;
        generator: Windows.Web.Syndication.SyndicationGenerator;
        iconUri: Windows.Foundation.Uri;
        id: string;
        imageUri: Windows.Foundation.Uri;
        items: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationItem>;
        lastUpdatedTime: Date;
        lastUri: Windows.Foundation.Uri;
        links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
        nextUri: Windows.Foundation.Uri;
        previousUri: Windows.Foundation.Uri;
        rights: Windows.Web.Syndication.ISyndicationText;
        sourceFormat: Windows.Web.Syndication.SyndicationFormat;
        subtitle: Windows.Web.Syndication.ISyndicationText;
        title: Windows.Web.Syndication.ISyndicationText;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    enum SyndicationFormat {
        atom10,
        rss20,
        rss10,
        rss092,
        rss091,
        atom03
    }

    export class SyndicationGenerator implements Windows.Web.Syndication.ISyndicationGenerator, Windows.Web.Syndication.ISyndicationNode {
        constructor(text: string);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        text: string;
        uri: Windows.Foundation.Uri;
        version: string;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationItem implements Windows.Web.Syndication.ISyndicationItem, Windows.Web.Syndication.ISyndicationNode {
        constructor(title: string, content: Windows.Web.Syndication.SyndicationContent, uri: Windows.Foundation.Uri);
        constructor();
        load(item: string): void;
        loadFromXml(itemDocument: Windows.Data.Xml.Dom.XmlDocument): void;
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
        commentsUri: Windows.Foundation.Uri;
        content: Windows.Web.Syndication.SyndicationContent;
        contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        eTag: string;
        editMediaUri: Windows.Foundation.Uri;
        editUri: Windows.Foundation.Uri;
        id: string;
        itemUri: Windows.Foundation.Uri;
        lastUpdatedTime: Date;
        links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
        publishedDate: Date;
        rights: Windows.Web.Syndication.ISyndicationText;
        source: Windows.Web.Syndication.SyndicationFeed;
        summary: Windows.Web.Syndication.ISyndicationText;
        title: Windows.Web.Syndication.ISyndicationText;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationLink implements Windows.Web.Syndication.ISyndicationLink, Windows.Web.Syndication.ISyndicationNode {
        constructor(uri: Windows.Foundation.Uri);
        constructor(uri: Windows.Foundation.Uri, relationship: string, title: string, mediaType: string, length: number);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        length: number;
        mediaType: string;
        relationship: string;
        resourceLanguage: string;
        title: string;
        uri: Windows.Foundation.Uri;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationNode implements Windows.Web.Syndication.ISyndicationNode {
        constructor(nodeName: string, nodeNamespace: string, nodeValue: string);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationPerson implements Windows.Web.Syndication.ISyndicationPerson, Windows.Web.Syndication.ISyndicationNode {
        constructor(name: string);
        constructor(name: string, email: string, uri: Windows.Foundation.Uri);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        email: string;
        name: string;
        uri: Windows.Foundation.Uri;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationText implements Windows.Web.Syndication.ISyndicationText, Windows.Web.Syndication.ISyndicationNode {
        constructor(text: string);
        constructor(text: string, type: Windows.Web.Syndication.SyndicationTextType);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        text: string;
        type: string;
        xml: Windows.Data.Xml.Dom.XmlDocument;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    enum SyndicationTextType {
        text,
        html,
        xhtml
    }

    export class TransferProgress {
        bytesSent: number;
        totalBytesToSend: number;
        bytesRetrieved: number;
        totalBytesToRetrieve: number;
    }

}
declare module Windows.Web {

    export class WebError {
        static getStatus(hresult: number): Windows.Web.WebErrorStatus;
    }

    enum WebErrorStatus {
        unknown,
        certificateCommonNameIsIncorrect,
        certificateExpired,
        certificateContainsErrors,
        certificateRevoked,
        certificateIsInvalid,
        serverUnreachable,
        timeout,
        errorHttpInvalidServerResponse,
        connectionAborted,
        connectionReset,
        disconnected,
        httpToHttpsOnRedirection,
        httpsToHttpOnRedirection,
        cannotConnect,
        hostNameNotResolved,
        operationCanceled,
        redirectFailed,
        unexpectedStatusCode,
        unexpectedRedirection,
        unexpectedClientError,
        unexpectedServerError,
        multipleChoices,
        movedPermanently,
        found,
        seeOther,
        notModified,
        useProxy,
        temporaryRedirect,
        badRequest,
        unauthorized,
        paymentRequired,
        forbidden,
        notFound,
        methodNotAllowed,
        notAcceptable,
        proxyAuthenticationRequired,
        requestTimeout,
        conflict,
        gone,
        lengthRequired,
        preconditionFailed,
        requestEntityTooLarge,
        requestUriTooLong,
        unsupportedMediaType,
        requestedRangeNotSatisfiable,
        expectationFailed,
        internalServerError,
        notImplemented,
        badGateway,
        serviceUnavailable,
        gatewayTimeout,
        httpVersionNotSupported
    }

}

